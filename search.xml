<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>个人学习阶段总结及博客未来计划</title>
      <link href="/posts/c2af516c/"/>
      <url>/posts/c2af516c/</url>
      
        <content type="html"><![CDATA[<p>近一个月，我坚持每天早上7点左右起床，并通过看各专栏和书籍学习技术，晚上如果不用加班，我也会去学习算法或者一些新技术的基本概念。如今月底了，回顾这一个月，我发现自己的技术能力确实有些许提高，整体而言，整个过程与我的预期虽然还有差距，但自己的坚持和努力还是有明显成效，这个值得肯定。</p><p>然而，抛开自己与女友去玩耍约会的时间，抛开因为工作原因必须加班坚守阵地的时间，我在学习上的时间其实并不算少，但我却感觉到自己并没有真正吸收全部知识。</p><p>当然，如果吸收全部知识这个前提本身是无法完成的，那我不会纠结，而我纠结就在于这个前提可实现，实现的方法论有很多，并且我在整个学习过程中也进行了不少总结，所以基于这个点，我要把自己的方法论结合自身情况，做一个简单的规划和总结。</p><h2 id="学习感悟"><a href="#学习感悟" class="headerlink" title="学习感悟"></a>学习感悟</h2><p>首先我要先做一个深刻的反省，吾日三省吾身，好的总结习惯，会让我们明白自身问题，并做到真正意义上的进步，而不是停留在意淫阶段。</p><p>在整个学习的阶段，我曾迷茫和焦虑过，迷茫于这么多知识我该从哪入手，焦虑于工作没有完成我该如何有效规划时间，去学习新知识，巩固旧概念。所以有段时间，我陷入了一学习就焦虑的状况，为啥呀？因为感觉学着碗里的，盼着锅里的，想着看看mysql底层实现，又觉得spark源码还有那么多没读过，另一边工作上flink又是刚接触，心底没有一个整体概念，怎么也得先深入学习下flink吧。如此这般循环，最后沦入深深无力感中，啥也没干好，时间却呼啦啦消逝。</p><p>这是一个大问题。</p><p>另外一边，学习成效上，我没有认真去执行高效学习的理论。何为高效学习的理论？就个人阅读的书籍总结而言，就是围绕<code>记忆和学习方法</code>做的一些优化手段。这些手段在普通人眼里是耗费时间的，于是没有去执行和遵守，最后却发现自己现在的行为才是冤大头。譬如我，我知道艾宾浩斯遗忘曲线，我知道总结并不等于了解，所以正确的学习姿势应该是：</p><blockquote><p>把每天学习的知识总结，并根据遗忘曲线的遗忘效率进行及时有效的复习，直到知识点巩固，最后再做命题测验，深入了解知识点内部原理。  </p></blockquote><p>而我呢，没有这么做，因为我在想，总结和复习是耗费时间的，我要做的应该是不断学习新知识，或者想着在一段时间的专题学习后，再回顾总结。然而，现实总比预期残酷，命运的捉弄不在乎who are u，绝大部分人的记忆都离不开遗忘曲线的作用范围，所以不及时复习的学习，只会花费更多时间才能巩固和记忆。</p><h2 id="个人问题解决方案"><a href="#个人问题解决方案" class="headerlink" title="个人问题解决方案"></a>个人问题解决方案</h2><p>发现了问题，那就得解决问题。</p><h3 id="学习焦虑解决方案"><a href="#学习焦虑解决方案" class="headerlink" title="学习焦虑解决方案"></a>学习焦虑解决方案</h3><p>焦虑的产生核心点在<code>不可掌握</code>，不可掌握又分为两点，其一为要做的事情太多，其二为没有事情可做。事情太多则头绪混乱，不知所措。无事可做则担心淘汰，无法生存。而不可掌握的感知，就在注意力。如果把注意力集中在做，而不是需要做的，那焦虑就会不攻而破。</p><p>所以解决方案很简单，两个问题两个解决的点</p><h4 id="解决一：攻破精神陷阱"><a href="#解决一：攻破精神陷阱" class="headerlink" title="解决一：攻破精神陷阱"></a>解决一：攻破精神陷阱</h4><p>我们要明白焦虑是精神陷阱，是人给自己带来的精神压力，最近明星自杀和明星猝死的新闻越发增多，这让我明白，学习与进步是必须要做的，但不能牺牲健康，精神压力过大，也是不健康的表现。</p><p>顶着巨大精神压力去生活，去工作，去进步，它的效率是<code>事倍功半</code>的，那是自我安慰的努力，毫成效可言。此时如果放下执念，放平心态，做一个简单的休息，整装待续，精神焕发，来个深呼吸，感受生命气息，再重新起步，才会明白努力的意义。</p><p>在这个方案中，我想特别提一个前提，那就是：<code>精神的丰富是必要的</code>。举个例子，我叫你休息，你去刷抖音，这在你眼里是休息，但却是另一种注意力耗散，会让你更加疲惫。那你问我，你该如何休息，我说，我不知道，只有你知道，然后你说，你知道的就是刷抖音，但其实<code>这里所说的你，是经过丰富阅读，丰富人生经历，丰富思考造就的你</code>，相比幼稚的你，这时的你是智慧的，了解自己，了解世界，了解心与灵魂的需求。相信我，这时的你不会把刷抖音当作休息的唯一途径。</p><p>所以一个人在<code>他的精神生活是丰富的前提下</code>，他才会真正明白自己所想要的，也才会明白什么是休息，什么是人生，什么是当下最重要的事情。</p><p>于是，我提倡，不要因为工作泯灭人性，不要因为学习忘记天的蓝，不要因为害怕躲避生命的风险。</p><h4 id="解决二：把注意力放到执行上"><a href="#解决二：把注意力放到执行上" class="headerlink" title="解决二：把注意力放到执行上"></a>解决二：把注意力放到执行上</h4><p>如果要把注意力放执行上，必须有个前提 —— 我知道该做什么。</p><p>所以关于这个的解决方案，我给自己设立了四象限的学习维度。分别是：</p><ol><li>简单的</li><li>复杂的</li><li>重要的</li><li>紧急的</li></ol><p>优先级应该是这样：<br>紧急 &gt; 简单 &gt;= 重要 &gt;= 复杂</p><p>然后把当前的事情归类，做一个学习规划。在规划的过程中，必须要认真谨慎，考虑各种不同因素和情况。做好规划后，坚定执行，不考虑规划外的事情，只考虑怎么把当前事情做好，如此这般，注意力集中就会少焦虑的产生。</p><h3 id="学习理论的实践方案"><a href="#学习理论的实践方案" class="headerlink" title="学习理论的实践方案"></a>学习理论的实践方案</h3><p>学习理论的实践，我推荐李笑来的《把时间当做朋友》和采铜的《精进》和《刻意练习》，这三本书有学习的理论，我这就不展开谈。</p><p>学习本身就是记忆和加工的过程，而记忆如果没东西，那加工啥玩意。所以记忆很重要，加工也很重要。所以关于学习理论的实践，主要有两个点需要攻破。</p><h4 id="解决一：遗忘曲线"><a href="#解决一：遗忘曲线" class="headerlink" title="解决一：遗忘曲线"></a>解决一：遗忘曲线</h4><p>遗忘曲线的核心在不同的遗忘点，进行不同程度的复习。关于复习，必须精简。我们在最初的学习阶段，会涉及很多概念去堆砌出最后的结论，而我们的复习阶段则是记忆结论。为何？因为时间有限。所以想要复习，离不开<code>总结</code>，而总结有讲究，个人认为有几个点：</p><ol><li>总结不是复制粘贴，而要把新知识和知识框架进行融合后输出</li><li>总结需要归纳，归纳需要层级，总结结论如何生成，要有简单过程</li><li>总结需要有：<blockquote><p>知识本身 + 给知识分维度（如简单、未理解、易错等） + 实践和展望（融合自身情况）</p></blockquote></li></ol><h4 id="解决二：加工方案"><a href="#解决二：加工方案" class="headerlink" title="解决二：加工方案"></a>解决二：加工方案</h4><p>当脑子有很多材料时，我们该如何进行加工，就会决定我们最后加工的效率和东西的质地。</p><h5 id="知识体系构建"><a href="#知识体系构建" class="headerlink" title="知识体系构建"></a>知识体系构建</h5><p>加工的过程离不开知识体系的构建，这个知识体系不是指专业的知识体系，而是上文所讲的，<code>体验</code>所产生的知识体系，这个知识体系会包含各个学科的知识，并且夹杂自身独特的人生经历和思考。丰富的知识体系会给大脑提供源源不断的灵感，所以专业并非好，而我们所说专业好，这不过是因为在人有限精力和注意力下的最好解决方案。</p><p>但知识体系这玩意不是短时间能搞定的，这个需要时间的积累，需要注意力的堆砌，当我们清楚，我们所作的每一次学习都会为日后提供构建知识体系的原材料时，我们每做的一件事都会谨慎和深邃许多。</p><h5 id="一段时间只做一件事情"><a href="#一段时间只做一件事情" class="headerlink" title="一段时间只做一件事情"></a>一段时间只做一件事情</h5><p>在上文的学习规划中，我没有提到一个很重要的点，叫做<code>一段时间只做一件事情</code>。这是我结合刻意练习和自身出现问题所做的总结。</p><p>前段时间我经历了一个星期做几个知识点学习的规划，但整体下来，我好像都没做好，并且产生焦虑。后来我放下追求完美的念头后，我根据优先级排序，规定了一段时间只做一件事情，我发现焦虑消失了，并且学习更加深入。</p><p>在学习领域，有两个区域需要注意，一个叫展示区，一个叫学习区。展示区是你利用现有知识去解决问题的阶段，而学习区，则是刻意练习中说到的有目的性学习。在刻意练习中讲到的<code>有目的性去学习</code>意思是，带着问题，带着规划去学习。这个过程，我们发现，有目的性学习就会有反馈，有反馈就会有成功与失败，有失败就能总结然后进步。这明显是个正向循环。</p><p>有目的性学习和一段时间只做一件事情的好处很明显，因为它们能让你深入理解一个知识点。在你规划一段时间有目的性学习的时候，一定要找到每个知识点的核心内容，譬如：明白spark的运行原理，如果要你设计，或者遇到类似知识点问题，你就能很快速解决。</p><h2 id="博客规划"><a href="#博客规划" class="headerlink" title="博客规划"></a>博客规划</h2><p>综上所述，我分析了自身问题，并提供解决方案，最后我想利用博客做一个简单规划和实践。每天我会把自己的技术学习进行总结汇报，记录到博客。但这个过程中，总会出现电脑不在身边或者今天因为某些原因没有学习的情况，如果是因为没有学习当天则不做记录，如果因为电脑不在，我会找时间上传到博客。</p><p>总结规划：</p><ol><li>写每日博客</li><li>阶段性学习后，做整体学习总结</li><li>每天写博客前复习上一篇和上上篇博客内容</li></ol><p>以上，愿自己坚持到完成个人目标</p><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
          <category> 阶段总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习总结 </tag>
            
            <tag> 个人总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm知识汇总</title>
      <link href="/posts/de2d575e/"/>
      <url>/posts/de2d575e/</url>
      
        <content type="html"><![CDATA[<p>这个栏目主要是把各jvm的知识模块进行链接汇总，方便自己的学习与复习</p><h1 id="jvm的内存结构"><a href="#jvm的内存结构" class="headerlink" title="jvm的内存结构"></a>jvm的内存结构</h1><h1 id="jvm的oom汇总"><a href="#jvm的oom汇总" class="headerlink" title="jvm的oom汇总"></a>jvm的oom汇总</h1><h1 id="jvm的jmm是什么"><a href="#jvm的jmm是什么" class="headerlink" title="jvm的jmm是什么"></a>jvm的jmm是什么</h1><h1 id="jvm的类加载过程"><a href="#jvm的类加载过程" class="headerlink" title="jvm的类加载过程"></a>jvm的类加载过程</h1><ol><li><a href="https://www.jianshu.com/p/202f6abb229c" target="_blank" rel="noopener">java类加载过程</a></li></ol><h1 id="双亲委派机制怎么理解"><a href="#双亲委派机制怎么理解" class="headerlink" title="双亲委派机制怎么理解"></a>双亲委派机制怎么理解</h1><h1 id="类加载器的实现原理"><a href="#类加载器的实现原理" class="headerlink" title="类加载器的实现原理"></a>类加载器的实现原理</h1><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
          <category> 汇总 </category>
          
          <category> hide </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表的算法题</title>
      <link href="/posts/63112dd/"/>
      <url>/posts/63112dd/</url>
      
        <content type="html"><![CDATA[<p>记得以前刚开始学习链表，对指针和方向的定义和判断难以理解，如今经过学习再回顾，慢慢知晓学习的本质就是反人性的重复，当达到一定的重复，所有的难理解不过是茶余饭后对过去愚笨自己的无奈。</p><p>针对链表，列出几个常面试的题目，便于后续自己的复习，持续更新。</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表统一代码实现"><a href="#链表统一代码实现" class="headerlink" title="链表统一代码实现"></a>链表统一代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表的定义可以自行百度了解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Node node_v1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        Node node_v2 = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        Node node_v3 = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        Node node_v4 = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        Node node_v5 = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        node_v1.next = node_v2;</span><br><span class="line">        node_v2.next = node_v3;</span><br><span class="line">        node_v3.next = node_v4;</span><br><span class="line">        node_v4.next = node_v5;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入一个单链表，输出该链表的反转链表</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个题目不难，链表是有指针的，把指针倒转过来就是反向链表。<br>如 1 -&gt; 2 -&gt; 3 -&gt; 4 的反向链表就是：<br>4 -&gt; 3 -&gt; 2 -&gt; 1</p><blockquote><p>核心点在：node.next = pre</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linked_Revered</span></span>&#123;</span><br><span class="line">    <span class="comment">// 非递归方案</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revered</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node pre = <span class="keyword">null</span>;</span><br><span class="line">        Node next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            next = node.next;</span><br><span class="line">            node.next = pre;</span><br><span class="line">            pre = node;</span><br><span class="line">            node = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归方案</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revered_digui</span><span class="params">(Node node,Node pre)</span></span>&#123;</span><br><span class="line">        Node next = node.next;</span><br><span class="line">        node.next = pre; <span class="comment">// 核心点，只要根据这个推导即可明白</span></span><br><span class="line">        revered_digui(next,node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revered_digui_v1</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span> || node.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为了递归到最后一个链表结点，用于后面反转</span></span><br><span class="line">        Node nextNode = revered_digui_v1(node.next);</span><br><span class="line">        <span class="comment">// 反转链表</span></span><br><span class="line">        node.next.next = node;</span><br><span class="line">        <span class="comment">// 把当前链表进行切断</span></span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求有环链表的入口结点"><a href="#求有环链表的入口结点" class="headerlink" title="求有环链表的入口结点"></a>求有环链表的入口结点</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>输入一个单链表，求他的环的入口结点</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>输入一个单链表，求环的入口，我们首先需要明确该链表是否有环，有环又该如何求入口结点，所以主要解决三个问题即可：</p><blockquote><ol><li>判断单链表是否有环</li><li>判断环的长度是多少，长度可用于协助计算入口结点</li><li>定位环的入口结点位置</li></ol></blockquote><p>话不多说，看代码马上明白每步的作用</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linked_Round</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">Detect_Round</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node fast = node;</span><br><span class="line">        Node slow = node;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个同时从头结点出发，一个一下走两步，一个走一步</span></span><br><span class="line"><span class="comment">        有两种情况：</span></span><br><span class="line"><span class="comment">        1、当 next 出现null的情况，说明没有环</span></span><br><span class="line"><span class="comment">        2、当 fast 和 slow 相遇了，说明有环</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">while</span>(slow.next != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算环的长度</span></span><br><span class="line">        len = <span class="number">1</span>;</span><br><span class="line">        Node currend_node = slow.next;</span><br><span class="line">        <span class="keyword">while</span>(slow.value != currend_node.value)</span><br><span class="line">            &#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                len ++;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用快慢指针，计算相遇时的结点，相遇结点就是入口结点</span></span><br><span class="line">        Node first_node = node; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            first_node = first_node.next;</span><br><span class="line">        </span><br><span class="line">        Node second_node = node;</span><br><span class="line">        <span class="keyword">while</span>(second_node.value != first_node.value)&#123;</span><br><span class="line">            second_node = second_node.next;</span><br><span class="line">            first_node = first_node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> second_node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有序链表合并"><a href="#有序链表合并" class="headerlink" title="有序链表合并"></a>有序链表合并</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>有点类似归并排序，只是归并用的是数组，这里用的是链表</p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedMixed</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Linked</span><span class="params">(Node node1,Node node2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node1 == <span class="keyword">null</span>) <span class="keyword">return</span> node2;</span><br><span class="line">        <span class="keyword">if</span>(node2 == <span class="keyword">null</span>) <span class="keyword">return</span> node1;</span><br><span class="line">                </span><br><span class="line">        Node head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 明确思路是：</span></span><br><span class="line"><span class="comment">        * 升序的话：每一层返回的都是小的</span></span><br><span class="line"><span class="comment">        * 降序的话：每一层返回的都是大的</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span>(node1.value &lt;= node2.value)&#123;</span><br><span class="line">            head = node1;</span><br><span class="line">            head.next = Linked(node1.next,node2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head = node2;</span><br><span class="line">            head.next = Linked(node1,node2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除单链表倒数第n个结点"><a href="#删除单链表倒数第n个结点" class="headerlink" title="删除单链表倒数第n个结点"></a>删除单链表倒数第n个结点</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这个思路和寻找入口结点的链表题目基本一致。用到快慢指针。代码逻辑主要两步：</p><blockquote><ol><li>用快慢指针方法确定需要删除的结点</li><li>如何删除结点</li></ol></blockquote><p>但这里需要考虑一种情况：</p><blockquote><p>如果只有一个结点，需要怎么处理</p></blockquote><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedLast</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">Linked</span><span class="params">(Node node,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        Node first = node;</span><br><span class="line">        Node sencond = node;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一个结点的情况</span></span><br><span class="line">        <span class="keyword">if</span>(first == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node.next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.确定删除结点位置</span></span><br><span class="line">        <span class="keyword">while</span>(first!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            sencond = sencond.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除结点</span></span><br><span class="line">        sencond.next = sencond.next.next;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java OOM 各情况分析</title>
      <link href="/posts/50474098/"/>
      <url>/posts/50474098/</url>
      
        <content type="html"><![CDATA[<p>最近在学习jvm，结合线上任务，最常见的就是java的oom，为了快速解决生产环境出现的oom问题，特此总结各oom解决方案  </p><p>本文基于jdk8版本探讨oom情况，不同于jdk8以前版本，jdk8用元空间代替永久代，所以不会有永久代的oom报错，取而代之的是元空间的oom报错。</p><p>这里记录一个小知识，我们常说的方法区其实是逻辑概念，永久代和元空间是实现这个概念的具体方案，所以其实可以把元空间当作是新的方法区实现。元空间利用的是直接内存，但会进行gc</p><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jvm oom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> hide </tag>
            
            <tag> java </tag>
            
            <tag> oom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer习题归纳（持续更新）</title>
      <link href="/posts/a95aad52/"/>
      <url>/posts/a95aad52/</url>
      
        <content type="html"><![CDATA[<p>参考：<br><a href="https://www.cnblogs.com/yongh/p/9637260.html" target="_blank" rel="noopener">剑指offer java实现</a><br><a href="https://study.163.com/course/introduction.htm?courseId=1002942008#/courseDetail?tab=1" target="_blank" rel="noopener">课程列表 可以当作学习方向</a></p><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 剑指offer归纳 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优先级队列 java实现</title>
      <link href="/posts/323450f/"/>
      <url>/posts/323450f/</url>
      
        <content type="html"><![CDATA[<p>最近有一个同事走了，去了美团风控，这几个月的面试，他手里拿了头条、携程的offer，羡慕之余，我还向他取了经。整体而言，他和我说，除了项目的介绍，对大数据框架的认识以外，特别需要关注的就是算法和数据结构。然而，自己在这方面的造诣确实很少，所以后续时间，我会按数据结构类型（着重链表、树等）刷题，并且总结到博客中。</p><p>回想和他的交流过程，印象里他提到了 <strong><em>优先级队列</em></strong> ，当时并不知道什么东西，回来一看，我才发现，这不就是堆排序的变种嘛。因为最近刚刷过堆排序，所以对实现方式了如指掌。</p><p>正当我大展身手，准备手写一番时，我无意之间看到java的优先级队列底层的源码实现，我那一个震惊，竟然有如此巧妙和简单的实现方式，刹那间，我对java那岂是简单的心生爱恋，简直爱不释手。就此，我便准备用java实现优先级队列。</p><h1 id="什么是优先级队列"><a href="#什么是优先级队列" class="headerlink" title="什么是优先级队列"></a>什么是优先级队列</h1><p>优先级队列的理解很简单，把这个词拆分成两个名词，马上就能明白，分别是 优先级 + 队列。</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>优先级指的是按照特定的排序算法，或者说比较算法，来实现队列元素的顺序提取。最简单的就是按数字的升序进行元素提取。所以核心点就在于</p><blockquote><p>如何确保 <strong><em>在乱序添加元素的前提下，还能有序的提取元素</em></strong></p></blockquote><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列就是一个数据结构，什么数据结构呢？</p><blockquote><p>元素按照顺序，先进先出的数据结构。具体实现方式可以用链表和数组。</p></blockquote><p>就像排队吃饭一样，排到前面的先吃饭，排到最后就没饭吃是一个道理。</p><h1 id="java实现及解释"><a href="#java实现及解释" class="headerlink" title="java实现及解释"></a>java实现及解释</h1><h2 id="实现优先级队列的算法"><a href="#实现优先级队列的算法" class="headerlink" title="实现优先级队列的算法"></a>实现优先级队列的算法</h2><p>其实实现优先级算法有挺多，最简单的就是每次添加元素就遍历队列，接着遍历出来的每个元素和添加的元素进行比较，然后把当前元素插入合适的位置。</p><p>但这种实现方式的时间复杂度为 O(n)，因为涉及到一个for循环。对于数据结构的实现，我们要优先考虑时间复杂度。那有啥好办法木有，有的，堆排序在众多排序中，时间复杂度是比较稳定的，为logn。所以对于优先级队列的默认实现，用到的是堆排序。（什么是堆排序，可以看我博客的 <a href="http://jskblog.xyz/posts/7ad6c44f/">十大排序中的堆排序</a>）</p><h2 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h2><p>关于java代码实现，主要两个点：</p><blockquote><ol><li>添加元素：需要元素上推构建堆逻辑</li><li>取出元素：需要元素下推构建堆逻辑</li></ol></blockquote><p>以上面两个为核心，进行逻辑实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">priQueue</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size_default = <span class="number">0</span>;</span><br><span class="line">    Object[] queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> default_size = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">priQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[default_size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> size,<span class="keyword">int</span> element)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 构建小顶堆</span></span><br><span class="line">        Comparable&lt;Integer&gt; element_com = element; <span class="comment">//把element变成可比较对象</span></span><br><span class="line">        <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = (size-<span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 取出父节点的下标</span></span><br><span class="line">            Object parent = queue[index]; <span class="comment">// 父节点的值</span></span><br><span class="line">            <span class="keyword">if</span>(element_com.compareTo((Integer) parent) &gt;= <span class="number">0</span>) <span class="comment">//父节点和当前元素进行比较</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 如果当前元素比父节点大，则跳出循环，直接添加到末尾</span></span><br><span class="line">            queue[size] = parent; <span class="comment">// 如果没有跳出循环，说明当前元素比父节点小，父节点放最后</span></span><br><span class="line">            size = index; <span class="comment">// size减少，用于上面index上推找父节点的父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue[size] = element;<span class="comment">//把添加元素添加到queue中</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = size_default; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(size&gt;=queue.length)&#123;<span class="comment">//延长数组</span></span><br><span class="line">            queue = Arrays.copyOf(queue,size+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size_default = size+<span class="number">1</span>;<span class="comment">//因为添加元素了，所以size+1</span></span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            queue[<span class="number">0</span>] = element;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            siftUp(size,element);<span class="comment">//上推构建顶堆</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> size,<span class="keyword">int</span> element)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 构建小顶堆，构建顶堆的过程，会直接替换掉原 size 下标的值</span></span><br><span class="line">        <span class="keyword">int</span> half = size_default &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 运算符运算 ：size/2 的意思 一半值</span></span><br><span class="line">        <span class="keyword">while</span>(size &lt; half)&#123;</span><br><span class="line">            <span class="keyword">int</span> child = (size &lt;&lt; <span class="number">1</span> ) + <span class="number">1</span>; <span class="comment">// size*2 + 1 size下标节点的左子节点</span></span><br><span class="line">            Object child_element = queue[child]; <span class="comment">// 左子节点</span></span><br><span class="line">            <span class="keyword">int</span> right = child+<span class="number">1</span>; <span class="comment">// 右子节点</span></span><br><span class="line">            <span class="keyword">if</span>(child++ &lt; half &amp;&amp;</span><br><span class="line">                    ((Comparable&lt;Integer&gt;)child_element).compareTo((Integer)queue[right]) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                child_element = queue[child = right]; <span class="comment">// 比较左右子节点哪个更小</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(((Comparable)element).compareTo(child_element) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//如果element 比 子节点还要小，不需要后续工作了，直接把element赋值给size下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            queue[size] = child_element; <span class="comment">// 如果上面没有跳出循环，说明子节点更小，把子节点值赋给size下标</span></span><br><span class="line">            size = child;<span class="comment">//size变成子节点下标，继续比较子节点的子节点大小，下推比较</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue[size] = element;<span class="comment">//把element赋值给size</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">poll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size_default == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//如果size没有了 直接返回null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s = -- size_default;<span class="comment">//s为下标值，size_default是数组长度，比下标多一位</span></span><br><span class="line">        Object result = queue[<span class="number">0</span>];<span class="comment">//取出首位</span></span><br><span class="line">        Object x = queue[s];<span class="comment">//取出末尾位</span></span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">0</span>)</span><br><span class="line">            siftDown(<span class="number">0</span>,(Integer) x);<span class="comment">//进行重构堆逻辑</span></span><br><span class="line">        <span class="keyword">return</span>  result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object[] return_queue()&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(queue,size_default);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 优先级队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> java </tag>
            
            <tag> 优先级队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java对象内存计算</title>
      <link href="/posts/a1f3afe4/"/>
      <url>/posts/a1f3afe4/</url>
      
        <content type="html"><![CDATA[<h1 id="java对象内存计算意义"><a href="#java对象内存计算意义" class="headerlink" title="java对象内存计算意义"></a>java对象内存计算意义</h1><p>最近在学习jvm的内存模型，学到参数调优的时候，我发现这个过程需要学会计算对象大小，并且根据具体场景模拟每秒进入内存的对象大小，以此为依据进行新生代和老年代的参数设置。</p><p>在我看着文章一段段说某个方法的大小是多少，然后假设每秒可以预估多少内存进入堆中，我陷入了惶恐，这说的都是啥玩意。</p><p>为了弥补这个知识盲点，方便个人日后的学习，或者在工作中的深入调优，对象的大小计算还是需要了解的。</p><p>当然如果是需要具体的对象大小，有相关工具和方法可以测量，但在具体生产调优中，我们更多的只是需要一个预估值，学习相关知识对预估是有一定帮助的。</p><h1 id="对象大小需要考虑的点"><a href="#对象大小需要考虑的点" class="headerlink" title="对象大小需要考虑的点"></a>对象大小需要考虑的点</h1><p>需要考虑的点不多，主要三点：</p><ol><li>对象头大小</li><li>数据类型大小</li><li>对齐填充</li></ol><p>如下图：</p><p><img alt="对象大小计算" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/java_class_photo.jpg" class="lozad"></p><h2 id="对象头大小"><a href="#对象头大小" class="headerlink" title="对象头大小"></a>对象头大小</h2><h3 id="对象头主要有两部分："><a href="#对象头主要有两部分：" class="headerlink" title="对象头主要有两部分："></a>对象头主要有两部分：</h3><ol><li>markoop（对象标记）：<blockquote><p>存储对象为：对象运行时数据，如哈希码、GC标记、锁信息、线程关联信息<br>占用内存大小：64为jvm上占用 8 字节</p></blockquote></li><li>klassoop（类元信息）：<blockquote><p>存储对象为：指向方法区的instanceKlass<br>占用内存大小：4个字节</p></blockquote></li></ol><p><strong><em>由上可知：对象头占的空间是 12字节，这是固定的</em></strong></p><h3 id="markoop-和-klassoop的简单介绍"><a href="#markoop-和-klassoop的简单介绍" class="headerlink" title="markoop 和 klassoop的简单介绍"></a>markoop 和 klassoop的简单介绍</h3><p>关于这两个点，可以很深入的去研究，但我们目前只需要知道类加载后，这两者生成的大概流程即可：</p><blockquote><p>一个java类被加载到vm时，会在方法区（如果不清楚，可以等待博主后续对jvm的更新）创建一个instanceKlass，来表示类的class信息。当我们的类用new创建新对象时，会在jvm的堆上创建一个instanceOopDesc对象。该对象就包含了对象头，对象头即包含上面说的两部分。然后这个实例对象会在对应的线程栈上创建一个引用，指向该实例对象。</p></blockquote><h2 id="数据类型大小"><a href="#数据类型大小" class="headerlink" title="数据类型大小"></a>数据类型大小</h2><p>这个是java的基础知识，相信大家对下面的表不会陌生：</p><table><thead><tr><th>类型</th><th>默认值</th><th>占用内存（字节）</th></tr></thead><tbody><tr><td>boolean</td><td>false</td><td>1</td></tr><tr><td>byte</td><td>0</td><td>1</td></tr><tr><td>short</td><td>0</td><td>2</td></tr><tr><td>char</td><td>\u00001</td><td>2</td></tr><tr><td>int</td><td>0</td><td>4</td></tr><tr><td>long</td><td>0</td><td>8</td></tr><tr><td>double</td><td>0</td><td>8</td></tr><tr><td>float</td><td>0</td><td>4</td></tr></tbody></table><p>上面是8种基本类型，但在对象内存占用计算中，还需要<strong><em>第九种类型</em></strong></p><table><thead><tr><th>类型</th><th>默认值</th><th>占用内存（字节）</th></tr></thead><tbody><tr><td>对象引用变量（Refrence Varible）</td><td>null</td><td>4</td></tr></tbody></table><p>假设对象引用变量简称refV，实际对象（Referred Object）为：refO：</p><blockquote><p>refV存储引用指向的实际对象的存储地址的首地址。可以直接用==做等值判断。作为对象的引用变量，refV无论指向包装类，集合类，字符串类，自定义类，还是数组，均占用4字节。<br>refO最小占用12字节，即只有对象头，但是要对齐填充，所以最小分配的内存空间是16字节。</p></blockquote><p><strong><em>如果用jvm知识解答，refV其实是会存放到方法栈中，与本文堆存储无关，但做为统一计算的学习也无可厚非</em></strong></p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>对象的存储空间的分配单位是8字节，当对象大小不是8的整数倍的时候需要填充对齐。譬如如果对象的总大小为 22 字节，为了填充成8的整数倍，则实际的内存大小为 24 字节。</p><h2 id="样例分析"><a href="#样例分析" class="headerlink" title="样例分析"></a>样例分析</h2><p>看下面几段java代码：</p><p>样例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> test_field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的内存大小为：</p><blockquote><p>int类型 4 字节 + 对象头 12 字节 = 16字节</p></blockquote><p>样例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> age; </span><br><span class="line">    test test_instance = <span class="keyword">new</span> test();</span><br><span class="line">    test2 test2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的内存大小为：</p><blockquote><p>double类型 8 字节 + test_instance的refv 4字节 + test2 的 4字节 + 对象头 12字节 = 8 + 4 + 4 + 12 = 28</p></blockquote><p><strong><em>因为28不是8的整数倍，所以最后为：32字节</em></strong></p><h3 id="样例2解答"><a href="#样例2解答" class="headerlink" title="样例2解答"></a>样例2解答</h3><blockquote><p>样例2中有两个对象初始化，无论是指向实例对象还是未指向实例对象，只要有类对象的引用，每个变量都占用 4 字节</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://yq.aliyun.com/articles/594507?utm_content=m_50650" target="_blank" rel="noopener">参考[1]</a><br><a href="https://juejin.im/post/5cafe99a6fb9a068553e14d2" target="_blank" rel="noopener">参考[2]</a></p><hr><center>谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
          <category> 对象内存计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 对象头 </tag>
            
            <tag> 内存计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序算法的实现和相关分析</title>
      <link href="/posts/7ad6c44f/"/>
      <url>/posts/7ad6c44f/</url>
      
        <content type="html"><![CDATA[<h1 id="排序说明"><a href="#排序说明" class="headerlink" title="排序说明"></a>排序说明</h1><p>因为室友面试被问到排序算法，当时他因为知识储备问题答不上，回来和我说起面试题，我想了想，发现自己对这块也不太熟悉，所以整理了一些重要的算法，进行python实现。</p><p>本文主要会涉及几个点：</p><ol><li>每个排序的python实现</li><li>一些排序思想的介绍</li><li>记录时间复杂度和空间复杂度</li><li>最后给自己留下题目，方便日后回顾</li></ol><h1 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h1><p>关于排序的大概介绍如下图：</p><p><img alt="各排序时间复杂度/空间复杂度/稳定性" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/sort_time.png" class="lozad"></p><blockquote><p>简单介绍一些概念：</p><blockquote><p>稳定性：在排序的过程中，相等的数是否会交换位置，会交换位置的算法则为 <strong><em>不稳定算法</em></strong><br>时间复杂度：通过大O算法进行初略进行算法的运行时间<br>空间复杂度：用到的内存初略计算</p></blockquote></blockquote><h1 id="各排序介绍"><a href="#各排序介绍" class="headerlink" title="各排序介绍"></a>各排序介绍</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><blockquote><p>最简单的排序算法<br>稳定性：稳定（如果里面的判断是= , 则为非稳定，正常默认冒泡排序为稳定算法）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    冒泡排序：</span></span><br><span class="line"><span class="string">    思路在 左右两个数 两两比较</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(arr)-i<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">                tmp = arr[j]</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>]</span><br><span class="line">                arr[j+<span class="number">1</span>] = tmp</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote><p>思路在：从头开始遍历，选择出最小值下标，然后进行最小值交换<br>稳定性：非稳定。<br>举例：5 8 5 2 1 第一次排序 2和5交换位置后，原先在前面的5到后面去了</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    选择排序：</span></span><br><span class="line"><span class="string">    思路在每次循环 选择最小的和当前循环的值进行转换</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    arr_len = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(arr_len):<span class="comment"># 循环数组长度</span></span><br><span class="line">        min_index = i <span class="comment"># 假设i为最小值的下标</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,arr_len,<span class="number">1</span>):<span class="comment"># 拿最小值下标和后面的数进行比较</span></span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[min_index]:</span><br><span class="line">                min_index = j <span class="comment"># 比较选出最小值</span></span><br><span class="line">        <span class="comment"># 交换最小值位置</span></span><br><span class="line">        tmp = arr[min_index]</span><br><span class="line">        arr[min_index] = arr[i]</span><br><span class="line">        arr[i] = tmp</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>思路在：current 为当前值，不断往前比较，确认达到最小/最大值 往那个index插入当前值<br>稳定性：稳定</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    插入排序：</span></span><br><span class="line"><span class="string">    思路在 current 为当前值，不断往前比较，确认达到最小/最大值 往那个index插入当前值</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    arr_len = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,arr_len):<span class="comment"># 注意是从1开始，而非0</span></span><br><span class="line">        index = i<span class="number">-1</span> <span class="comment"># 当前比较数下标的前一个index</span></span><br><span class="line">        current = arr[i] <span class="comment"># 当前需要进行比较的数</span></span><br><span class="line">        <span class="keyword">while</span> index&gt;=<span class="number">0</span> <span class="keyword">and</span> arr[index] &gt; current: <span class="comment"># 当前数和前一个数进行比较</span></span><br><span class="line">            arr[index+<span class="number">1</span>] = arr[index] <span class="comment"># 如果当前数比前一个数小，把前一个数的值赋给 当前比较数</span></span><br><span class="line">            index-=<span class="number">1</span> <span class="comment"># 继续往左比较</span></span><br><span class="line">        arr[index+<span class="number">1</span>] = current <span class="comment"># 比较结束后，如果上面没有进入循环，则index+1 其实就是当前比较数</span></span><br><span class="line">                                <span class="comment"># 如果进入了循环，右边的数不断往左移，跳出循环后，把当前数赋给index + 1 位置</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><blockquote><p>思想在：插入排序在小数据量的时候时间是教快的，希尔的思路在于，把大数据拆分成多个分区，不同分区用插入排序进行排序，最后融合<br>稳定性：非稳定</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shellSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    希尔排序：</span></span><br><span class="line"><span class="string">    思路在 分序列进行插入排序</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    arr_len = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(arr_len/<span class="number">2</span>):</span><br><span class="line">        插入排序</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote><p>快速排序是比较复杂的排序算法<br>思路在：<a href="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html" target="_blank" rel="noopener">快速排序参考资料（看完立马懂）</a><br>稳定性：非稳定</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(arr,start,end)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    快速排序：</span></span><br><span class="line"><span class="string">    思路在 选一个比较值 大的放右边 小的放左边 以此为逻辑递归执行</span></span><br><span class="line"><span class="string">    涉及递归，存在递归深度问题</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> start &gt;= end: <span class="keyword">return</span></span><br><span class="line">    temp = arr[start] <span class="comment"># 选出一个值作为比较值</span></span><br><span class="line">    left = start <span class="comment"># 开始下标</span></span><br><span class="line">    right = end <span class="comment"># 结束下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt; right: <span class="comment"># 判断下标没有碰面 才进行下一步操作</span></span><br><span class="line">        <span class="comment"># 外面的while用于判断是否继续进行循环比较</span></span><br><span class="line">        <span class="comment"># 里面的while用于控制范围缩小的区间</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> arr[right] &gt;= temp:<span class="comment"># 判断当前值是否小于比较值，当小于的时候则不继续循环，大于的时候则继续循环</span></span><br><span class="line">            right -= <span class="number">1</span> <span class="comment"># 一直往左进行范围缩小，直到小于比较值</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> arr[left] &lt;= temp: <span class="comment"># 和上面的循环判断相反</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; right: <span class="comment"># 交换两者的位置</span></span><br><span class="line">            arr[right] = arr[left] ^ arr[right]</span><br><span class="line">            arr[left] = arr[left] ^ arr[right]</span><br><span class="line">            arr[right] = arr[left] ^ arr[right]</span><br><span class="line">    <span class="comment"># 交换 比较值和left=right的值</span></span><br><span class="line">    arr[start] = arr[left]</span><br><span class="line">    arr[left] = temp</span><br><span class="line">    <span class="comment"># 以中间值左右划分，递归进行快速排序。递归会有深度问题，可以用栈的方式实现</span></span><br><span class="line">    quickSort(arr,start,left<span class="number">-1</span>)</span><br><span class="line">    quickSort(arr,left+<span class="number">1</span>,end)</span><br></pre></td></tr></table></figure><blockquote><p>下面是用栈的方式替代递归</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zhan_quickSort</span><span class="params">(arr,start,end)</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    stack.append(start)</span><br><span class="line">    stack.append(end)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">        end = stack.pop()</span><br><span class="line">        start = stack.pop()</span><br><span class="line"></span><br><span class="line">        index = baseSort(arr,start,end) <span class="comment"># 这一部分是上面去除quickSort递归前面的逻辑，直接返回中间值</span></span><br><span class="line">        <span class="keyword">if</span> index+<span class="number">1</span> &lt; right:</span><br><span class="line">            stack.append(index+<span class="number">1</span>)</span><br><span class="line">            stack.append(right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index<span class="number">-1</span> &gt; left:</span><br><span class="line">            stack.append(index<span class="number">-1</span>)</span><br><span class="line">            stack.append(left)</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote><p>思路在：用二分法 对数组进行切分，从最小值开始进行归并排序<br>稳定性：稳定</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(arr)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left,right)</span>:</span></span><br><span class="line">        merged = [] <span class="comment"># 创建一个数组</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># 下标判断，默认为0</span></span><br><span class="line">        left_len = len(left)</span><br><span class="line">        right_len = len(right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; left_len <span class="keyword">and</span> j &lt; right_len: <span class="comment"># 遍历传进来的两个数组，判断下标不会超过数组长度</span></span><br><span class="line">            <span class="keyword">if</span> left[i] &lt; right[j]: <span class="comment"># 对两个数组从0开始比较 符合条件的就把值添加到 新建的数组中</span></span><br><span class="line">                merged.append(left[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                merged.append(right[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 最后跳出循环，把剩余的元素给添加进 新建数组中</span></span><br><span class="line">        merged.extend(left[i:])</span><br><span class="line">        merged.extend(right[j:])</span><br><span class="line">        <span class="keyword">return</span> merged</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:<span class="keyword">return</span> arr <span class="comment"># 递归的返回条件</span></span><br><span class="line">    middle = len(arr)//<span class="number">2</span> <span class="comment"># 二分出左右两边数组</span></span><br><span class="line">    <span class="comment"># 递归左右两边数组</span></span><br><span class="line">    left = mergeSort(arr[:middle])</span><br><span class="line">    right = mergeSort(arr[middle:])</span><br><span class="line">    <span class="keyword">return</span> merge(left,right)</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><blockquote><p>堆排序是一个有意思的排序。思路在 构建顶堆，然后交换顶堆和最后的值<br>这里涉及两个概念：大顶堆 和 小顶堆<br>堆的概念: 堆指的是完全二叉树的数组对象，完全二叉树指的是 1、倒数第一层以前都为满节点 2、最后一层节点都靠左<br>大顶堆：节点值比子节点大（每个子树间比较），构建大顶堆最后排序为：升序<br>小顶堆：节点值比子节点小（每个子树间比较），构建小顶堆最后排序为：降序<br>稳定性：非稳定<br>参考资料：<a href="https://www.jianshu.com/p/d174f1862601" target="_blank" rel="noopener">堆排序[1]</a> <a href="https://www.cnblogs.com/shiqi17/p/9694938.html" target="_blank" rel="noopener">堆排序[2]</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(elems)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路在 先构建顶堆 然后 交换头和尾节点 再从头开始构建顶堆</span></span><br><span class="line"><span class="string">    :param elems:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">siftdown</span><span class="params">(elems, begin, end)</span>:</span> <span class="comment">#向下筛选</span></span><br><span class="line">        i, j = begin, begin*<span class="number">2</span>+<span class="number">1</span> <span class="comment">#i为父节点，j为i的左子结点</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; end:</span><br><span class="line">            <span class="keyword">if</span> j+<span class="number">1</span> &lt; end <span class="keyword">and</span> elems[j] &gt; elems[j+<span class="number">1</span>]: <span class="comment">#如果左子结点大于右子结点</span></span><br><span class="line">                j += <span class="number">1</span>                              <span class="comment">#则将j指向右子结点</span></span><br><span class="line">            <span class="keyword">if</span> elems[i] &lt; elems[j]: <span class="comment">#j已经指向两个子结点中较小的位置，</span></span><br><span class="line">                <span class="keyword">break</span>        <span class="comment">#如果插入元素e小于j位置的值，则为3者中最小的</span></span><br><span class="line">            elems[i],elems[j] = elems[j],elems[i] <span class="comment"># 交换两个值，子节点替代父节点</span></span><br><span class="line">            i,j = j,j*<span class="number">2</span>+<span class="number">1</span> <span class="comment"># 把j的下标赋给i，j的值变成原j的子节点，这一步是为了交换节点后，对新的子树进行顶堆建立</span></span><br><span class="line"></span><br><span class="line">    end = len(elems)<span class="number">-1</span></span><br><span class="line">    parent = end//<span class="number">2</span><span class="number">-1</span> <span class="comment"># 取出所有有子节点的父节点</span></span><br><span class="line">    <span class="keyword">while</span> parent &gt;= <span class="number">0</span>: <span class="comment"># 构建顶堆</span></span><br><span class="line">        siftdown(elems,parent,end)</span><br><span class="line">        parent -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> end &gt; <span class="number">0</span>:</span><br><span class="line">        elems[end],elems[<span class="number">0</span>] = elems[<span class="number">0</span>],elems[end] <span class="comment"># 交换顶值和最后值</span></span><br><span class="line">        siftdown(elems,<span class="number">0</span>,end) <span class="comment"># 以首位作为父节点，重新构建顶堆</span></span><br><span class="line">        end -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elems</span><br></pre></td></tr></table></figure><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><blockquote><p>思路在 构建一个新数组 它的下标为需要排序的数组值 它的值为该数出现的次数，最后遍历新数组按顺序取出值<br>计数排序是特殊的桶排序<br>稳定性：稳定</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countingSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路在 构建一个新数组 它的下标为需要排序的数组值 它的值为该数出现的次数</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    max_value = max(arr) <span class="comment"># 计数排序需要获取最大值</span></span><br><span class="line">    count = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(max_value+<span class="number">1</span>)] <span class="comment"># 下标为arr的值 值为计数总数</span></span><br><span class="line">    last_value = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        count[arr[i]] += <span class="number">1</span> <span class="comment"># 把需要排序的值 做为下标 进行计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(count)):</span><br><span class="line">        <span class="keyword">while</span> count[i] &gt; <span class="number">0</span>: <span class="comment"># 遍历计数值 如果大于0 则把下标添加到新的数组</span></span><br><span class="line">            last_value.append(i)</span><br><span class="line">            count[i] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> last_value</span><br></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><blockquote><p>思路在：过个人方式把数据划分到不同的桶中（抽象概念，可以用数组实现） 然后桶内排序（桶内排序需要用到别的排序算法），遍历出来即是有序数组<br>稳定性：稳定</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路在：</span></span><br><span class="line"><span class="string">    通过个人方式把数据划分到不同的桶中（抽象概念，可以用数组实现） 然后桶内排序（桶内排序需要用到别的排序算法），遍历出来即是有序数组</span></span><br><span class="line"><span class="string">    :param array:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 1.创建n个空桶</span></span><br><span class="line">    min_value = min(array)</span><br><span class="line">    max_value = max(array)</span><br><span class="line">    bucket_size = max_value-min_value+<span class="number">1</span></span><br><span class="line">    new_list = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(bucket_size)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.把arr[i] 插入到bucket[n*array[i]]</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> array:</span><br><span class="line">        <span class="comment"># 核心步骤在 如何划分桶 即index 的生成逻辑</span></span><br><span class="line">        index = (data-min_value)</span><br><span class="line">        new_list[index].append(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.桶内排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(bucket_size):</span><br><span class="line">        new_list[i].sort()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4.产生新的排序后的列表</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(bucket_size):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(new_list[i])):</span><br><span class="line">            array[index] = new_list[i][j]</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><blockquote><p>不介绍了</p></blockquote><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>稳定和不稳定的排序算法有哪些？</li><li>哪个算法最稳定，哪个算法最快？</li><li>哪个算法使用空间最大？</li><li>列出各算法的稳定性、时间复杂度、空间复杂度 和 可手写各算法（着重在快速排序、堆排序、归并排序、插入排序）</li><li>python排序的实现：<a href="https://blog.csdn.net/yangzhongblog/article/details/8184707" target="_blank" rel="noopener">time sort</a></li></ol><hr><center>谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建windows flink idea开发测试环境</title>
      <link href="/posts/b4bb247c/"/>
      <url>/posts/b4bb247c/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建说明"><a href="#搭建说明" class="headerlink" title="搭建说明"></a>搭建说明</h1><h2 id="难易"><a href="#难易" class="headerlink" title="难易"></a>难易</h2><p>windows flink搭建十分简单，官网都有说明，我一路走下来基本没有坑</p><h2 id="记录原因"><a href="#记录原因" class="headerlink" title="记录原因"></a>记录原因</h2><p>简单却记录的原因在于：</p><blockquote><p>1、整合资料，方便快速搭建<br>2、我之前见同事搭建过，觉得牛逼，便想请教下搭建方式，询问是否有教程。结果对方回应说没有教程，靠他一点点摸索，当时听完，对方在我心目中地位瞬间上升很多档次，深刻感知自己的弱小。如今看来，不是我弱小，而是我愚蠢。我百度一番，也没发现全流程教程，所以借此记录，方便后续新手的搭建</p></blockquote><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>windows 结合 idea，可以有效快速熟悉flink语法，作为入门是很好的方式</p><h1 id="搭建步骤："><a href="#搭建步骤：" class="headerlink" title="搭建步骤："></a>搭建步骤：</h1><h2 id="基本环境"><a href="#基本环境" class="headerlink" title="基本环境"></a>基本环境</h2><blockquote><p>1、java1.8以上<br>2、scala 2.1.1 或者 scala 2.1.2 （我下载的是2.1.2）<br>3、maven 最新版本<br>4、idea 社区版<br>上面的环境，可自行百度（我都是去对应官网下载）</p></blockquote><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>这两个是官网的链接，有先后顺序。如果不想看我的教程，可以直接查看官网教程<br><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/zh/dev/projectsetup/java_api_quickstart.html" target="_blank" rel="noopener">参考链接</a><br><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/zh/dev/projectsetup/dependencies.html" target="_blank" rel="noopener">参考链接</a></p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><blockquote><p>具体步骤只有两步：1、maven创建项目 2、配置依赖</p></blockquote><h4 id="maven创建项目"><a href="#maven创建项目" class="headerlink" title="maven创建项目"></a>maven创建项目</h4><ul><li>打开idea，创建maven工程，按如下配置进行添加。看配置参数可知，我搭建的是1.9版本，对应的版本可以根据自己需求来<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mvn archetype:generate                               \</span><br><span class="line">  -DarchetypeGroupId=org.apache.flink              \</span><br><span class="line">  -DarchetypeArtifactId=flink-quickstart-java      \</span><br><span class="line">  -DarchetypeVersion=1.9.0</span><br></pre></td></tr></table></figure><img alt="操作图" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/flink_windows.jpg" class="lozad"></li></ul><p>配置完毕后，会进行mvn操作，等待maven操作完成，进行下一步</p><h3 id="配置依赖"><a href="#配置依赖" class="headerlink" title="配置依赖"></a>配置依赖</h3><ul><li>打开pom.xml，我们会发现有两个错误项，把那两个删除，换成下面的依赖，更新maven完成搭建</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote><p>在上面的依赖配置中，我们发现scope这个选项，如果要在本地测试，需要把scope的值设置成compile。对应maven scope的解释请看<a href="http://jskblog.xyz/posts/2d6fc607/">maven scope</a>。</p></blockquote><p>简单解释即:<br>scope为compile时，代表强依赖，打包会把依赖添加到jar包中<br>scope为provided时，打包时，依赖不添加到jar包中</p><p>flink对两种scope的使用：</p><ol><li>compile：<strong><em>用于本地测试</em></strong></li><li>provided：<strong><em>用于线上部署运行</em></strong>。依赖不需要打包到jar包中的原因是：flink线上环境有相应的jar包，如果强依赖会出现jar包冲突情况</li></ol><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
          <category> flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows flink </tag>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven中scope的区别</title>
      <link href="/posts/2d6fc607/"/>
      <url>/posts/2d6fc607/</url>
      
        <content type="html"><![CDATA[<h1 id="依赖的Scope"><a href="#依赖的Scope" class="headerlink" title="依赖的Scope"></a>依赖的Scope</h1><p>最近在本地搭建flink想要熟悉语法，根据官网搭建过程中，发现maven的个别概念不熟悉，就此做个记录。<br>scope定义了类包在项目的使用阶段。项目阶段包括： 编译，运行，测试和发布。</p><h1 id="分类说明"><a href="#分类说明" class="headerlink" title="分类说明"></a>分类说明</h1><ul><li>compile<br>默认scope为compile，表示为当前依赖参与项目的编译、测试和运行阶段，属于强依赖。打包之时，会达到包里去。</li><li>test<br>该依赖仅仅参与测试相关的内容，包括测试用例的编译和执行，比如定性的Junit。</li><li>runtime<br>依赖仅参与运行周期中的使用。一般这种类库都是接口与实现相分离的类库，比如JDBC类库，在编译之时仅依赖相关的接口，在具体的运行之时，才需要具体的mysql、oracle等等数据的驱动程序。<br>此类的驱动都是为runtime的类库。</li><li>provided<br>该依赖在打包过程中，不需要打进去，这个由运行的环境来提供，比如tomcat或者基础类库等等，事实上，该依赖可以参与编译、测试和运行等周期，与compile等同。区别在于打包阶段进行了exclude操作。</li><li>system<br>使用上与provided相同，不同之处在于该依赖不从maven仓库中提取，而是从本地文件系统中提取，其会参照systemPath的属性进行提取依赖。</li><li>import<br>这个是maven2.0.9版本后出的属性，import只能在dependencyManagement的中使用，能解决maven单继承问题，import依赖关系实际上并不参与限制依赖关系的传递性。</li><li>systemPath<br>当maven依赖本地而非repository中的jar包，sytemPath指明本地jar包路径,例如：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupid</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupid</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactid</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systempath</span>&gt;</span>$&#123;basedir&#125;/WebContent/WEB-INF/lib/hamcrest-core-1.3.jar<span class="tag">&lt;/<span class="name">systempath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="dependency中的type"><a href="#dependency中的type" class="headerlink" title="dependency中的type"></a>dependency中的type</h1><p>引入某一个依赖时，必须指定type，这是因为用于匹配dependency引用和dependencyManagement部分的最小信息集实际上是{groupId，artifactId，type，classifier}。在很多情况下，这些依赖关系将引用没有classifier的jar依赖。这允许我们将标识设置为{groupId，artifactId}，因为type的默认值是jar，并且默认classifier为null。<br>type的值一般有jar、war、pom等，声明引入的依赖的类型</p><hr><center>谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 技术技巧 </category>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven scope </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装jar包后如何用maven调用</title>
      <link href="/posts/abf5534d/"/>
      <url>/posts/abf5534d/</url>
      
        <content type="html"><![CDATA[<h1 id="安装jar包后如何用maven调用"><a href="#安装jar包后如何用maven调用" class="headerlink" title="安装jar包后如何用maven调用"></a>安装jar包后如何用maven调用</h1><p>最近有使用maven，故此做一个maven的简单记录，防止后续需要</p><p>安装自定义jar包到本地Maven库<br>当出现下列情况时：<br>1.要使用的 jar 不存在于 Maven 的中心储存库中。<br>2.您创建了一个自定义的 jar ，而另一个 Maven 项目需要使用。</p><p>远程服务器需要在settings.xml中配置server用户名密码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>n<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">username</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">password</span>&gt;</span>12345<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要手动将所需要的jar包存放至Maven本地资源库，可以再cmd中输入以下命令：</p><blockquote><p>mvn install:install-file -Dfile=c:\userdefined-1.0.jar -DgroupId=pers.test.code -DartifactId=userdefined -Dversion={1.0} -Dpackaging=jar</p></blockquote><p>远程库命令如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mvn</span> <span class="attr">deploy:deploy-file</span> <span class="bullet">-DgroupId=com.abc.com3rd.policy</span> <span class="bullet">-DartifactId=policy-sdk</span> <span class="bullet">-Dversion=20180502102622</span> <span class="bullet">-Dpackaging=jar</span> <span class="bullet">-Dfile=D:\jar\local_policy.jar</span> <span class="bullet">-DrepositoryId=repo-huotu</span> <span class="bullet">-Durl=http://repo.abc.com:8081/nexus/content/repositories/releases/</span> <span class="bullet">-DgeneratePom=false</span></span><br><span class="line"><span class="string">各参数代表含义为：</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span><span class="string">Dmaven.test.skip=true</span>                              <span class="string">//跳过编译、测试</span></span><br><span class="line"><span class="bullet">-</span><span class="string">Dfile=D:\MvnProject\service-mvn-1.0.0.jar</span>          <span class="string">//jar包文件地址,绝对路径</span></span><br><span class="line"><span class="bullet">-</span><span class="string">DgroupId=pri.roy.mvn.test</span>                          <span class="string">//gruopId--pom坐标，自定义</span></span><br><span class="line"><span class="bullet">-</span><span class="string">DartifactId=mvn-api</span>                                <span class="string">//artifactId--pom坐标，自定义</span></span><br><span class="line"><span class="bullet">-</span><span class="string">Dversion</span>                                           <span class="string">//版本号</span></span><br><span class="line"><span class="bullet">-</span><span class="string">Dpackaging</span>                                         <span class="string">//打包方式</span></span><br><span class="line"><span class="bullet">-</span><span class="string">DrepositoryId</span>                                      <span class="string">//远程库服务器ID</span></span><br><span class="line"><span class="bullet">-</span><span class="string">Durl</span>                                               <span class="string">//远程库服务器地址</span></span><br></pre></td></tr></table></figure><p>安装成功后，在pom.xml文件中可以使用了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>pers.test.code<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>userdefined <span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><center>谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 技术技巧 </category>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
            <tag> jar包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown 样式总结</title>
      <link href="/posts/c491c9ac/"/>
      <url>/posts/c491c9ac/</url>
      
        <content type="html"><![CDATA[<blockquote><p>markdown的样式总结</p></blockquote><hr><p><strong>本文由佳境协助完成，就此感谢他，做个小广告：</strong></p><blockquote><ul><li>Welcome To <a href="http://shmily-qjj.top/" target="_blank" rel="noopener">佳境博客</a></li><li>他的<a href="https://github.com/Shmilyqjj" target="_blank" rel="noopener">GitHub</a>地址</li><li>他的<a href="http://music.163.com/artist?id=13610347" target="_blank" rel="noopener">CloudMusic</a>地址</li></ul></blockquote><h3 id="HEXO目录结构"><a href="#HEXO目录结构" class="headerlink" title="HEXO目录结构"></a>HEXO目录结构</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">|--</span> <span class="string">_config.yml</span>     <span class="string">全局配置（网站名称作者主题部署等）</span></span><br><span class="line"><span class="string">|--</span> <span class="string">package.json</span>    <span class="string">框架参数（框架依赖拆件及其版本）</span></span><br><span class="line"><span class="string">|--</span> <span class="string">scaffolds</span>       <span class="string">脚手架（通用MarkDown模板，新建文章时，hexo根据这个目录的文件进行构建）</span></span><br><span class="line"><span class="string">|--</span> <span class="string">source</span>          <span class="string">网页资源（css,js,images,文章等）</span></span><br><span class="line">   <span class="string">|--</span> <span class="string">_posts</span>       <span class="string">博客文章（写文章的地方）</span></span><br><span class="line"><span class="string">|--</span> <span class="string">themes</span>          <span class="string">主题目录</span></span><br><span class="line"><span class="string">|--</span> <span class="string">.gitignore</span>      <span class="string">Git忽略文件或目录</span></span><br><span class="line"><span class="string">|--</span> <span class="string">package.json</span>    <span class="string">框架参数（框架依赖拆件及其版本）</span></span><br></pre></td></tr></table></figure><hr><h1 id="MarkDown语法字典"><a href="#MarkDown语法字典" class="headerlink" title="MarkDown语法字典"></a>MarkDown语法字典</h1><ul><li><p>标题</p><h1 id="一级标题-最大"><a href="#一级标题-最大" class="headerlink" title="一级标题(最大)"></a>一级标题(最大)</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></li><li><p>字体</p></li><li><p>斜体文本*<br><em>斜体文本</em></p></li><li><p><em>粗体文本*</em><br><strong>粗体文本</strong></p></li><li><p><strong>粗斜体文本*</strong><br><strong><em>粗斜体文本</em></strong><br><u>带下划线文本</u></p></li><li><p>脚注</p></li></ul><ul><li><p>列表<br>无序列表用* + -三种符号表示</p><ul><li>列表嵌套</li></ul><ol><li>有序列表第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素<blockquote><p>列表中可以使用区块<br>列表中可以使用区块</p></blockquote></li></ul></li><li>有序列表第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素<ul><li>最多第三层嵌套</li></ul><ul><li>最多第三层嵌套</li></ul><ul><li>最多第三层嵌套</li></ul></li></ul></li></ol></li><li><p>区块引用</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套…</p><blockquote><p>第二层嵌套…</p></blockquote></blockquote><ul><li>list</li><li>list</li></ul><ul><li>list</li></ul></blockquote></li><li><p>代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">        System.out.<span class="title">println</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">//tab或者四个空格</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = []</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">copy.copy(l)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qjj = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//定义代码块并指定语言-&gt;显示高亮</span></span><br></pre></td></tr></table></figure><ul><li>链接<br>这是我的云音乐主页<a href="http://music.163.com/artist?id=13610347" target="_blank" rel="noopener">CloudMusic</a><br>直接显示链接地址: <a href="http://music.163.com/artist?id=13610347" target="_blank" rel="noopener">http://music.163.com/artist?id=13610347</a><br>我的网易云主页高级链接<a href="http://music.163.com/artist?id=13610347" target="_blank" rel="noopener">cm-1</a><br>我的网易云主页高级链接<a href="http://music.163.com/artist?id=13610347" target="_blank" rel="noopener">cm-2</a></li></ul><ul><li><p>添加图片<br><img alt="alt lalala" data-src="http://m.qpic.cn/psb?/V10aWFGB3ChSVt/4Onwe7wF*pBhD4*iWs0KetAXGTu6fMrAUJrxWkkB4fk!/b/dL8AAAAAAAAA&bo=hANYAgAAAAADB*8!&rf=viewer_4" class="lozad"><br><img alt="alt hahaha" title="图片注释呀!鼠标放那会弹出注释!" data-src="http://m.qpic.cn/psb?/V10aWFGB3ChSVt/4Onwe7wF*pBhD4*iWs0KetAXGTu6fMrAUJrxWkkB4fk!/b/dL8AAAAAAAAA&bo=hANYAgAAAAADB*8!&rf=viewer_4" class="lozad"></p><img width="30%" title="可以使用html的标签,控制图片大小,title悬停显示文字" data-src="http://m.qpic.cn/psb?/V10aWFGB3ChSVt/4Onwe7wF*pBhD4*iWs0KetAXGTu6fMrAUJrxWkkB4fk!/b/dL8AAAAAAAAA&bo=hANYAgAAAAADB*8!&rf=viewer_4" class="lozad"></li><li><p>图片链接<br><a href="https://www.alluxio.io/slack" target="_blank" rel="noopener"><img alt="Slack" data-src="https://slackin.alluxio.io/badge.svg" class="lozad"></a><br><a href="https://www.alluxio.io/download" target="_blank" rel="noopener"><img alt="Release" data-src="https://img.shields.io/github/release/alluxio/alluxio/all.svg" class="lozad"></a><br><a href="https://hub.docker.com/r/alluxio/alluxio" target="_blank" rel="noopener"><img alt="Docker Pulls" data-src="https://img.shields.io/docker/pulls/alluxio/alluxio.svg" class="lozad"></a><br><a href="https://www.alluxio.io/docs" target="_blank" rel="noopener"><img alt="Documentation" data-src="https://img.shields.io/badge/docs-reference-blue.svg" class="lozad"></a><br><a href="https://twitter.com/intent/follow?screen_name=alluxio" target="_blank" rel="noopener"><img alt="Twitter Follow" data-src="https://img.shields.io/twitter/follow/alluxio.svg?label=Follow&style=social" class="lozad"></a><br><a href="https://github.com/Alluxio/alluxio/blob/master/LICENSE" target="_blank" rel="noopener"><img alt="License" data-src="https://img.shields.io/github/license/alluxio/alluxio.svg" class="lozad"></a></p></li></ul><ul><li>添加表格<br><code>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行</code><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>表格</td><td>表格</td></tr><tr><td>表格</td><td>表格</td></tr><tr><td>表格</td><td>表格</td></tr></tbody></table></li></ul><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><ul><li>对HTML的支持<br><code>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Ctrl<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span>+<span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Alt<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span>+<span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Del<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span> 重启电脑</span><br></pre></td></tr></table></figure><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><p><strong>文本加粗</strong><br><strong>*正常显示*号配合文本加粗体\</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">以下支持反斜杠转义</span></span><br><span class="line"><span class="string">\</span>   <span class="string">反斜线</span></span><br><span class="line"><span class="string">`</span>   <span class="string">反引号</span></span><br><span class="line"><span class="string">*</span>   <span class="string">星号</span></span><br><span class="line"><span class="string">_</span>   <span class="string">下划线</span></span><br><span class="line"><span class="string">&#123;&#125;</span>  <span class="string">花括号</span></span><br><span class="line"><span class="string">[]</span>  <span class="string">方括号</span></span><br><span class="line"><span class="string">()</span>  <span class="string">小括号</span></span><br><span class="line"><span class="comment">#   井字号</span></span><br><span class="line"><span class="string">+</span>   <span class="string">加号</span></span><br><span class="line"><span class="bullet">-</span>   <span class="string">减号</span></span><br><span class="line"><span class="string">.</span>   <span class="string">英文句点</span></span><br><span class="line"><span class="string">!</span>   <span class="string">感叹号</span></span><br></pre></td></tr></table></figure><ul><li>数学公式  需要开启 mathjax: 0 0改为1<br><code>当需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现</code></li></ul><p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>$$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}<br>$$</p><hr><h3 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks:"></a>Thanks:</h3><p><a href="https://github.com/mashirozx/Sakura/" target="_blank" rel="noopener">Sakura</a> Hexo theme.</p><p><a href="https://sakura.hojun.cn" target="_blank" rel="noopener">hojun</a> Modified into the theme.</p><hr><center>谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsdelivr加速读取github文件</title>
      <link href="/posts/5a5aec9f/"/>
      <url>/posts/5a5aec9f/</url>
      
        <content type="html"><![CDATA[<h2 id="jsdelivr是什么"><a href="#jsdelivr是什么" class="headerlink" title="jsdelivr是什么"></a>jsdelivr是什么</h2><p>github：<a href="https://github.com/jsdelivr/jsdelivr" target="_blank" rel="noopener">https://github.com/jsdelivr/jsdelivr</a><br>官网：<a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">https://www.jsdelivr.com/</a><br>免费的公用CDN加速服务网（CDN是就近服务器访问，所以会加速）</p><h2 id="作用是什么"><a href="#作用是什么" class="headerlink" title="作用是什么"></a>作用是什么</h2><p>可以加速访问文件、图片，而本文章则介绍如何利用jsdelivr加速访问github照片为主<br>之所以需要用到jsdelivr加速访问照片，在于可<strong>方便快速</strong>管理 hexo 里面的图片链接</p><h2 id="如何操作"><a href="#如何操作" class="headerlink" title="如何操作"></a>如何操作</h2><p>举我个人例子的大致过程：</p><ol><li>生成新的github仓库</li><li>构建文件夹用于存放照片文件 <a href="https://github.com/JSK520/blog_web/blob/master/photos/person.jpg" target="_blank" rel="noopener">github目录</a></li><li>关键一步：点击项目上端的<strong>release</strong> 创建版本：<br><img alt="release的创建简介" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/photos/release_v1.jpg" class="lozad"></li><li>创建好后，点击进入图片链接：<br>那我的做例子，进入github照片路径为：<br><a href="https://github.com/JSK520/blog_web/blob/v1.1/photos/release_v1.jpg" target="_blank" rel="noopener">https://github.com/JSK520/blog_web/blob/v1.1/photos/release_v1.jpg</a></li><li>把对应路径变更为以下方式即可<br><a href="https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/photos/release_v1.jpg" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/photos/release_v1.jpg</a></li></ol><p>仔细看我们发现：<br><a href="https://github.com/JSK520/blog_web/blob/v1.1/" target="_blank" rel="noopener">https://github.com/JSK520/blog_web/blob/v1.1/</a><br>这个前缀替换成了<br><a href="https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/</a><br>而 /photos/release_v1.jpg 是github的文件名</p><hr><center>谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> jsdelivr </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jsdelivr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 总结</title>
      <link href="/posts/424111dd/"/>
      <url>/posts/424111dd/</url>
      
        <content type="html"><![CDATA[<p>无法提交theme：<br>下面以yelee做例子<br>cd theme/<br>删除 .git文件<br>git rm -cached yelee/<br>git add yelee</p><p>如果出现 lock情况：<br>rm -f xx/.git/index.lock</p><h2 id="github照片上传："><a href="#github照片上传：" class="headerlink" title="github照片上传："></a>github照片上传：</h2><p>查看远程仓库的版本：<br>git ls-remote</p><p>直接覆盖线上版本：<br>git push -f origin master:tags/v1.1</p><hr><center>谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
