<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>jvm垃圾回收知识汇总</title>
      <link href="/posts/62a5eeb2/"/>
      <url>/posts/62a5eeb2/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾回收区域"><a href="#垃圾回收区域" class="headerlink" title="垃圾回收区域"></a>垃圾回收区域</h1><p>上篇了解到jvm的内存区域有 堆区、程序计数器、虚拟机栈、本地方法栈、方法区，而会进行垃圾回收的区域是：<code>堆区和元空间</code>。而如果元空间没有设置值，则不会有垃圾回收。</p><p>因为虚拟机栈在程序结束后会自己出栈，内存就是释放了。</p><h1 id="垃圾回收标记法"><a href="#垃圾回收标记法" class="headerlink" title="垃圾回收标记法"></a>垃圾回收标记法</h1><p>我们知道只有堆区和方法区会进行垃圾回收，那在垃圾回收的时候，到底回收什么东西呢？垃圾的定义是什么呢？</p><p>在jvm中，没有被引用的对象就可以标记为非存活对象，而非存活对象就是垃圾。</p><p>那我们该如何判断对象是否存活？有两个算法：</p><h2 id="程序计数算法"><a href="#程序计数算法" class="headerlink" title="程序计数算法"></a>程序计数算法</h2><p>给对象添加一个引用计数器，每当有一个地方引用时就+1，引用失效时-1。对象计数器等于0，则为非存活对象。</p><p>优点：实现简单、判断效率高<br>缺点：很难解决循环引用问题</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>gc root 对象作为起始点，从这些节点向下搜索，所走的路径称作引用链，不在引用链中的对象则为非存活对象</p><p>gc root的对象有（对应的引用就是根节点，由存活的引用出发）：</p><ol><li>虚拟机栈的栈帧的局部变量表所引用的对象；</li><li>本地方法栈的JNI所引用的对象；</li><li>静态变量和常量所引用的对象；</li></ol><p>可达性分析过程如下图：</p><p><img alt="可达性分析过程" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/gc_root.png" class="lozad"></p><p>优点：精确严谨<br>缺点：会导致stw，stw的原因在确保引用关系不会变化</p><h1 id="垃圾回收时机"><a href="#垃圾回收时机" class="headerlink" title="垃圾回收时机"></a>垃圾回收时机</h1><p>上面了解到什么时垃圾，那我们会在什么时候进行垃圾的回收？</p><p>最开始我们讲过，主要进行垃圾回收的地方是：</p><ol><li>元空间</li><li>堆区</li></ol><p>所以当这两个区域满了，我们就会进行垃圾回收</p><h2 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h2><p>主要回收一部分垃圾：</p><ol><li>无用类</li></ol><blockquote><p>注意java8的常量和静态常量在堆里生成</p></blockquote><h3 id="无用类"><a href="#无用类" class="headerlink" title="无用类"></a>无用类</h3><p>满足以下几点则为无用类：</p><ol><li>该类所有实例都被回收</li><li>该类的classloader被回收</li><li>类class对象没有被引用，无法通过反射访问该类</li></ol><h2 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h2><p>堆区触发时机需要考虑两个区域：</p><ol><li>新生代</li><li>老年代</li></ol><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>新生对象无法放入Eden区</p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>有几种情况：</p><ol><li>老年代空间放不下新生代对象</li><li>老年代空间小于每次minor gc后进入老年代的平均大小（空间担保机制，需要开启-XX:-HandlePromotionFailure）</li><li>通过参数设置，可以在老年代剩余空间少于92%时进行垃圾回收（CMS的一个参数调整）</li></ol><h1 id="内存空间为什么会满"><a href="#内存空间为什么会满" class="headerlink" title="内存空间为什么会满"></a>内存空间为什么会满</h1><p>我们现在知道什么时候会进行垃圾回收，但我们很好奇，内存区域到底是怎么满的？</p><h2 id="元空间-1"><a href="#元空间-1" class="headerlink" title="元空间"></a>元空间</h2><p>方法区满的主要原因是加载的类太多，并且一直无法释放，导致类加载累积。</p><h2 id="堆区-1"><a href="#堆区-1" class="headerlink" title="堆区"></a>堆区</h2><h3 id="新生代-1"><a href="#新生代-1" class="headerlink" title="新生代"></a>新生代</h3><p>一直有新生对象进入新生代。新生代的垃圾回收算法 是复制算法，所以效率很高。一般的优化都是希望垃圾尽可能在新生代进行完成。</p><h3 id="老年代-1"><a href="#老年代-1" class="headerlink" title="老年代"></a>老年代</h3><p>老年代的垃圾回收算法为 标记整理算法，并且老年代的存活对象较多，会导致垃圾回收比较耗时，所以我们更多时候是希望不要让垃圾回收在老年代进行。</p><p>而jvm整个数据流程是先通过新生代 然后再放入老年代，所以老年代的数据都是新生代传递过来的，传递的条件主要有：</p><ol><li>超过年龄（默认15）</li><li>minor gc后无法放入存活区</li><li>minor gc后各年龄的存活对象大小比存活区50%大（动态年龄判断）</li><li>大对象直接进入老年代。参数-XX:PretenureSizeThreshold设置，默认值为0。parnew和serial的垃圾回收器才有效果。</li></ol><h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><p>在讲 gc root的时候，我们讲过引用链，在引用的世界里，有四种引用需要我们记住</p><h2 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h2><p>强引用是普遍存在引用，强引用的对象不会被回收</p><h2 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h2><p>发生内存溢出异常前，会进行回收，如果还是内存溢出则 oom。可用作内存敏感的高速缓存：数据会更新，内存不足我可以回收重新读取<br>（用软引用的方法构建的对象）</p><h2 id="弱应用"><a href="#弱应用" class="headerlink" title="弱应用"></a>弱应用</h2><p>无论内存是否足够，垃圾回收都会进行回收<br>（用弱引用的方法构建的对象）</p><h2 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h2><p>无论内存是否足够，垃圾回收都会进行回收<br>（用虚引用的方法构建的对象）</p><h1 id="垃圾回收术语"><a href="#垃圾回收术语" class="headerlink" title="垃圾回收术语"></a>垃圾回收术语</h1><p>关于垃圾回收，有几个术语需要记住：</p><ol><li>minor gc：新生代的垃圾回收，一般存活对象少，收集很快</li><li>old gc：老年代的垃圾回收</li><li>full gc：整个jvm区的垃圾回收，等于minor gc + old gc + 方法区gc</li><li>mixed gc：老年代超过45%，新生代和老年代进行混合gc（这是g1的垃圾回收术语）</li></ol><h1 id="内存溢出和内存泄露"><a href="#内存溢出和内存泄露" class="headerlink" title="内存溢出和内存泄露"></a>内存溢出和内存泄露</h1><p>经过上面的垃圾回收，正常情况下程序会重新拥有足够内存进行运算，但也会有特殊情况，导致内存一致无法回收到可以正常使用，这种情况程序就会抛出异常。而导致内存不够的主要有两种情况：</p><ol><li>内存溢出</li><li>内存泄露</li></ol><h2 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h2><p>内存溢出就是我们常说的oom，关于oom的汇总可以查看</p><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>内存泄露指的是无用对象无法被垃圾回收，导致内存浪费，严重时会造成OOM。</p><p>java内存泄露的主要原因是：长生命周期的对象持有短生命周期对象引用。即：</p><ol><li>gc root对象可达</li><li>对象无用</li></ol><p>产生内存泄露的原因有：</p><ol><li>静态集合类引起内存泄露</li><li>各种连接（譬如jdbc没有关闭connection）</li><li>监听器</li><li>hash算法的集合，修改属性值无法进行remove</li></ol><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><p>在介绍垃圾回收器前，我们先介绍下都有哪些垃圾回收算法，以及优劣</p><h2 id="标记-清除-算法"><a href="#标记-清除-算法" class="headerlink" title="标记-清除 算法"></a>标记-清除 算法</h2><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>标记阶段：标记出需要垃圾回收的对象</li><li>清除阶段：统一回收（清除）需要回收的对象</li></ol><blockquote><p>标记阶段会进行两次，具体步骤可查看上面的可达性图解</p></blockquote><p><img alt="标记-清除 算法" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/mark_clear.webp" class="lozad"></p><h3 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h3><ul><li>优势：算法简单，实现简单</li><li>劣势：<ul><li>分为标记和清除两个阶段，过程效率都不高</li><li>会产生空间垃圾碎片，导致内存不连续，可能导致有内存对象却无法分配的问题，浪费资源</li></ul></li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>垃圾回收行为低 的场景</p><blockquote><p>老年代适合该算法，因为回收频率低，利用率高，效率和空间问题不明显</p></blockquote><h2 id="复制-算法"><a href="#复制-算法" class="headerlink" title="复制 算法"></a>复制 算法</h2><h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>把内存划分为两块，每次只使用其中一块</li><li>当使用的这块内存用完，就将这块内存上还存活的对象复制到另一块没使用的内存上</li><li>然后把使用过的内存清除</li></ol><p><img alt="复制 算法" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/jvm_copy.webp" class="lozad"></p><h3 id="优劣势"><a href="#优劣势" class="headerlink" title="优劣势"></a>优劣势</h3><ul><li>优势：<ul><li>解决标记清除效率问题</li><li>内存碎片问题</li></ul></li><li>劣势：<ul><li>内存需要空出一部分用于复制存活数据</li><li>如果存活对象多，复制频繁会影响效率</li></ul></li></ul><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>存活对象少&amp;需要频繁垃圾回收 的区域</p><blockquote><p>新生代符合</p></blockquote><h2 id="标记-整理-算法"><a href="#标记-整理-算法" class="headerlink" title="标记-整理 算法"></a>标记-整理 算法</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>标记阶段：标记需要需要回收的对象</li><li>整理阶段：让存活的对象移到一边</li><li>清除阶段：一次性清除端外的所有对象</li></ol><p><img alt="标记整理 算法" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/mark_clear_collect.webp.webp" class="lozad"></p><h3 id="优劣势-1"><a href="#优劣势-1" class="headerlink" title="优劣势"></a>优劣势</h3><ul><li>优势：<ul><li>一次性把端外对象都清除</li><li>解决内存碎片问题</li></ul></li></ul><h2 id="分代算法"><a href="#分代算法" class="headerlink" title="分代算法"></a>分代算法</h2><p>主流虚拟机都用这种算法，即把上面的垃圾回收算法优劣势进行利用</p><h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><ol><li>新生代用的复制算法，但不把内存进行对半分，而是分成三份，比例默认为8:1:1</li></ol><blockquote><p>因为新生代的对象存活率低，所以可以如此划分三部分，充分利用复制算法效率</p></blockquote><ol start="2"><li>老年代主要用的标记整理</li></ol><h3 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h3><p>我们结合上面的所有知识点，进行一次真实的对象迁移过程</p><blockquote><p>前提，堆区划分为新生代和老年代，新生代分Eden、from survivor、to survivor。新生代和老年代比例 1：2</p></blockquote><ul><li>对象首先进入Eden区</li><li>Eden区内存不足，进行minor gc，利用<code>复制算法</code>垃圾回收，把Eden存活对象复制到from survior区域，清除Eden区垃圾对象</li><li>对象继续进入Eden区，当Eden区又满时，进行minor gc，把Eden区和from survivor区存活对象移到to survivor区域</li><li>当出现以下情况时，把对象移到老年代<ul><li>超过年龄（默认15）</li><li>minor gc后无法放入存活区</li><li>minor gc后各年龄的存活对象大小比存活区50%大（动态年龄判断）</li><li>大对象直接进入老年代。参数-XX:PretenureSizeThreshold设置，默认值为0。parnew和serial的垃圾回收器才有效果。</li></ul></li><li>对象依旧按照对象先进Eden区的规范去进行，当老年代满了以后，就进行full gc，full gc的基本算法就是标记整理算法<code>（但不同的垃圾回收器有不同的优化和应用场景）</code>，而进行full gc的条件有以下：<ul><li>老年代空间放不下新生代对象</li><li>老年代空间小于每次minor gc后进入老年代的平均大小（空间担保机制，需要开启-XX:-HandlePromotionFailure）</li><li>通过参数设置，可以在老年代剩余空间少于92%时进行垃圾回收（CMS的一个参数调整）</li></ul></li></ul><h1 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h1><h2 id="垃圾回收考虑的问题"><a href="#垃圾回收考虑的问题" class="headerlink" title="垃圾回收考虑的问题"></a>垃圾回收考虑的问题</h2><p>主要有三点：</p><ol><li>吞吐量</li><li>响应时间</li><li>内存大小</li></ol><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p>吞吐量 = 运行用户代码时间/（运行用户代码时间+垃圾收集时间）</p><p>适合场景为：后台服务</p><h3 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h3><p>响应时间即停顿时间，停顿时间越短，用户体验越好</p><p>适合场景为：用户交互服务</p><h2 id="java-8-默认回收器"><a href="#java-8-默认回收器" class="headerlink" title="java 8 默认回收器"></a>java 8 默认回收器</h2><p>在介绍垃圾回收器前，想给大家确认java8默认的垃圾回收器。那我们应该如何查看呢？</p><p>可以在有java8的机器上输入</p><blockquote><p>java -XX:+PrintFlagsFinal -version</p></blockquote><p><img alt="默认垃圾回收器" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/garbage_collection_v1.png" class="lozad"></p><p><img alt="默认垃圾回收器" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/garbage_collection.png" class="lozad"></p><blockquote><p>关于内容查看，= 代表默认值，:= 代表修改过的值</p></blockquote><p>看图我们知道java8 默认的垃圾回收器为 Parallel GC，具体每个回收器对应的细节回收器如下图：</p><table><thead><tr><th>垃圾回收器</th><th>新生代</th><th>老年代</th></tr></thead><tbody><tr><td>G1GC</td><td>G1New</td><td>G1Old</td></tr><tr><td>Parallel GC</td><td>ParallelScavenge</td><td>ParallelOld(-UseParallelOld则是SerialOld)</td></tr><tr><td>CMS</td><td>ParNew</td><td>ConcurrentMarkSweep</td></tr><tr><td>Serial GC</td><td>DefNew</td><td>SerialOld</td></tr><tr><td>Epsilon</td><td>N/A</td><td>N/A</td></tr><tr><td>ZGC</td><td>N/A</td><td>Z</td></tr><tr><td>Shenandoah</td><td>N/A</td><td>Shenandoah</td></tr></tbody></table><p><code>关于每个具体回收器的介绍，我们看下面</code></p><h2 id="新生代垃圾回收器"><a href="#新生代垃圾回收器" class="headerlink" title="新生代垃圾回收器"></a>新生代垃圾回收器</h2><blockquote><p>新生代垃圾回收机制都采用 复制算法</p></blockquote><h3 id="serial"><a href="#serial" class="headerlink" title="serial"></a>serial</h3><h4 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h4><ul><li>并发收集</li></ul><blockquote><p>即单线程交替执行，在进行垃圾回收时会停止其他工作线程，该行为叫stop the world，简称stw</p></blockquote><ul><li>效率高</li></ul><blockquote><p>对于限定单CPU环境来说，Serial收集器没有线程交互开销（专一做垃圾收集），拥有更高的单线程收集效率。</p></blockquote><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>客户端模式下，虚拟机的 新生代区域</p><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><pre><code>-XX:+UseSerialGC：添加该参数来显式的使用串行垃圾收集器；</code></pre><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><img alt="serial垃圾回收器" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/serial_collection.webp" class="lozad"></p><h3 id="parnew"><a href="#parnew" class="headerlink" title="parnew"></a>parnew</h3><h4 id="简单介绍-1"><a href="#简单介绍-1" class="headerlink" title="简单介绍"></a>简单介绍</h4><ul><li>ParNew垃圾收集器是Serial收集器的多线程版本</li></ul><blockquote><p>由于存在线程交互的开销，所以在单CPU环境下，性能差于 Serial收集器</p></blockquote><ul><li>与CMS收集器配合工作</li></ul><blockquote><p>目前只有parnew可以与cms（老年代收集器）做搭配</p></blockquote><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><p>server端新生代的多线程收集</p><h4 id="参数设置-1"><a href="#参数设置-1" class="headerlink" title="参数设置"></a>参数设置</h4><pre><code>-XX:+UseConcMarkSweepGC：指定使用CMS后，会默认使用ParNew作为新生代收集器；-XX:+UseParNewGC：强制指定使用ParNew；    -XX:ParallelGCThreads：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同；</code></pre><h4 id="工作流程-1"><a href="#工作流程-1" class="headerlink" title="工作流程"></a>工作流程</h4><p><img alt="parnew垃圾回收器" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/parnew_collection.webp" class="lozad"></p><h3 id="parallel-scavenge"><a href="#parallel-scavenge" class="headerlink" title="parallel scavenge"></a>parallel scavenge</h3><h4 id="简单介绍-2"><a href="#简单介绍-2" class="headerlink" title="简单介绍"></a>简单介绍</h4><ul><li>具备parnew的多线程收集特点</li><li>该收集器以提高吞吐量为目的（关于吞吐量介绍上面）</li><li>自适应</li></ul><blockquote><p>会根据系统运行情况自动调整参数，如果莫名对象不入新生代而进入老年代，可能就是这个参数的设置原因。这是parnew和par scavenge最大差别</p></blockquote><h4 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h4><p>高吞吐为目标的系统服务</p><h4 id="参数设置-2"><a href="#参数设置-2" class="headerlink" title="参数设置"></a>参数设置</h4><pre><code>-XX:MaxGCPauseMillis：控制最大垃圾收集停顿时间，大于0的毫秒数-XX:GCTimeRatio：设置垃圾收集时间占总时间的比率，0 &lt; n &lt; 100的整数；计算公式为 垃圾收集时间：1 / (1 + n)-XX:+UseAdptiveSizePolicy：动态调整这些参数，以提供最合适的停顿时间或最大的吞吐量。调整内容有 新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRation）、晋升老年代的对象年龄（-XX:PretenureSizeThreshold）等</code></pre><h4 id="工作流程-2"><a href="#工作流程-2" class="headerlink" title="工作流程"></a>工作流程</h4><p><img alt="parallel scavenge垃圾回收器" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/parallel_scavenge_collection.webp" class="lozad"></p><h2 id="老年代垃圾回收器"><a href="#老年代垃圾回收器" class="headerlink" title="老年代垃圾回收器"></a>老年代垃圾回收器</h2><h3 id="serial-old"><a href="#serial-old" class="headerlink" title="serial old"></a>serial old</h3><h4 id="简单介绍-3"><a href="#简单介绍-3" class="headerlink" title="简单介绍"></a>简单介绍</h4><ul><li>Serial Old是 Serial收集器的老年代版本；</li><li>采用<code>标记-整理</code>算法</li></ul><h4 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>在客户端模式下，虚拟机的老年代区域</li><li>在服务器端：<ul><li>与par scavenge收集器搭配使用</li><li>作为cms的后备方案。在发生 Concurrent Mode Failure 时使用</li></ul></li></ul><h4 id="工作流程-3"><a href="#工作流程-3" class="headerlink" title="工作流程"></a>工作流程</h4><p><img alt="serial old垃圾回收器" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/serial_old_collection.webp" class="lozad"></p><h3 id="parallel-old"><a href="#parallel-old" class="headerlink" title="parallel old"></a>parallel old</h3><h4 id="简单介绍-4"><a href="#简单介绍-4" class="headerlink" title="简单介绍"></a>简单介绍</h4><ul><li>Parallel Old垃圾收集器是Parallel Scavenge收集器的老年代版本</li><li>采用<code>标记-整理</code>算法</li></ul><h4 id="适用场景-4"><a href="#适用场景-4" class="headerlink" title="适用场景"></a>适用场景</h4><p>server模式、多cpu的情况下，可以起到高吞吐量的效果</p><h4 id="参数设置-3"><a href="#参数设置-3" class="headerlink" title="参数设置"></a>参数设置</h4><pre><code>-XX:+UseParallelOldGC：指定使用Parallel Old收集器。java8中默认适用该收集器。</code></pre><h4 id="工作流程-4"><a href="#工作流程-4" class="headerlink" title="工作流程"></a>工作流程</h4><p><img alt="parallel old垃圾回收器" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/parallel_old_collection.webp" class="lozad"></p><h3 id="cms"><a href="#cms" class="headerlink" title="cms"></a>cms</h3><h4 id="简单介绍-5"><a href="#简单介绍-5" class="headerlink" title="简单介绍"></a>简单介绍</h4><ul><li>并行：用户线程&amp;垃圾收集线程可同时进行</li><li>采用<code>标记-清除</code>算法</li><li>目的：追求垃圾收集停顿时间短</li><li>会产生浮动垃圾：因为用户线程和垃圾回收线程同时进行，所以会产生新的垃圾无法标记收集，这种情景下，如果剩余的内存空间不足浮动垃圾存储，就会导致 Concurrent Mode Failure 错误<ul><li>参数设置：-XX:CMSInitiatingOccupancyFraction：设置CMS预留内存空间，java6开始默认 92%</li></ul></li><li>存在内存碎片：这是标记清除的问题，可以通过参数设置进行调整<ul><li>-XX:+UseCMSCompactAtFullCollection：是否进行内存碎片整理，这个过程会很耗时，默认开启，但还需要结合下面参数</li><li>-XX:+CMSFullGCsBeforeCompaction：设置多少次full gc后，进行内存碎片整理。默认为0，即不进行</li></ul></li></ul><h4 id="适用场景-5"><a href="#适用场景-5" class="headerlink" title="适用场景"></a>适用场景</h4><p>希望用户交互好的场景。web服务常用</p><h4 id="参数设置-4"><a href="#参数设置-4" class="headerlink" title="参数设置"></a>参数设置</h4><p>-XX:+UseConcMarkSweepGC：指定使用CMS收集器</p><h4 id="工作流程-5"><a href="#工作流程-5" class="headerlink" title="工作流程"></a>工作流程</h4><p>cms工作流程较复杂，主要分四步</p><table><thead><tr><th>步骤</th><th>操作</th><th>备注</th></tr></thead><tbody><tr><td>初始标记</td><td>仅标记gc root直接关联的对象</td><td>- 速度快 - stw</td></tr><tr><td>并发标记</td><td>从gc root开始标记所有的存活对象</td><td>- 耗时 - 用户线程和收集线程并行执行 - 单线程标记：只开一个线程标记</td></tr><tr><td>重新标记</td><td>修正 并行标记变动对象的 标记记录</td><td>- 速度慢 - stw - 多线程</td></tr><tr><td>并发清除</td><td>清除垃圾</td><td>- 耗时 - 用户线程和收集线程并行 - 单线程</td></tr></tbody></table><p><img alt="cms垃圾回收器" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/cms_collection.webp" class="lozad"></p><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><h4 id="简单介绍-6"><a href="#简单介绍-6" class="headerlink" title="简单介绍"></a>简单介绍</h4><ul><li>region做为垃圾回收最小单位，堆内存最多允许2048个region，每个region大小默认的计算方式是用堆大小/2048 = 每个region的大小，也可手动设置 -XX:G1HeapRegionSize</li><li>新生代和老年代是逻辑概念<ul><li>新生代还是区分 Eden区 和 Survivor区，因为采用的还是复制算法</li><li>进入老年代的时机和其他垃圾回收器一样</li></ul></li><li>新生代默认初始占堆的5%，会动态变化，默认最大不超过堆的 60%，超过了就会进行新生代的垃圾回收</li><li>通过对每个region追踪回收价值（即每个region有多少垃圾，回收需要多长时间），可让用户设置<code>垃圾回收所需时间</code>，用于提高用户的交互性。这是G1最大的特性</li><li>当对象大小大于单个region的50%，标记为大对象，大对象会有专门的大对象存储region（每个region不会固定属性，会动态变化其属于新生代还是老年代）</li><li>采用什么垃圾算法<ul><li>全局看是标记-整理 算法（理解：如果局部都采用复制算法，其实全局看是类似标记整理算法的）</li><li>局部看是 复制 算法</li></ul></li><li>Remember set：用于记录哪些region对象引用了本region里的对象，该方案可以在老年代扫描中减少扫描时间</li><li>新生代和老年代的GC<ul><li>Cset：代表需要回收的目标分区。每次暂停垃圾回收时，会把Cset分区释放，并把存活对象分配到空闲分区（对于新生代和老年代都一样，就是<code>复制算法</code>）。年轻代有年轻代的Cset，混合收集时，会把收益最高的分区放入Cset</li><li>新生代：当Eden区内存不足时，会把Eden区存活对象移向Survivor（和其他垃圾回收器一样）</li><li>老年代：当老年代占用空间大于堆的45%时，进行<code>混合收集</code>，但不会把垃圾全部回收（因为要达到设置的垃圾回收所需时间），会依赖两个值进行回收<ul><li>垃圾回收的最大总次数：-XX:G1MixedGCCountTarget（默认为8）即把垃圾回收分成几次进行回收</li><li>堆废物百分比：-XX:G1HeapWastePercent（默认5%）即把废物垃圾百分比占到该比例不再进行混合回收</li></ul></li></ul></li></ul><h4 id="适用场景-6"><a href="#适用场景-6" class="headerlink" title="适用场景"></a>适用场景</h4><p>针对服务器端的大内存、多cpu机器和服务</p><p>在下面的情况时，使用G1可能比CMS好：</p><p>  （1）超过50％的Java堆被活动数据占用：对于cms 内存会经常满，需要进行full gc</p><p>  （2）对象分配频率或年代提升频率变化很大：对于cms 当内存过大，每次full gc会耗时长</p><p>  （3）GC停顿时间过长（长于0.5至1秒）：对于g1 可以根据价值进行回收</p><h4 id="工作流程-6"><a href="#工作流程-6" class="headerlink" title="工作流程"></a>工作流程</h4><table><thead><tr><th>步骤</th><th>操作</th><th>备注</th></tr></thead><tbody><tr><td>初始标记</td><td>记录直接引用</td><td>- stw - 单线程 - 速度快</td></tr><tr><td>并发标记</td><td>可达性分析</td><td>- 用户线程和收集线程并行 - 单线程</td></tr><tr><td>最终标记</td><td>修正 对象变化 的标记（记录到Rset）</td><td>- stw - 多线程</td></tr><tr><td>筛选回收</td><td>根据价值进行筛选回收</td><td>- stw - 回收效率高 - 多线程</td></tr></tbody></table><p><img alt="G1垃圾回收器" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/G1_collection.webp" class="lozad"></p><h4 id="G1垃圾回收过程"><a href="#G1垃圾回收过程" class="headerlink" title="G1垃圾回收过程"></a>G1垃圾回收过程</h4><p>因为G1的垃圾回收触发机制和回收机制和其他垃圾回收器不太一致，所以特此写下流程</p><ul><li>如果新生代未达到60%，老年代未达到45%，系统正常运行</li><li>如果新生代达到60%，新对象进入新生代，Eden装不下，触发ygc（复制算法）</li><li>对象一直进入新生代，当以下情况进入老年代<ul><li>年龄达15岁（可设置）</li><li>ygc后存活对象放不进survivor区</li><li>survior区大小大于50%（可设置），最大年龄的到老年代</li></ul></li><li>当老年代的占比内存达45%，进行mixed垃圾回收</li><li>以上过程都是先进行复制算法进行垃圾回收，当出现实在没有空闲内存时，会触发full gc，具体原因：<ul><li>新生代拷贝存活对象，找不到空闲区域</li><li>老年代拷贝存活对象，招不到空闲区域</li><li>分配巨型对象招不到连续内存空间</li></ul></li><li>full gc会适用serial old进行垃圾回收</li></ul><p><a href="https://www.cnblogs.com/alsf/p/9484770.html" target="_blank" rel="noopener">参考</a><br><a href="https://www.jianshu.com/p/e5d2435a9122" target="_blank" rel="noopener">参考</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html" target="_blank" rel="noopener">参考:oracle jvm官网介绍</a><br><a href="https://blog.csdn.net/coderlius/article/details/79272773" target="_blank" rel="noopener">参考</a></p><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
          <category> 垃圾回收器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 垃圾回收器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java对象内存计算</title>
      <link href="/posts/a1f3afe4/"/>
      <url>/posts/a1f3afe4/</url>
      
        <content type="html"><![CDATA[<h1 id="java对象内存计算意义"><a href="#java对象内存计算意义" class="headerlink" title="java对象内存计算意义"></a>java对象内存计算意义</h1><p>最近在学习jvm的内存模型，学到参数调优的时候，我发现这个过程需要学会计算对象大小，并且根据具体场景模拟每秒进入内存的对象大小，以此为依据进行新生代和老年代的参数设置。</p><p>在我看着文章一段段说某个方法的大小是多少，然后假设每秒可以预估多少内存进入堆中，我陷入了惶恐，这说的都是啥玩意。</p><p>为了弥补这个知识盲点，方便个人日后的学习，或者在工作中的深入调优，对象的大小计算还是需要了解的。</p><p>当然如果是需要具体的对象大小，有相关工具和方法可以测量，但在具体生产调优中，我们更多的只是需要一个预估值，学习相关知识对预估是有一定帮助的。</p><h1 id="对象大小需要考虑的点"><a href="#对象大小需要考虑的点" class="headerlink" title="对象大小需要考虑的点"></a>对象大小需要考虑的点</h1><p>需要考虑的点不多，主要三点：</p><ol><li>对象头大小</li><li>数据类型大小</li><li>对齐填充</li></ol><p>如下图：</p><p><img alt="对象大小计算" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/java_class_photo.jpg" class="lozad"></p><h2 id="对象头大小"><a href="#对象头大小" class="headerlink" title="对象头大小"></a>对象头大小</h2><h3 id="对象头主要有两部分："><a href="#对象头主要有两部分：" class="headerlink" title="对象头主要有两部分："></a>对象头主要有两部分：</h3><ol><li>markoop（对象标记）：<blockquote><p>存储对象为：对象运行时数据，如哈希码、GC标记、锁信息、线程关联信息<br>占用内存大小：64为jvm上占用 8 字节</p></blockquote></li><li>klassoop（类元信息）：<blockquote><p>存储对象为：指向方法区的instanceKlass（类元数据指针），vm通过这个指针确认这个对象是哪个实例<br>占用内存大小：4个字节</p></blockquote></li></ol><p><strong><em>由上可知：对象头占的空间是 12字节，这是固定的</em></strong></p><p>更形象的图如下：</p><p><img alt="对象内容" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/class_opp.png" class="lozad"></p><p><img alt="引用过程" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/oop_klass.jpg" class="lozad"></p><blockquote><p>markoop对应markword，klassoop对应class对象指针</p></blockquote><h3 id="markoop-和-klassoop的简单介绍"><a href="#markoop-和-klassoop的简单介绍" class="headerlink" title="markoop 和 klassoop的简单介绍"></a>markoop 和 klassoop的简单介绍</h3><p>关于这两个点，可以很深入的去研究，但我们目前只需要知道类加载后，这两者生成的大概流程即可：</p><blockquote><p>一个java类被加载到vm时，会在方法区（如果不清楚，可以等待博主后续对jvm的更新）创建一个instanceKlass，来表示类的class信息。当我们的类用new创建新对象时，会在jvm的堆上创建一个instanceOopDesc对象。该对象就包含了对象头，对象头即包含上面说的两部分。然后这个实例对象会在对应的线程栈上创建一个引用，指向该实例对象。</p></blockquote><p>简单的说，对象生成在堆里，栈里会有指针指向这个对象，同时这个对象有markoop和klassoop，klassoop指向方法区的instanceklass</p><p>这个是栈引用的一种方式，而栈引用存在两种方式：</p><h3 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h3><p>java堆分配出一块句柄池，refrence指向句柄池，句柄池中有指向实例数据和类型数据的具体地址信息</p><p><img alt="句柄访问" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/refrence_ahead.jpg" class="lozad"></p><h3 id="直接指针引用"><a href="#直接指针引用" class="headerlink" title="直接指针引用"></a>直接指针引用</h3><p>就是上面所介绍的方式</p><p><img alt="直接指针引用" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/refrence_ahead.jpg" class="lozad"></p><h3 id="两者的区别和优劣"><a href="#两者的区别和优劣" class="headerlink" title="两者的区别和优劣"></a>两者的区别和优劣</h3><ul><li><p>使用句柄的好处在，refrence存储是稳定的句柄地址，在对象移动时不会改变refrence本身不需要改变，只需要改变句柄池的实例数据的指针</p></li><li><p>直接引用最大好处是节省句柄池的时间开销，如果对象访问频繁，时间节省也会很大</p></li><li><p>我们正常用的java都是HotSpot虚拟机，该虚拟机用的是直接引用</p></li></ul><blockquote><p>这里又存在一个问题，栈引用指向实例对象很好理解，因为需要访问实际数据进行运算，那为什么还需要访问方法区的对象类型数据（class对象）呢？</p></blockquote><h3 id="class对象的介绍"><a href="#class对象的介绍" class="headerlink" title="class对象的介绍"></a>class对象的介绍</h3><p>认识class对象，我们需要先了解RTTI（Run-Time Type Identification）运行时类型识别，其作用是 在运行时识别一个对象的类型和类的信息。</p><p>在我们程序进行编译时，我们新创建的类会产生类对应的class对象字节码，存在同名.class文件中。当我们new对象时，jvm的类加载器会把这个class对象加载，并根据class对象里面的类型信息构建实例对象。实例对象生成后，需要有一个指针指向class对象，因为class对象存有该类的元数据信息，可以明确该对象的属性、方法属性信息等，可以通过相关api获取已经加载对象的信息。具体对象存储内容和大小计算继续看下去。而关于这个编译的过程牵扯到类加载知识，博主后面会进行更新。</p><h2 id="数据类型大小"><a href="#数据类型大小" class="headerlink" title="数据类型大小"></a>数据类型大小</h2><p>这个是java的基础知识，相信大家对下面的表不会陌生：</p><table><thead><tr><th>类型</th><th>默认值</th><th>占用内存（字节）</th></tr></thead><tbody><tr><td>boolean</td><td>false</td><td>1</td></tr><tr><td>byte</td><td>0</td><td>1</td></tr><tr><td>short</td><td>0</td><td>2</td></tr><tr><td>char</td><td>\u00001</td><td>2</td></tr><tr><td>int</td><td>0</td><td>4</td></tr><tr><td>long</td><td>0</td><td>8</td></tr><tr><td>double</td><td>0</td><td>8</td></tr><tr><td>float</td><td>0</td><td>4</td></tr></tbody></table><p>上面是8种基本类型，但在对象内存占用计算中，还需要<strong><em>第九种类型</em></strong></p><table><thead><tr><th>类型</th><th>默认值</th><th>占用内存（字节）</th></tr></thead><tbody><tr><td>对象引用变量（Refrence Varible）</td><td>null</td><td>4</td></tr></tbody></table><p>假设对象引用变量简称refV，实际对象（Referred Object）为：refO：</p><blockquote><p>refV存储引用指向的实际对象的存储地址的首地址。可以直接用==做等值判断。作为对象的引用变量，refV无论指向包装类，集合类，字符串类，自定义类，还是数组，均占用4字节。<br>refO最小占用12字节，即只有对象头，但是要对齐填充，所以最小分配的内存空间是16字节。</p></blockquote><p><strong><em>如果用jvm知识解答，refV其实是会存放到方法栈中，与本文堆存储无关，但做为统一计算的学习也无可厚非</em></strong></p><p>由上面图【对象内容】可以看出，对象会分两类，所以对象的计算公式分两种情况：  </p><table><thead><tr><th>对象类型</th><th>内存分布构成</th></tr></thead><tbody><tr><td>普通对象</td><td>8字节 markWord+4字节 class对象指针 + 数据区 + 补全字节（最后总字节按8的倍数补齐）</td></tr><tr><td>数组对象</td><td>8字节 markWord+4字节 class对象指针 + <code>4字节数组长度</code> + 数据区 + 补全字节（最后总字节按8的倍数补齐）</td></tr></tbody></table><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>对象的存储空间的分配单位是8字节，当对象大小不是8的整数倍的时候需要填充对齐。譬如如果对象的总大小为 22 字节，为了填充成8的整数倍，则实际的内存大小为 24 字节。</p><h2 id="样例分析"><a href="#样例分析" class="headerlink" title="样例分析"></a>样例分析</h2><p>看下面几段java代码：</p><p>样例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> test_field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的内存大小为：</p><blockquote><p>int类型 4 字节 + 对象头 12 字节 = 16字节</p></blockquote><p>样例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> age; </span><br><span class="line">    test test_instance = <span class="keyword">new</span> test();</span><br><span class="line">    test2 test2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的内存大小为：</p><blockquote><p>double类型 8 字节 + test_instance的refv 4字节 + test2 的 4字节 + test对象内存 = 8 + 4 + 4 + 16 = 30</p></blockquote><p><strong><em>因为30不是8的整数倍，所以最后为：32字节</em></strong></p><h3 id="样例2解答"><a href="#样例2解答" class="headerlink" title="样例2解答"></a>样例2解答</h3><blockquote><p>样例2中有两个对象初始化，无论是指向实例对象还是未指向实例对象，只要有类对象的引用，每个变量都占用 4 字节</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://yq.aliyun.com/articles/594507?utm_content=m_50650" target="_blank" rel="noopener">参考[1]</a><br><a href="https://juejin.im/post/5cafe99a6fb9a068553e14d2" target="_blank" rel="noopener">参考[2]</a><br><a href="https://www.cnblogs.com/TvvT-kevin/p/9913913.html" target="_blank" rel="noopener">参考[3]</a></p><hr><center>谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
          <category> 对象内存计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 对象头 </tag>
            
            <tag> 内存计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM常量池分类及介绍</title>
      <link href="/posts/48f0de66/"/>
      <url>/posts/48f0de66/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM常量池分类及介绍"><a href="#JVM常量池分类及介绍" class="headerlink" title="JVM常量池分类及介绍"></a>JVM常量池分类及介绍</h1><p>常量池有以下三种：</p><ul><li>类文件常量池/静态常量池</li><li>运行时常量池</li><li>字符串常量池</li></ul><h2 id="类文件常量池-静态常量池"><a href="#类文件常量池-静态常量池" class="headerlink" title="类文件常量池/静态常量池"></a>类文件常量池/静态常量池</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>class文件编译生成class字节码文件，其结构有一项是常量池，用于存放字面量和符号引用。这部分数据在类加载后会进入方法区的运行时常量池。</p><h3 id="存什么"><a href="#存什么" class="headerlink" title="存什么"></a>存什么</h3><p>存放编译器生成的字面量和符号引用</p><p>关于相关概念做以下解释</p><ul><li>字面量：1.文本字符串 2.八种基本类型的值 3.被声明为final的常量等;</li></ul><blockquote><p>String s = “abc”  abc就是字面量</p></blockquote><ul><li>符号引用：1.类和方法全限定名 2.字段名称和描述 3. 方法名称和描述</li></ul><blockquote><p>存在符号引用的原因是，在未类加载的时候，java类并不知道所引用目标的内存地址，所以需要一个符号来无歧义描述和定位到目标。举例，在编译时 A类引用了B类，但是A类并不知道B类的内存地址，所以先用 address.B 来描述引用了B类</p></blockquote><p>讲到符号引用需要牵扯到直接引用，因为class常量池数据加载后会落到运行时常量池，在运行时常量池中，符号引用会变成直接引用</p><ul><li>直接引用：1. 直接指向目标的指针（指向方法区的指针） 2. 相对偏移量（指向实例变量、实例方法的直接引用都是偏移量） 3. 间接定位对象句柄</li></ul><p>可以认为直接引用就是程序运行时可以定位到引用东西（类，方法，变量，对象）的地址</p><h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>在HotSpot VM里实现的string pool是一个哈希表，java8默认大小值为60013，可以通过-XX:StringTableSize进行设置，被所有类共享，每个实例只有一份</p><h3 id="存什么-1"><a href="#存什么-1" class="headerlink" title="存什么"></a>存什么</h3><p>StringPool中存的是对象实例的引用值，具体的实例分配到jvm的堆里</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p>JVM必须经过加载、连接、初始化，而连接又包括验证、准备、解析。在加载的时候，静态常量池的内容会加载到运行时常量池中，如果发现是成员字符串，字符串就会被装载到字符串常量池中，如果是局部字符串，则在执行到相关代码时才会用到字符串常量池。在解析阶段，会把静态常量池的符号引用转成直接引用。</p><h3 id="存什么-2"><a href="#存什么-2" class="headerlink" title="存什么"></a>存什么</h3><ul><li>class文件元信息描述</li><li>编译后的代码数据</li><li>引用类型数据</li><li>类文件常量池</li></ul><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
          <category> 常量池 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 常量池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM OOM 汇总及介绍</title>
      <link href="/posts/91f0cf3/"/>
      <url>/posts/91f0cf3/</url>
      
        <content type="html"><![CDATA[<h1 id="java-lang-OutOfMemoryError"><a href="#java-lang-OutOfMemoryError" class="headerlink" title="java.lang.OutOfMemoryError"></a>java.lang.OutOfMemoryError</h1><h2 id="java-heap-space"><a href="#java-heap-space" class="headerlink" title="java heap space"></a>java heap space</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>应用程序尝试加入更多数据到堆空间中，但jvm堆空间不足报出该错。相对应的可能物理内存很充裕。</p><h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><ul><li>内存溢出。数据量剧增，超出了预期</li><li>内存泄漏。存在无用对象，但无法被gc掉，因为gc root可达</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>参数设置  </p><blockquote><p>-Xmx10M</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OOM</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">2</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] i = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面程序会报出 java heap space的错误，原因可查看堆内存里面的分配，最后分配到eden区只有2M，加上本身程序会占用部分内存，2M的内存无法进入eden区。为什么不直接进入老年代在于，大对象进入老年代需要parnew和serial的垃圾回收器才有效果。而且我测试发现，所谓的大对象其实没有那么简单的计算方式，我会在其他文章说明。</p></blockquote><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>一般解决方案是加大堆内存即可，但该方法可能治标不治本，例如内存泄漏，可能是代码逻辑问题，加大内存只会推迟报错</p><p>如果要根除，需要定位问题：</p><ul><li>哪些对象占堆内存的大部分</li><li>这些对象再源代码的位置</li></ul><p>如果发现不是代码层面问题，可把堆内存加大</p><h2 id="GC-overhead-limit"><a href="#GC-overhead-limit" class="headerlink" title="GC overhead limit"></a>GC overhead limit</h2><h3 id="现象-1"><a href="#现象-1" class="headerlink" title="现象"></a>现象</h3><p>应用程序jvm花费的总时间的98%用于GC，并且只恢复了不到2%。出现的现象是，多次GC后发现，堆内存马上又满了，需要再次进行GC，这形成了恶性循环，占用大部分程序cpu时间用于GC，应用程序的用户体验会极差。为了避免这种情况，报出改错。</p><h3 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h3><ul><li>内存溢出。数据量剧增，超出了预期</li><li>内存泄漏。存在无用对象，但无法被gc掉，因为gc root可达</li></ul><p>这两个原因导致堆内存占用过高，然后新进的对象的大小又不至于使程序报出java heap space</p><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>参数设置  </p><blockquote><p>-Xmx10M</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Map map = System.getProperties();</span><br><span class="line">    Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      map.put(r.nextInt(), <span class="string">"value"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><p>如果要根除，需要定位问题：</p><ul><li>哪些对象占堆内存的大部分</li><li>这些对象再源代码的位置</li></ul><p>如果不是代码问题，可以加大堆内存</p><h2 id="MetaSpace"><a href="#MetaSpace" class="headerlink" title="MetaSpace"></a>MetaSpace</h2><h3 id="现象-2"><a href="#现象-2" class="headerlink" title="现象"></a>现象</h3><p>堆内存里的元空间区域空间被耗尽</p><h3 id="原因-2"><a href="#原因-2" class="headerlink" title="原因"></a>原因</h3><p>探讨原因前，需要明白元空间的作用。</p><p>元空间在java8后替代永久代，里面存储的数据主要是</p><ul><li>类的名称和字段</li><li>具有方法字节码的类方法</li><li>运行时常量池：符号引用转成直接引用</li><li>JIT优化</li><li>等</li></ul><p>可以简单理解为类的元数据存储，所以报错的原因主要在：太多类或者过大的类加载到了元空间</p><h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>参数设置  </p><blockquote><p>-Xmx10M</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Metaspace</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> javassist.ClassPool cp = javassist.ClassPool.getDefault();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; ; i++) &#123; </span><br><span class="line">Class c = cp.makeClass(<span class="string">"eu.plumbr.demo.Generated"</span> + i).toClass();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>默认元空间是无内存限制的，如果需要调整元空间的限制，可加：</p><blockquote><p>-XX:MaxMetaspaceSize=512m</p></blockquote><p>不限制内存空间可能有的问题是：导致jvm和本地内存的频繁交换，直到物理内存不足分配失败</p><h2 id="Unable-to-create-new-native-thread"><a href="#Unable-to-create-new-native-thread" class="headerlink" title="Unable to create new native thread"></a>Unable to create new native thread</h2><h3 id="现象-3"><a href="#现象-3" class="headerlink" title="现象"></a>现象</h3><p>java程序本质是多线程程序，执行需要线程，所以当线程起不来时，就会报该错误</p><h3 id="原因-3"><a href="#原因-3" class="headerlink" title="原因"></a>原因</h3><ul><li>系统内存耗尽，无法为新线程分配内存</li><li>创建线程数超过了操作系统的限制</li></ul><h3 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h3><p>参数设置  </p><blockquote><p>-Xmx10M</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(InterruptedException e) &#123; &#125;        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><p>围绕着原因进行解决：</p><ul><li>增加机器线程数</li><li>使机器内存得以空余<ul><li>添加机器内存</li><li>减少jvm各内存占用比例</li></ul></li></ul><h2 id="Out-of-swap-space"><a href="#Out-of-swap-space" class="headerlink" title="Out of swap space"></a>Out of swap space</h2><h3 id="现象-4"><a href="#现象-4" class="headerlink" title="现象"></a>现象</h3><p>操作系统在物理内存不足时会用到虚拟内存，虚拟内存的本质是把磁盘当内存用，当物理内存不足时，就会使用虚拟内存，虚拟内存的设置是有上限的，java程序遇到物理内存和虚拟内存都不足时，会报错。</p><h3 id="原因-4"><a href="#原因-4" class="headerlink" title="原因"></a>原因</h3><ul><li>操作系统配置的交换空间不足</li><li>操作系统内存不足</li></ul><h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><p>可提高交换内存空间，但过大的虚拟内存会频繁交换，且磁盘运算能力远小于内存，对应用程序不友好</p><h2 id="Requested-array-size-exceeds-VM-limits"><a href="#Requested-array-size-exceeds-VM-limits" class="headerlink" title="Requested array size exceeds VM limits"></a>Requested array size exceeds VM limits</h2><h3 id="现象-5"><a href="#现象-5" class="headerlink" title="现象"></a>现象</h3><p>java对程序可以分配的最大数组大小有限制，通常在1到21亿之间</p><h3 id="原因-5"><a href="#原因-5" class="headerlink" title="原因"></a>原因</h3><p>该错误由jvm本机代码引发，当程序为数组分配内存之前，jvm会确认机器在分配该数据结构时，是否有足够的寻址范围</p><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h3><p>参数设置  </p><blockquote><p>-Xmx10M</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[Integer.MAX_VALUE-i];</span><br><span class="line">System.out.format(<span class="string">"Successfully initialized an array with %,d elements.\n"</span>, Integer.MAX_VALUE-i);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">t.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行该语句会出现两个java heap space错误，原因在生成2 ^ 31-1 int原语需要8G内存，而你的内存设置小于该值</p></blockquote><h3 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h3><p>减少数组的最大数据集大小</p><h2 id="Kill-process-or-sacrifice-child"><a href="#Kill-process-or-sacrifice-child" class="headerlink" title="Kill process or sacrifice child"></a>Kill process or sacrifice child</h2><h3 id="现象-6"><a href="#现象-6" class="headerlink" title="现象"></a>现象</h3><p>内核操作中，有一个名为 内存不足杀手 ，当可使用内存极低的时候，会对所有进程进行评分，选择得分最差的目标，然后杀死。该过程由操作系统内核的安全网执行。</p><h3 id="原因-6"><a href="#原因-6" class="headerlink" title="原因"></a>原因</h3><ul><li>内存不足时会触发 OOM Killer</li></ul><p>在解释原因后，需要介绍下OOM killer机制背后的内存分配原理。在内存分配背后，系统认为每个应用程序不会把申请到的内存全部用完，所以系统允许的内存分配会大于实际系统内存大小。这样的好处在可以充分把内存使用起来。但当所有应用程序都把申请的内存用满时，其实系统是没有那么多内存的。正如银行取钱，如果全国人都去银行把所有钱取出来，银行是没有那么多钱的。</p><h3 id="解决方案-6"><a href="#解决方案-6" class="headerlink" title="解决方案"></a>解决方案</h3><p>换大内存机器</p><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
          <category> oom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> oom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql索引和优化机制</title>
      <link href="/posts/f9d59ed2/"/>
      <url>/posts/f9d59ed2/</url>
      
        <content type="html"><![CDATA[<h1 id="文章思路"><a href="#文章思路" class="headerlink" title="文章思路"></a>文章思路</h1><ol><li>介绍mysql架构</li><li>介绍索引数据结构</li><li>介绍B+树和mysql页概念</li><li>介绍innodb和myisam的索引</li><li>介绍innodb中的索引优化和场景优化方案</li></ol><h1 id="mysql架构"><a href="#mysql架构" class="headerlink" title="mysql架构"></a>mysql架构</h1><h2 id="mysql架构图"><a href="#mysql架构图" class="headerlink" title="mysql架构图"></a>mysql架构图</h2><p><img alt data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/photos/mysql_connection.jpg" class="lozad"></p><p>第一层为客户端的连接认证，C/S都有此架构，诸如连接处理、授权认证、安全等<br>第二层为服务器层，包含MySQL的大多数核心服务功能 ，包括查询解析、分析、优化、缓存、内置函数、存储过程、触发器、视图等<br>第三层包含了存储引擎，服务器通过API与其通信，API规避了不同存储引擎的差异，不同存储引擎也不会互相通信，另外存储引擎不会去解析SQL(InnoDB是例外，它会解析外键定义，因为服务器本身没有实现该功能)  </p><p>每个连接都会在 MySQL 服务端产生一个线程（内部通过线程池管理线程），比如一个 select 语句进入，MySQL 首先会在查询缓存中查找是否缓存了这个 select 的结果集，如果没有则继续执行解析、优化、执行的过程；否则会之间从缓存中获取结果集。</p><h2 id="mysql机制介绍"><a href="#mysql机制介绍" class="headerlink" title="mysql机制介绍"></a>mysql机制介绍</h2><h3 id="半双工连接"><a href="#半双工连接" class="headerlink" title="半双工连接"></a>半双工连接</h3><p>mysql客户端/服务端通信协议是“半双工”的，即一旦一端开始发送消息，另一端必须接收完整消息才能响应它</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>命中缓存则不会解析和优化sql语句。缓存中包含任何用户自定义函数、存储函数、用户变量、临时表、mysql系统表，其查询不会被缓存。缓存在数据或者结构发生变化的时候会失效。缓存可以关闭和开启</p><h3 id="语法解析和预处理"><a href="#语法解析和预处理" class="headerlink" title="语法解析和预处理"></a>语法解析和预处理</h3><p>mysql会根据关键字对sql语句进行解析，并生成解析树。这个过程会进行验证解析，譬如sql语句关键字是否错误等。预处理则会查看解析树是否合法，譬如查询数据表和列是否存在</p><h3 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h3><p>mysql是使用基于成本的优化器，但其成本计算可能会出错，主要原因在可能统计信息不准确、优化和我们标准不一致（我们希望时间短，但优化器基于成本优化）等。成本统计信息包括：每张表或者索引的页面个数、索引的基数、索引和数据行的长度、索引的分布情况等等</p><h3 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a>查询执行引擎</h3><p>完成解析和优化，mysql会生成对应的执行计划。然后通过调用api去存储引擎查询数据</p><h3 id="完整过程"><a href="#完整过程" class="headerlink" title="完整过程"></a>完整过程</h3><ol><li>客户端向mysql服务器发送一条查询请求</li><li>服务器先看缓存，如果有直接返回</li><li>服务器进行解析、预处理、优化并生成执行计划</li><li>mysql根据执行计划调用存储引擎api执行查询</li><li>将结果返回给客户端，同时缓存结果</li></ol><h3 id="sql语句执行过程"><a href="#sql语句执行过程" class="headerlink" title="sql语句执行过程"></a>sql语句执行过程</h3><ol><li>FROM：对FROM子句中的表执行笛卡尔积(交叉联接)，生成虚拟表VT1。</li><li>ON：对VT1应用ON筛选器，只有那些使为真才被插入到TV2。</li><li>OUTER (JOIN):如果指定了OUTER JOIN(相对于CROSS JOIN或INNER JOIN)，保留表中未找到匹配的行将作为外部行添加到VT2，生成TV3。如果FROM子句包含两个以上的表，则对上一个联接生成的结果表和下一个表重复执行步骤1到步骤3，直到处理完所有的表位置。</li><li>WHERE：对TV3应用WHERE筛选器，只有使为true的行才插入TV4。</li><li>GROUP BY：按GROUP BY子句中的列列表对TV4中的行进行分组，生成TV5。</li><li>CUTE|ROLLUP：把超组插入VT5，生成VT6。</li><li>HAVING：对VT6应用HAVING筛选器，只有使为true的组插入到VT7。</li><li>SELECT：处理SELECT列表，产生VT8。</li><li>DISTINCT：将重复的行从VT8中删除，产品VT9。</li><li>ORDER BY：将VT9中的行按ORDER BY子句中的列列表顺序，生成一个游标(VC10)，生成表TV11，并返回给调用者。</li></ol><h1 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h1><p>关于mysql B+树索引介绍，需要先把二叉查找树，平衡二叉树和B树做简单介绍，也是这章目的。</p><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>二叉查找树的特点是：左节点都比当前节点小，右节点都比当前节点大。</p><p>这个特性在查找过程中是有优势的，因为和当前节点比较，如果小于就遍历左节点，如果大于就遍历右节点。</p><p>二叉查找树定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一棵空树，或者是具有下列性质的二叉树：</span><br><span class="line">（1）若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</span><br><span class="line">（2）若右子树不空，则右子树上所有结点的值均大于它的根结点的值；</span><br><span class="line">（3）左、右子树也分别为二叉排序树；</span><br><span class="line">（4）没有键值相等的结点。</span><br></pre></td></tr></table></figure><p>二叉查找树是二叉树的特例，所以每个节点其实只会存一个键值和数据，因为每次查询都是二分查询，会比顺序查找快。</p><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>平衡二叉树的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 必须为二叉查找树</span><br><span class="line">2. 每个节点的左右子树高度差至多为1</span><br></pre></td></tr></table></figure><p>举例看下图：</p><p><img alt data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/photos/two_balance.jfif" class="lozad"></p><p>左边的树 45 那个节点，左边有44 43两个节点，但右边没有节点，所以这个高度差为2，是非平衡二叉树</p><p>右边的树每个节点都符合高度差至多为1的条件，所以为平衡二叉树</p><p>平衡二叉树之所以可以保持高度差至少为1，在于这是一颗会旋转的树，关于其算法实现，后面博客实现并会列到算法标签</p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>上面说到，二叉查找树的每个节点只会保存一个键值和数据，这对于大数据量来说是致命的，因为当数据量过大的时候，树的高度简直无法预估。而我们知道，内存的读取效率是远高于磁盘的，所以我们希望每次从磁盘读取数据的时候，可以尽可能多的把数据读到内存处理，但二叉树的特性会使读到内存的数据受限，所以我们希望有个数据结构可以尽可能多的把键值读到内存。这是B树来源</p><p>B树其实是平衡n叉查找树，这里的B指的是Balance，B树定义为（M代表节点有多少个查找路径）：</p><ol><li>根节点至少有两个子女</li><li>每个非根节点包含关键字个数满足：大于等于ceil(m/2)-1个且小于等于M-1个（ceil(1.1)为2）</li><li>除根节点以外的所有节点（不包含叶子节点）查找路径是关键字+1，故满足：大于等于ceil(m/2)个且小于等于M个（ceil(1.1)为2）</li><li>所有叶子节点都在同一层</li></ol><p>举例：</p><p><img alt data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/photos/B_tree_photo1.png" class="lozad"></p><p>用上面这个图来解释B树定义：</p><p>首先图里的这是一个4阶B树，原因是<code>11 12</code>|<code>14 15</code>|<code>17 18</code>|<code>20 21</code>，这四个节点是最多的</p><ol><li>根节点是10那个节点</li><li>非根节点关键个数：<code>3 6</code>|<code>13 16 19</code> 这两个节点就是关键个数的值。通过公式计算得：<blockquote><p>ceil(4/2) - 1 =&lt; 关键个数 &lt;= 4-1  即： 1&lt;=关键个数&lt;=3</p></blockquote></li><li>查找路径就是<code>13 16 19</code>链接的那四个子节点和<code>3 6</code>的三个子节点，查找路径满足关键字范围+1：即 <blockquote><p>2&lt;=查找路径&lt;=4</p></blockquote></li><li>所有子节点都在同一层，最后一行就是都在同一层</li></ol><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>B+树是B树的升级版本，它的定义为：</p><ol><li>每个节点至多m个子女</li><li>除根节点，每个节点至少有m/2个子女，根节点至少2个子女</li><li>有k个子女的节点必然有k个关键字</li></ol><p>B+树和B树的区别：</p><ol><li>有K个子节点的节点就必然有k个关键字</li><li>非叶节点具有索引作用，记录信息存在叶子节点</li><li>树的叶子节点构成一个有序链表，可以按照关键字排序遍历</li></ol><h1 id="介绍B-树和mysql页概念"><a href="#介绍B-树和mysql页概念" class="headerlink" title="介绍B+树和mysql页概念"></a>介绍B+树和mysql页概念</h1><p>在介绍mysql B+树的概念前，需要先对mysql的页概念有个大致了解</p><h2 id="mysql页概念"><a href="#mysql页概念" class="headerlink" title="mysql页概念"></a>mysql页概念</h2><p>mysql的数据存储最小单位为页，一页默认16k（可设置），操作系统默认页为4k，扇区默认512B。</p><p>每个页之间是通过双向指针进行连接，页里面的是一个单链表，链表节点是一行一行的数据。每个页都有它自身的属性，像B+树的非叶子节点就是存目录项记录的页。</p><p>每4行数据会划分一个槽，当查找数据的时候，我们可以通过二分查找槽的位置快速查找数据位置，大概过程为：</p><ol><li>通过二分法确认记录所在的槽，并找到和对比该槽最小记录，直到找到符合要求的槽</li><li>通过记录的next_record属性遍历槽内数据</li></ol><p>关于页的具体介绍，我会单独写篇文章，页的图示如下：</p><p><img alt data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/photos/16a01bd1b8eafbb4" class="lozad"></p><h2 id="mysql的B-树"><a href="#mysql的B-树" class="headerlink" title="mysql的B+树"></a>mysql的B+树</h2><p>关于B+树，上面其实已经简单介绍过了，并且结合mysql的页概念，关于B+树的工作原理也就不会难理解</p><p>mysql B+树查询工作原理：</p><ol><li>从根节点开始遍历</li><li>根据条件二分查找选择不同的子节点，最后到叶子节点</li><li>叶子节点进行二分查找找到对应的值</li></ol><p>mysql B+树插入情况：</p><blockquote><p>leaf page：叶子节点 || index page：内部节点</p></blockquote><table><thead><tr><th>leaf page满</th><th>index page满</th><th>操作</th></tr></thead><tbody><tr><td>no</td><td>no</td><td>直接将记录插入叶子节点</td></tr><tr><td>yes</td><td>no</td><td><code>1.拆分leaf page</code> <code>2. 将中间的节点放入index page中</code> <code>3.小于中间节点的放左边</code> <code>4.大于等于中间节点记录放右边</code></td></tr><tr><td>yes</td><td>no</td><td><code>1.拆分leaf page</code> <code>2.小于中间节点的记录放左边</code> <code>3.大于等于中间节点的记录放右边</code> <code>4.拆分index page</code> <code>5.小于中间节点的记录放左边</code> <code>6.大于中间节点记录放右边</code> <code>7.中间节点放上一层index page</code></td></tr></tbody></table><blockquote><p>这里还有一种情况，当叶子节点的左右节点数据没有满时，会做左右旋转（即把数据全部左移或者右移），以避免页分裂</p></blockquote><p>介绍完B+树原理，我们先来看个面试题：</p><p><code>1) 为什么要用B+树构建索引，而不是B树：</code></p><ol><li>因为B树非叶子节点也存数据，会增加树的高度，导致更多的io开销，查询性能更低</li><li>B+树范围查找只需要遍历子节点，但B树不行</li><li>B+树的查询效率更稳定，因为叶子节点存数据，非叶子节点存索引，查询不同的数据查询路径长度相同</li></ol><p><code>2) 一棵B+树可以添加多少数据？</code></p><p>叶子节点：假设一行数据为1k，则一页可以存16行数据<br>非叶子节点：假设主键为bigint类型，占8各字节，指针大小默认为6字节，一行占14字节，那非叶子节点一页可以存16384/14=1170条数据</p><p>所以：<br>一颗高度为2的B+树可以存 1170<em>16 = 18720条数据<br>一颗高度为3的B+树可以存 1170</em>1170*16 = 21902400 条数据<br>3层高的树就可以存千万级数据</p><p>（page number为3的代表主键索引的根页，page number为4的默认为二级索引）</p><p><code>3) mysql为什么把节点大小设置成系统页的整数倍？</code></p><p>磁盘读取会发生预读，预读的范围就是页的整数倍。很多Os系统页的大小为4k，主存和磁盘以页为单位交换数据。当程序读取数据不在主存时，会发生缺页异常，并从磁盘中读取连续几页的数据。这样mysql的节点可以在一次IO就读到内存中</p><h1 id="innodb和myisam的索引"><a href="#innodb和myisam的索引" class="headerlink" title="innodb和myisam的索引"></a>innodb和myisam的索引</h1><p>innodb和myisam索引叶子节点存储的数据不一样，主要原因在于两者的存储引擎特性不一致导致。</p><h2 id="myisam的索引"><a href="#myisam的索引" class="headerlink" title="myisam的索引"></a>myisam的索引</h2><h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>MyISAM引擎使用B+树作为索引结果，叶节点的data域存放的是数据记录的地址</p><p><img alt data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/photos/myisam_primary_photo.png" class="lozad"></p><h3 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h3><p>在MyISAM中，主索引和辅助索引在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复</p><p><img alt data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/photos/myisam_second_photo.png" class="lozad"></p><h2 id="innodb的索引"><a href="#innodb的索引" class="headerlink" title="innodb的索引"></a>innodb的索引</h2><h3 id="innodb的主键索引"><a href="#innodb的主键索引" class="headerlink" title="innodb的主键索引"></a>innodb的主键索引</h3><p>innodb的主键索引又叫聚簇索引，原因是：innodb叶节点存的是完整记录</p><p><img alt data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/photos/innodb_primary_photo.png" class="lozad"></p><h3 id="innodb的辅助索引"><a href="#innodb的辅助索引" class="headerlink" title="innodb的辅助索引"></a>innodb的辅助索引</h3><p>innodb的辅助索引叶节点存的是索引值和主键值</p><p><img alt data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/photos/innodb_second_photo.png" class="lozad"></p><p>如果利用辅助索引进行查询的话，需要做回表操作，即先通过辅助索引找到对应的主键，然后通过主键再回到主键索引进行查询，返回最后的记录。如果辅助索引的高度为3，主键索引高度也为3，最后就需要6次IO操作</p><p>索引的查询是顺序IO（原因是表空间在申请的时候是尽可能连续空间），所以效率很快，但回表操作是随机IO，所以当需要回表的数据特别大的时候，其实也是耗时的</p><h3 id="innodb的联合索引"><a href="#innodb的联合索引" class="headerlink" title="innodb的联合索引"></a>innodb的联合索引</h3><p>联合索引是指对表上多个列进行建立索引。联合索引构建的索引是要按照建立索引时候的顺序进行排序构建B+树的，所以构建索引时候的字段顺序需要注意，后面优化会讲到。</p><p>举例：</p><p>给字段 name,age 做联合索引</p><table><thead><tr><th>name</th><th>age</th></tr></thead><tbody><tr><td>精进马大使</td><td>18</td></tr><tr><td>精进马大使2号</td><td>22</td></tr><tr><td>江仕锴</td><td>24</td></tr><tr><td>吴彦祖</td><td>28</td></tr></tbody></table><p>最后生成的B+树这样排序：</p><p><code>精进马大使|18</code>-&gt; <code>精进马大使2号|22</code> -&gt; <code>江仕锴|24</code> -&gt; <code>吴彦祖|28</code></p><blockquote><p>先按name排序，再按age排序</p></blockquote><h3 id="innodb的覆盖索引"><a href="#innodb的覆盖索引" class="headerlink" title="innodb的覆盖索引"></a>innodb的覆盖索引</h3><p>覆盖索引指的是：索引值在sql语句的所选字段里面。官方的语言就是<code>从辅助索引中就可以直接得到查询的记录</code>，这样的好处在不需要回表，而且辅助索引的信息少，可以减少IO操作</p><p>举例：</p><p>c1,c2是t1的索引，所以下面是覆盖索引场景：</p><blockquote><p>select c1,c2 from t1 where c1 = ‘b’ and c2 = ‘a’</p></blockquote><h3 id="innodb的哈希索引"><a href="#innodb的哈希索引" class="headerlink" title="innodb的哈希索引"></a>innodb的哈希索引</h3><p>InnoDB存储引擎使用哈希算法来对字典进行查找，哈希碰撞采用转链表解决，哈希函数采用除法散列方式。对等值查询很快，对范围查询无能为力</p><h2 id="索引代价和使用条件"><a href="#索引代价和使用条件" class="headerlink" title="索引代价和使用条件"></a>索引代价和使用条件</h2><h3 id="代价"><a href="#代价" class="headerlink" title="代价"></a>代价</h3><ol><li>空间上的代价<blockquote><p>每建立一个索引，都会构建一个B+树，每棵B+树的每个节点都是一个数据页，一页默认16k，每棵树有多个数据页</p></blockquote></li><li>时间代价<blockquote><p>上面页的概念中讲到，索引的构成是页之间双向链表顺序连接，页里面的记录是单向链表顺序连接，但每次增删改的时候，都会打破顺序，需要重排序，所以存储引擎需要额外时间做记录移位（页分裂、页回收），每个索引对应的B+树都要做相关操作，索引多了自然需要耗费时间在这上面</p></blockquote></li></ol><h3 id="适用条件"><a href="#适用条件" class="headerlink" title="适用条件"></a>适用条件</h3><p>我们拿上面联合索引的例子来看适用条件：</p><p>假设表名为test1</p><table><thead><tr><th>name</th><th>age</th></tr></thead><tbody><tr><td>精进马大使</td><td>18</td></tr><tr><td>精进马大使2号</td><td>22</td></tr><tr><td>江仕锴</td><td>24</td></tr><tr><td>吴彦祖</td><td>28</td></tr></tbody></table><p>构建联合索引：</p><p><code>精进马大使|18</code>-&gt; <code>精进马大使2号|22</code> -&gt; <code>江仕锴|24</code> -&gt; <code>吴彦祖|28</code></p><ol><li>全值匹配</li></ol><p>全值匹配中，用and连接的各索引顺序不影响查询结果，因为有优化器的作用</p><ol start="2"><li>匹配左边列</li></ol><p>用到索引：</p><blockquote><p>select * from test1 where name = ‘精进马大使’<br>select * from test1 where name = ‘精进马大使’ and age = ‘18’</p></blockquote><p>用不到索引：</p><blockquote><p>select * from test1 where age = ‘18’</p></blockquote><p>原因：<code>因为是按照从左到右建立索引顺序，如果不按从左到右使用索引，它无法获取第二个索引的排序状态</code></p><ol start="3"><li>匹配列前缀</li></ol><p>用到索引：</p><blockquote><p>select * from test1 where name like ‘精进%’</p></blockquote><p>用不到索引：</p><blockquote><p>select * form test1 where name like ‘%精进’</p></blockquote><p>原因：<code>索引是按照前缀进行排序的，如果前缀确认可以用索引定位，如果前缀不确认无法用到索引</code></p><ol start="4"><li>匹配范围值</li></ol><p>用到索引：</p><blockquote><p>select * from test1 where name &gt; ‘精进马大使’ and name &lt; ‘吴彦祖’</p></blockquote><p>用不到索引：</p><blockquote><p>select * from test1 where name &gt; ‘精进马大使’ and name &lt; ‘吴彦祖’ and age &gt; ‘20’</p></blockquote><p>原因：<code>如果前面索引用了范围匹配，后面的索引会用不上，还是索引排序的原因</code></p><ol start="5"><li>精确匹配某一列，范围查询另一列</li></ol><p>用到索引：</p><blockquote><p>select * from test1 where name = ‘精进马大使’ and age &gt; ‘18’</p></blockquote><ol start="6"><li>用于排序和分组</li></ol><p>正常order by会把数据读到内存然后用排序算法进行排序（快排、归并等），如果内存不够，则会借助磁盘空间存放中间结果。这个过程叫文件排序</p><p>但如果order by索引列，因为索引自身就是排序的，所以返回会很快。分组也一样</p><ol start="7"><li><p>用到表达式和函数处理列的，无法用到索引</p></li><li><p>优化关联语句</p></li></ol><p>关联语句的后面列如果是索引列，会加速定位。因为关联语句前面列会被遍历，后面列会利用前面遍历出来的值做等值定位</p><blockquote><p>select * from test1 join test2 on test1.name = test2.name</p></blockquote><p>这里会遍历test1.name的值，并把值传递给test2.name，test2.name利用值进行等值查询</p><h1 id="innodb中的索引优化和场景优化方案"><a href="#innodb中的索引优化和场景优化方案" class="headerlink" title="innodb中的索引优化和场景优化方案"></a>innodb中的索引优化和场景优化方案</h1><h2 id="不使用null的原因"><a href="#不使用null的原因" class="headerlink" title="不使用null的原因"></a>不使用null的原因</h2><ol><li>NOT IN、!= 等负向条件查询在有 NULL值的情况下返回永远为空结果，查询容易出错<blockquote><p>select * from t1 where c1 not in null：会返回空</p></blockquote></li><li>NULL值到非NULL的更新无法做到原地更新，更容易发生索引分裂，从而影响性能（这个带来的性能问题很小）</li><li>NULL会使索引、索引统计和值更加复杂，并且需要额外一个字节的存储空间</li></ol><h2 id="count的使用"><a href="#count的使用" class="headerlink" title="count的使用"></a>count的使用</h2><p>count(*)：全部行<br>count(列)：不包含null的行</p><h2 id="索引优化汇总"><a href="#索引优化汇总" class="headerlink" title="索引优化汇总"></a>索引优化汇总</h2><ol><li>只为用于搜索、排序或分组的列创建索引</li><li>为列的基数大的列创建索引</li><li>索引列的类型尽量小</li><li>可以只对字符串值的前缀建立索引</li><li>只有索引列在比较表达式中单独出现才可以适用索引</li><li>为了尽可能少的让聚簇索引发生页面分裂和记录移位的情况，建议让<code>主键拥有AUTO_INCREMENT属性</code>。</li><li>定位并删除表中的重复和冗余索引</li><li>尽量使用<code>覆盖索引</code>进行查询，<code>避免回表</code>带来的性能损耗。</li></ol><h3 id="为什么性别不能用作索引"><a href="#为什么性别不能用作索引" class="headerlink" title="为什么性别不能用作索引"></a>为什么性别不能用作索引</h3><p>这个点主要应对第二个点，列基数大的列建立索引才有用，性别基数小，只有2，所以没啥用，那为啥？核心答案是会产生更多IO</p><p>myisam存储引擎：</p><blockquote><p>因为索引记录的是内存地址，如果为性别建立索引，会为大范围记录进行内存地址的IO查找，这样的查询不如顺序遍历扫描全表快</p></blockquote><p>innodb存储引擎：</p><blockquote><p>如果性别列是辅助索引，这时候还需要回表操作，什么是回表操作？上面辅助索引有讲。回表操作时随机IO，性别基数小，会有大批记录需要回表，这时候随机IO就不如全表扫描的顺序IO来的快。</p></blockquote><p><code>但是innodb中，如果性别做聚簇索引，效率会有提升，因为可以用索引快速定位到整行数据</code></p><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> mysql知识 </category>
          
          <category> 索引 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql锁机制优化汇总</title>
      <link href="/posts/cdbb5827/"/>
      <url>/posts/cdbb5827/</url>
      
        <content type="html"><![CDATA[<h1 id="文章思路"><a href="#文章思路" class="headerlink" title="文章思路"></a>文章思路</h1><p>根据以下思路进行介绍：</p><ol><li>锁有哪些</li><li>各个锁的使用场景和简单介绍</li><li>innodb和myisam引擎锁的简单介绍</li><li>如何加锁</li><li>锁可能会出现的问题</li><li>如何优化锁相关机制</li></ol><h1 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h1><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>乐观锁指的是，数据库很乐观，觉得每次查询和修改数据库数据都不会出现冲突情况，只在提交操作时检查是否违反数据完整性，适合多读情况</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>通过版本来进行控制，每次修改完数据，都会拿当前版本信息和读取时的版本信息进行对比，如果版本信息变化了，就认为是过期数据</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</p><h3 id="悲观锁和存储引擎"><a href="#悲观锁和存储引擎" class="headerlink" title="悲观锁和存储引擎"></a>悲观锁和存储引擎</h3><p>mysql的存储引擎是可插拔的，mysql通过api使用存储引擎进行存储。不同的存储引擎会支持不同的锁。我这里只总结innodb和myisam的区别</p><table><thead><tr><th>存储引擎</th><th>级别锁</th><th>支持的锁</th></tr></thead><tbody><tr><td>myisam引擎</td><td>表级锁</td><td>表级共享锁、表级排他锁</td></tr><tr><td><code>innodb引擎</code></td><td>表级锁</td><td>意向共享锁、意向排他锁</td></tr><tr><td>mysisam引擎</td><td>行级锁</td><td>无</td></tr><tr><td><code>innodb引擎</code></td><td>行级锁</td><td>行级共享锁、行级排他锁、间隙锁、next-key锁、插入意向锁</td></tr></tbody></table><h3 id="myisam悲观锁介绍"><a href="#myisam悲观锁介绍" class="headerlink" title="myisam悲观锁介绍"></a>myisam悲观锁介绍</h3><p>上面表格看到，myisam只支持表级锁：</p><ol><li>对myisam表的读操作（表级共享锁）：<code>不会阻塞</code>对同一表的<code>读操作</code>，但会阻塞同一表的写操作</li><li>对myisam表的写操作（表级排他锁）：<code>会阻塞</code>对同一表的<code>读写操作</code></li></ol><blockquote><p>表级锁：会以表做为粒度加锁</p></blockquote><p>优化建议：</p><ol><li>concurrent_insert：主要可以调整并发策略</li><li>low_priority_updates：设置1则读优先写</li><li>给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会。</li></ol><h3 id="innodb悲观锁介绍"><a href="#innodb悲观锁介绍" class="headerlink" title="innodb悲观锁介绍"></a>innodb悲观锁介绍</h3><p>在做innodb锁介绍前，先对innodb的锁进行分类（根据上面表格分类）：</p><blockquote><p>行级锁：共享锁、排他锁、间隙锁、next-key锁、插入意向锁<br>表级锁：意向共享锁、意向排他锁</p></blockquote><p>这里先做简单的介绍，关于什么时候会用什么锁可以看下文的<code>如何加锁</code></p><h4 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h4><ol><li>共享锁（S）：Shared Locks 也称为读锁，读锁允许多个连接同时并发读同一资源</li><li>排他锁（X）：Exclusive Locks 也称为写锁，保证只有一个资源在进行写操作，并写阻塞其他用户对该资源读写操作</li></ol><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>意向锁分为：</p><ol><li>意向共享锁：An intention shared lock (IS)</li><li>意向排他锁：An intention exclusive lock (IX)</li></ol><p>意向锁是innodb中<code>粒度较粗锁度较弱</code>的锁，他的作用主要做<code>意向预判</code>，即如果你连表级锁都没法获取，就没必要花资源去找行级锁了。那它是如何做到预判的？主要通过和行锁的兼容来预判（下面的表也是各博客的常客）：</p><table><thead><tr><th></th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td>IX</td><td>不兼容</td><td>兼容</td><td>不兼容</td><td>兼容</td></tr><tr><td>S</td><td>不兼容</td><td>不兼容</td><td>兼容</td><td>兼容</td></tr><tr><td>IS</td><td>不兼容</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><h4 id="索引行锁（Record-Locks）"><a href="#索引行锁（Record-Locks）" class="headerlink" title="索引行锁（Record Locks）"></a>索引行锁（Record Locks）</h4><p>通过名字可以看得出这是一个对索引进行加锁的锁机制。如果执行的语句中没有索引的话，就会给加上表锁，原因是通过索引我们可以快速找到需要加锁的行，但没有索引，执行计划就是需要扫描全表，扫描表的过程中会给每条记录加上<code>next-key锁</code>。但哪怕用到了索引，如果执行计划觉得没必要用到索引，譬如数据量很小，那还是会加表锁。所以这是基于执行计划的锁机制。</p><p>有些博客说到的点我没测出来：</p><blockquote><p>由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。</p></blockquote><p>我使用的版本是5.7.21-20，如果用相同的索引键并不会锁冲突，但如果是相同值，则会锁冲突，即<code>我所发现的是锁记录，而非锁索引键</code>。</p><p>innodb中，如果没有显式的为表加锁，表也会有个隐式的字段用来做主键，这点主要原因是innodb聚簇索引的特性所致。</p><h4 id="间隙锁（gap锁）"><a href="#间隙锁（gap锁）" class="headerlink" title="间隙锁（gap锁）"></a>间隙锁（gap锁）</h4><p>间隙锁是给间隙设置的锁。如果加间隙锁，则会在指定值前面的间隙加锁。</p><h4 id="next-key锁"><a href="#next-key锁" class="headerlink" title="next-key锁"></a>next-key锁</h4><p>next-key锁是索引行锁和间隙锁的集合。即如果用到next-key锁，则会把记录和该记录的前一个间隙加锁。</p><p>加next-key锁的目的：</p><ol><li>为了满足幻读</li><li>为了满足恢复与复制：并发的插入和更新需要控制顺序，不然会导致binlog的顺序错乱。binlog作用主要在主从同步和数据恢复。</li></ol><p>会产生next-key锁的情况：</p><ol><li>使用范围的加锁机制</li><li>等值加锁不存在的值</li></ol><h4 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h4><p>插入意向锁本质是gap锁，但它不会阻塞别的操作（如果插入数据不一致，插入意向锁间是兼容的，对别的语句而言也是共享的），主要目的是为了<code>提高并发插入</code>。插入意向锁会在获取gap锁，然后希望在这个gap区域插入数据时，获取到插入意向锁。举个例子就会秒懂：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">假设现在有记录 10， 30， 50， 70 ；且为主键 ，需要插入记录 25 。</span><br><span class="line"></span><br><span class="line">找到 小于等于25的记录 ，这里是 10</span><br><span class="line">找到 记录10的下一条记录 ，这里是 30</span><br><span class="line">判断 下一条记录30 上是否有锁</span><br><span class="line">1. 判断 30 上面如果 没有锁 ，则可以插入</span><br><span class="line">2. 判断 30 上面如果有Record Lock，则可以插入</span><br><span class="line">3. 判断 30 上面如果有Gap Lock/Next-Key Lock，则无法插入，因为锁的范围是 (10, 30) /（10, 30] ；在30上增加insert intention lock（ 此时处于waiting状态），当 Gap Lock / Next-Key Lock 释放时，等待的事物（ transaction）将被 唤醒 ，此时 记录30 上才能获得 insert intention lock ，然后再插入 记录25</span><br><span class="line">注意：一个事物 insert 25 且没有提交，另一个事物 delete 25 时，记录25上会有 Record Lock</span><br></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a></h4><h1 id="如何加锁"><a href="#如何加锁" class="headerlink" title="如何加锁"></a>如何加锁</h1><p>关于加锁的介绍其实各博客都已经写烂了，我只是做汇总，但有个问题困惑过我，我想做记录：</p><blockquote><p>如果我不用加锁语句，语句会加锁吗？mysql是如何做到事务隔离级别的？</p></blockquote><p>关于这个问题，需要先介绍两个概念，分别是显式锁和隐式锁</p><h2 id="显式锁"><a href="#显式锁" class="headerlink" title="显式锁"></a>显式锁</h2><p>顾名思义是手动添加的锁，也是博客常用的显示加锁：</p><p>添加共享锁</p><blockquote><p>select * from table where id = ? lock in share mode;</p></blockquote><p>添加排他锁</p><blockquote><p>select * from table where id = ? for update</p></blockquote><h2 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h2><p>默认存储引擎会根据不同的隔离级别进行加锁。</p><h3 id="myisam的隐式锁"><a href="#myisam的隐式锁" class="headerlink" title="myisam的隐式锁"></a>myisam的隐式锁</h3><p>在使用 MyISAM 存储引擎时。执行 SQL 语句，会自动为 SELECT 语句加上共享锁，为 UDI（更新，删除，插入）操作加上排他锁。</p><h3 id="innodb的隐式锁"><a href="#innodb的隐式锁" class="headerlink" title="innodb的隐式锁"></a>innodb的隐式锁</h3><p>innodb的隐式锁会根据事务级别进行处理</p><p><img alt data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/photos/lock_photo1.jpg" class="lozad"></p><p><img alt data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/photos/lock_photo2.jpg" class="lozad"></p><h1 id="使用锁需要注意的问题"><a href="#使用锁需要注意的问题" class="headerlink" title="使用锁需要注意的问题"></a>使用锁需要注意的问题</h1><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁是指两个或多个事务在同一个资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</p><p>产生原因：</p><ol><li>真正的数据冲突</li><li>存储引擎的实现方式</li></ol><p>解决方案(部分或完全回滚其中一个事务)：</p><ol><li><code>wait-for graph 算法来主动进行死锁检测</code>。InnoDB处理死锁的方法：将持有最少行级的排它锁的事务进行回滚(比较简单的回滚算法)</li><li><code>innodb_lock_wait_timeout等待锁超时回滚事务</code>。死锁超时机制，超时后放弃对锁的请求</li></ol><h2 id="优化锁机制"><a href="#优化锁机制" class="headerlink" title="优化锁机制"></a>优化锁机制</h2><ol><li>尽量使用较低的隔离级别；</li><li>精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会</li><li>选择合理的事务大小，小事务发生锁冲突的几率也更小</li><li>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁</li><li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会</li><li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响</li><li>不要申请超过实际需要的锁级别</li><li><code>除非必须，查询时不要显示加锁。</code>  MySQL的MVCC可以实现事务中的查询不用加锁，优化事务性能；MVCC只在COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作</li><li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/29150809" target="_blank" rel="noopener">参考1</a><br><a href="https://juejin.im/post/5b82e0196fb9a019f47d1823" target="_blank" rel="noopener">参考2</a><br><a href="https://juejin.im/post/5cb6c4ef51882532b70e6ff0" target="_blank" rel="noopener">参考3</a><br><a href="https://blog.csdn.net/mysteryhaohao/article/details/51669741" target="_blank" rel="noopener">参考4</a><br><a href="https://www.cnblogs.com/rjzheng/p/9950951.html" target="_blank" rel="noopener">参考5</a></p><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> mysql知识 </category>
          
          <category> 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm 逃逸分析</title>
      <link href="/posts/5d514306/"/>
      <url>/posts/5d514306/</url>
      
        <content type="html"><![CDATA[<blockquote><p>撑着油纸伞，独自<br>彷徨在悠长、悠长<br>又寂寥的雨巷，<br>我希望飘过<br>一个丁香一样地<br>结着愁怨的姑娘<br>——《雨巷》戴望舒</p></blockquote><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>逃逸分析是java JIT的一个优化方案。</p><h2 id="什么是逃逸分析"><a href="#什么是逃逸分析" class="headerlink" title="什么是逃逸分析"></a>什么是逃逸分析</h2><p>逃逸分析需要分开两个词讨论，分别是逃逸和分析</p><h3 id="什么是逃逸"><a href="#什么是逃逸" class="headerlink" title="什么是逃逸"></a>什么是逃逸</h3><p>逃逸分析的基本行为就是分析对象动态<code>作用域</code>：当一个对象在方法中被定义后，它可能<code>被外部方法所引用</code>，例如作为调用参数传递到其他地方中，称为<code>方法逃逸</code>。甚至还有可能被外部线程访问到，比如赋值给类变量或可以在其他线程中访问的实例变量，称为<code>线程逃逸</code>。如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或者线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">skip</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> String[] skip()&#123;</span><br><span class="line">       String[] str = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">       <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面对象定义后，return出方法，这种现象就叫逃逸</p><h1 id="逃逸分析的作用"><a href="#逃逸分析的作用" class="headerlink" title="逃逸分析的作用"></a>逃逸分析的作用</h1><p>使用逃逸分析可以优化三个方面：</p><ol><li>同步省略</li><li>栈上分配</li><li>分离对象或标量替换</li></ol><h2 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h2><p>如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p><blockquote><p>即如果一个加了锁的方法，我发现该方法并没有逃逸，可以把锁消除</p></blockquote><h2 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h2><p>如果一个对象没有逃逸出方法，可能会把对象分配到栈上（正常分配到堆上），好处在：不需要gc，会跟着线程生命周期而结束。</p><h2 id="分离对象或标量替换"><a href="#分离对象或标量替换" class="headerlink" title="分离对象或标量替换"></a>分离对象或标量替换</h2><p>如果逃逸分析证明一个对象不会被外部访问。并且这个对象可以被拆散的话，那程序真正执行的时候可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来替换。</p><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>java7以后默认开启，关闭要指定：-XX:-DoEscapeAnalysis</p><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
          <category> 逃逸分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 逃逸分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql事务隔离和mvcc</title>
      <link href="/posts/1c92a0d/"/>
      <url>/posts/1c92a0d/</url>
      
        <content type="html"><![CDATA[<blockquote><p>风雨沉沉的夜里，前面一片荒郊<br>走尽荒郊，便是人们底道</p><p>呀？黑暗里歧路万千，叫我怎样走好？<br>“上帝！快给我些光明吧，让我好向前跑！”</p><p>上帝慌着说，“光明？我没处给你找”<br>“你要光明，你自己去造”<br>—— 朱自清《光明》</p></blockquote><p>回想30号写的总结，现在过去六天了，在这六天里，因为工作原因和个人特殊原因没能及时学习。但哪怕是及时学习了，我发现简单的几个知识点，看完需要花1个小时，总结却可能远远不止，因为正如我总结那篇所说，总结是需要结合自己的知识框架去思考，这个过程并非如我想象的简单，但不管如何，我会坚持下来，能日更就日更。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在文章开始前，想抛出一个结论，这个问题困扰了我一段时间：<code>mysql mvcc能不能解决幻读问题</code>，结论如下：</p><ol><li>在快照读读情况下，mysql通过mvcc来避免幻读。（快照读指的是简单的select语句）</li><li>在当前读读情况下，mysql通过next-key来避免幻读。（当前读指的是增删改的操作）</li></ol><h2 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h2><p>在读提交和可重复读两种事务隔离级别下，使用“当前读”的操作包括：<br>1、SELECT LOCK IN SHARE MODE（加锁语句）<br>2、SELECT FOR UPDATE（加锁语句）<br>3、DELETE\UPDATE\INSERT INTO\REPLACE INTO</p><p>当前读读到的是数据库最新的数据</p><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>学习事物隔离需要先理解什么是事务</p><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h3 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h3><p>事务的主要目的是让<code>数据库操作符合现实世界状态转换规则</code>，原意是交易，翻译成了事务。ACID是老生常谈的四大事务因素。</p><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>所有操作都是连续的，要么都成功，要么都不成功，譬如转账，不能有转到一半的情况</p><h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>数据库数据符合现实世界的约束，称为一致性。譬如转账，a给b转了10元，那在转账前a和b的金钱总额 = 转账后a和b的金钱总额</p><h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>数据库为每一个用户开一个事务，多个并发事务间需要相互隔离，主要为状态转换做隔离。譬如a给b转账10元，和，b给a转账5元，两个事务要隔离，不然最后的金额会出现问题。</p><h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>转换结果永久保留</p><h2 id="关于mysql对事务的支持"><a href="#关于mysql对事务的支持" class="headerlink" title="关于mysql对事务的支持"></a>关于mysql对事务的支持</h2><h3 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h3><ol><li><p>BEGIN</p><blockquote><p>mysql&gt; BEGIN;<br>mysql&gt; insert into t1 value(“v1”);<br>mysql&gt; ROOLBACK;/COMMIT;</p></blockquote></li><li><p>START TRANSACTION<br>不做详细介绍</p></li></ol><h3 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h3><p>默认情况下，mysql会自动提交事务，mysql有个系统变量<code>autocommit</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &apos;autocommit&apos;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | ON    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>该autocommit默认值为ON，一条语句相当于一个事务</p><h3 id="隐式提交"><a href="#隐式提交" class="headerlink" title="隐式提交"></a>隐式提交</h3><ol><li>使用DDL语言（create、alter、drop：可以理解为让表存在的语言）</li><li>隐式使用和修改mysql数据库表</li><li>事务控制和关于锁定语句</li><li>加载数据的语句</li><li>关于mysql复制语句</li></ol><h3 id="保存点"><a href="#保存点" class="headerlink" title="保存点"></a>保存点</h3><p>不细说：该作用在可以为每条操作做保存点，回滚可以回滚到指定保存点位置。</p><h2 id="事务并发可能遇到的问题"><a href="#事务并发可能遇到的问题" class="headerlink" title="事务并发可能遇到的问题"></a>事务并发可能遇到的问题</h2><h3 id="脏写"><a href="#脏写" class="headerlink" title="脏写"></a>脏写</h3><p>一个事务修改了另一个未提交事务修改过的数据</p><p>关键在：</p><ol><li>一个事务未提交</li><li>另一个事务读到中间状态，修改了中间状态值</li><li>因为未提交，所以修改的中间状态值后得出的结果是有问题的</li></ol><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>一个事务读到另一个未提交事务修改过的数据</p><p>关键在：</p><ol><li>一个事务未提交</li><li>另一个事务读到中间状态</li><li>因为未提交，所以读到的数据无法回溯</li></ol><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>一个事务无法重复读取到相同值，原因在别的事务修改的值影响到另一个事务读取值范围</p><p>关键在：</p><ol><li>一个事务不断修改数据，但都不是最终数据</li><li>另一个事务不断读到修改后的数据</li><li>这时导致中间读到的数据都不是最终结果</li></ol><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>一个事务相同条件下多次读取记录，读到了之前没有读到的记录</p><p>关键在：</p><ol><li>一个事务在修改数据</li><li>另一个事务相同条件下，读到了之前没有读到的记录（强调新增）</li><li>删除操作导致数据读不到，属于<code>不可重复读</code></li></ol><blockquote><p>以上的问题级别由大到小：脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p></blockquote><h2 id="隔离级别划分"><a href="#隔离级别划分" class="headerlink" title="隔离级别划分"></a>隔离级别划分</h2><blockquote><p>注：possible = 可能发生  |  Not possible = 不可能发生<br>因为脏写太严重，所以所有隔离级别都不允许</p></blockquote><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED（未提交读）</td><td>possible</td><td>possible</td><td>possible</td></tr><tr><td>READ COMMITTED（已提交读）</td><td>Not possible</td><td>possible</td><td>possible</td></tr><tr><td>REPEATABLE READ（可重复读）</td><td>Not possible</td><td>Not possible</td><td>possible</td></tr><tr><td>SERIALIZABLE（可串行化）</td><td>Not possible</td><td>Not possible</td><td>Not possible</td></tr></tbody></table><p>上面的是sql标准做的隔离级别，不同的数据库会有不同的实现，<code>mysql在REPEATABLE READ隔离级别下，已经可以做到禁止幻读的问题</code></p><h1 id="MVCC-原理"><a href="#MVCC-原理" class="headerlink" title="MVCC 原理"></a>MVCC 原理</h1><blockquote><p>注：MVCC原理主要用于mysql innodb引擎上，所以innodb的所有设计思想在这里充分体现</p></blockquote><h2 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h2><p>innodb存储的最小单位是页，页里面存储的是每条数据，innodb中存储数据的数据结构后面有机会我会讲到，目前我们先假设我们学习过相关知识。</p><p>在数据的数据结构中，聚簇索引有两个必要的隐藏列：</p><ol><li>trx_id：存储事务id，每次一个事务对数据进行改动时都会赋值</li><li>roll_pointer：指向undo日志的地址（undo日志的结构后面会总结，简单理解就是每次修改操作的记录）</li></ol><h3 id="insert-undo"><a href="#insert-undo" class="headerlink" title="insert undo"></a>insert undo</h3><p>指向insert undo（insert的操作）的链接会在提交事务时就没用了，日志文件会被系统回收，所以没有版本链</p><h3 id="update-undo"><a href="#update-undo" class="headerlink" title="update undo"></a>update undo</h3><p>每修改一条记录，都会有相应的undo日志，roll_pointer把这些undo日志链接成链表，这个链表就称为版本链。版本链的头结点就是当前记录当前的值，每个版本都有相应的事务id（即上文说的trx_id），该事务id是用来识别判断当前查询应该返回的数据。</p><h2 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h2><p>对于<code>ReadCommit</code>和<code>repeatableRead</code>的隔离级别来说，都必须保证读到的是已经提交的事务，所以如果未提交的事务，这两个级别是不允许访问的。为了做到这点，mysql里面用<code>ReadView</code>结合<code>版本链</code>来实现这个功能。核心功能在：<code>判断版本链中的哪个版本是当前事务可见的</code></p><p>关于ReadView有四个概念需要先理解：</p><ol><li>m_ids:在生成ReadView时，数据库活跃的事务id列表</li><li>min_trx_id:活跃事务id的最小值，即m_ids列表中的最小值</li><li>max_trx_id:生成ReadView时，系统分配的下一个事务id（不是最大事务id）</li><li>creator_trx_id:生成ReadView事务的事务id</li></ol><p>有了ReadView，应该访问哪个版本的数据会经过下面步骤：<br>（总步骤：会遍历<code>版本链</code>中每个版本的trx_id和当前ReadView的属性值做比较）</p><ol><li>trx_id的值与creator_trx_id值<code>相等</code>，说明是访问自己事务的数据</li><li>trx_id的值<code>小于</code>min_trx_id值，说明这个版本的事务已经提交，可以被当前事务访问</li><li>trx_id的值<code>大于</code>max_trx_id值，说明该版本在ReadView生成后才生成，不可以被当前事务访问</li><li>trx_id的值在min_trx_id和max_trx_id<code>之间</code>，首先判断是否在m_ids里面，如果在，说明该版本是属于当前活跃版本，不可以访问。如果不在，说明该版本的事务已提交，可以访问数据</li></ol><h2 id="read-commit的ReadView"><a href="#read-commit的ReadView" class="headerlink" title="read commit的ReadView"></a>read commit的ReadView</h2><p>read commit的隔离级别是：不会出现脏读，而脏读产生的原因是因为：<code>一个事务读到另一个事务没有提交的数据</code>，所以解决这个问题的方案就是：进行每次查询操作的时候，都产生一个ReadView</p><h2 id="repeatable-Read的ReadView"><a href="#repeatable-Read的ReadView" class="headerlink" title="repeatable Read的ReadView"></a>repeatable Read的ReadView</h2><p>repeatable Read的隔离级别是：可以重复读和避免了幻读，而产生不可重复读的原因是：<code>一个事务读到另一个事务一直修改的数据</code>，产生幻读的原因是：<code>一个事务读到另一个事务添加的数据</code>，所以解决这个问题的方案是：进行第一次查询操作的时候，产生一个ReadView，后面每次查询都用这个ReadView判断可读版本</p><blockquote><p>上面两个概念我没有讲的很仔细，因为我主要做复习的笔记记录，如果没有基础可能需要先深入学习相关概念，看以后如果有时间我会添加图文再做详细解释</p></blockquote><h2 id="关于purge"><a href="#关于purge" class="headerlink" title="关于purge"></a>关于purge</h2><p>为了MVCC，update undo和delete操作（会做delete mark）的数据会保留一段时间。随着系统的运行，在确定系统中包含最早产生的那个ReadView的事务不会再访问某些update undo日志以及被打了删除标记的记录后，有一个后台运行的purge线程会把它们真正的删除掉。</p><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> mysql知识 </category>
          
          <category> mvcc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> mvcc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql explain简介</title>
      <link href="/posts/9aa2b4bd/"/>
      <url>/posts/9aa2b4bd/</url>
      
        <content type="html"><![CDATA[<blockquote><p>那时的我们<br>关于文学<br>关于爱情<br>关于穿越世界的旅行</p><p>如今我们深夜饮酒<br>杯子碰到一起<br>都是梦破碎的声音</p><p>—— 北岛《波兰来客》</p></blockquote><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>explain用于mysql的调优是有好处的，所以本篇做简单参数介绍和使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT 1;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><p>如上面例子，在mysql客户端的查询语句前加explain可以查看执行计划，每一列都有其含义，我接下来做简单句记录。</p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在一个大查询里，每个select关键字对应一个唯一id，但有些子查询会被优化成连接查询，而连接查询会共用一个id，所以不能仅仅判断查询语句select的个数来判断id数。</td></tr><tr><td>select_type</td><td>select关键字对应的查询类型，有专门分类，后面会讲</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区信息</td></tr><tr><td>type</td><td>针对单表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际上用到的索引</td></tr><tr><td>key_len</td><td>实际使用的索引长度</td></tr><tr><td>ref</td><td>索引用等值查询时，与索引等值匹配的对象信息</td></tr><tr><td>rows</td><td>预估需要读的记录数</td></tr><tr><td>filtered</td><td>经过搜索条件过滤后剩余记录的百分比</td></tr><tr><td>Extra</td><td>额外信息，官网有很多，这里介绍几种重要的</td></tr></tbody></table><h1 id="id"><a href="#id" class="headerlink" title="id"></a>id</h1><p>关于id主要有三种情况</p><ol><li>简单一个select<blockquote><p>select * from t1;</p></blockquote></li><li>子查询<blockquote><p>select * from t1 where c1 in (select c2 from t2);</p></blockquote></li><li>union<blockquote><p>select * from t1 union select * from t2</p></blockquote></li></ol><h2 id="简单一个select"><a href="#简单一个select" class="headerlink" title="简单一个select"></a>简单一个select</h2><p>第一种情况，只会有一个id</p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询本身有几种：</p><ol><li>where子查询：需要看优化器是否会优化</li><li>from子查询：子查询会变成一张临时表，最终也只会有一个id</li><li>exists子查询：会有两个id，看下图<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t_sqoop_web where exists (select * from t_sqoop_web);    </span><br><span class="line">+----+-------------+-------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table       | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | t_sqoop_web | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |   19 |   100.00 | NULL        |</span><br><span class="line">|  2 | SUBQUERY    | t_sqoop_web | NULL       | index | NULL          | PRIMARY | 1534    | NULL |   19 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure></li></ol><p>where子查询需要分两种情况：</p><h3 id="优化器不优化成连接查询"><a href="#优化器不优化成连接查询" class="headerlink" title="优化器不优化成连接查询"></a>优化器不优化成连接查询</h3><p>这种情况，会出现两个id：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &apos;a&apos;;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 9688 |   100.00 | Using where |</span><br><span class="line">|  2 | SUBQUERY    | s2    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9954 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">2 rows in set, 1 warning (0.02 sec)</span><br></pre></td></tr></table></figure><h3 id="优化器优化成连接查询"><a href="#优化器优化成连接查询" class="headerlink" title="优化器优化成连接查询"></a>优化器优化成连接查询</h3><p>这种情况，只会出现一个id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2 WHERE common_field = &apos;a&apos;);</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra                        |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ALL  | idx_key3      | NULL     | NULL    | NULL              | 9954 |    10.00 | Using where; Start temporary |</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s2.key3 |    1 |   100.00 | End temporary                |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="union语句"><a href="#union语句" class="headerlink" title="union语句"></a>union语句</h2><p>union情况需要解释一番，看下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t_sqoop_web union select * from t_sqoop_web_test; </span><br><span class="line">+----+--------------+------------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">| id | select_type  | table            | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |</span><br><span class="line">+----+--------------+------------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">|  1 | PRIMARY      | t_sqoop_web      | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   19 |   100.00 | NULL            |</span><br><span class="line">|  2 | UNION        | t_sqoop_web_test | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    6 |   100.00 | NULL            |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt;       | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |</span><br><span class="line">+----+--------------+------------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">3 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure><p>我们看到除了1，2两个id，还出现了null的情况，这是因为union会涉及去重，而<code>在mysql中的去重会生成临时表用来去重</code>，所以null id的那一行会生一个名为&lt;union1,2&gt;的临时表</p><h1 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h1><p>每个select查询都会对应有这个select的类型，在explain中就用select_type做展示，主要的select_type有：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>SIMPLE</td><td>不包含子查询和union的查询</td></tr><tr><td>PRIMARY</td><td>包含union、unionAll、子查询的最左边查询的select_type为PRIMARY</td></tr><tr><td>UNION</td><td>包含union、unionAll，且除了PRIMARY外的其他类型</td></tr><tr><td>UNION RESULT</td><td>Result of a UNION</td></tr><tr><td>SUBQUERY</td><td>First SELECT in subquery</td></tr><tr><td>DEPENDENT SUBQUERY</td><td>First SELECT in subquery, dependent on outer query</td></tr><tr><td>DEPENDENT UNION</td><td>Second or later SELECT statement in a UNION, dependent on outer query</td></tr><tr><td>DERIVED</td><td>Derived table</td></tr><tr><td>MATERIALIZED</td><td>Materialized subquery</td></tr><tr><td>UNCACHEABLE SUBQUERY</td><td>A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td></tr><tr><td>UNCACHEABLE UNION</td><td>The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td></tr></tbody></table><h2 id="SIMPLE"><a href="#SIMPLE" class="headerlink" title="SIMPLE"></a>SIMPLE</h2><p>只要不包含子查询和union的查询都算是SIMPLE类型，这种类型是最简单的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t_sqoop_web;</span><br><span class="line">+----+-------------+-------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table       | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t_sqoop_web | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   19 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><blockquote><p>连接查询也是属于SIMPLE类型</p></blockquote><h2 id="PRIMARY"><a href="#PRIMARY" class="headerlink" title="PRIMARY"></a>PRIMARY</h2><p>由几个小查询组成的查询语句，最左边的查询select_type就是PRIMARY：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t_sqoop_web union select * from t_sqoop_web_test; </span><br><span class="line">+----+--------------+------------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">| id | select_type  | table            | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |</span><br><span class="line">+----+--------------+------------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">|  1 | PRIMARY      | t_sqoop_web      | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   19 |   100.00 | NULL            |</span><br><span class="line">|  2 | UNION        | t_sqoop_web_test | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    6 |   100.00 | NULL            |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt;       | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |</span><br><span class="line">+----+--------------+------------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">3 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure><h2 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h2><p>包含union和unionAll的除了最左边为PRIMARY外，其他的为UNION，可以看上图</p><h2 id="UNION-RESULT"><a href="#UNION-RESULT" class="headerlink" title="UNION RESULT"></a>UNION RESULT</h2><p>用于union的临时表去重，上表 id为NULL的那行就是</p><h2 id="SUBQUERY"><a href="#SUBQUERY" class="headerlink" title="SUBQUERY"></a>SUBQUERY</h2><p>如果子查询满足以下两种情况：</p><ol><li>不能优化成join语句</li><li>不是相关子查询，并且子查询被物化</li></ol><p>那么子查询的第一个select 就是SUBQUERY：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &apos;a&apos;;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 9688 |   100.00 | Using where |</span><br><span class="line">|  2 | SUBQUERY    | s2    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9954 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">2 rows in set, 1 warning (0.02 sec)</span><br></pre></td></tr></table></figure><p>上面条件说到会被物化，所以子查询只出现只执行一次</p><p>什么是相关子查询和不相关子查询：</p><blockquote><p>相关子查询：子查询需要依赖外查询进行查询——如果子查询where语句用到外查询的字段，则可以认为是相关子查询<br>不相关子查询：子查询不需要依赖外查询进行查询——如果子查询是一个单独的查询语句，不依赖任何外部表的字段，则可以认为是不相关子查询</p></blockquote><h2 id="DEPENDENT-SUBQUERY"><a href="#DEPENDENT-SUBQUERY" class="headerlink" title="DEPENDENT SUBQUERY"></a>DEPENDENT SUBQUERY</h2><p>如果满足以下两个情况：</p><ol><li>不能优化成join语句</li><li>子查询是相关子查询</li></ol><p>则子查询的第一个select关键字为 DEPENDENT SUBQUERY：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t_sqoop_web where mysql_db_tb in (select mysql_db_tb from t_sqoop_web_test where t_sqoop_web.hive_db = t_sqoop_web_test.hive_db) or sqoop_type = &apos;&apos;;</span><br><span class="line">+----+--------------------+------------------+------------+----------------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type        | table            | partitions | type           | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+--------------------+------------------+------------+----------------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY            | t_sqoop_web      | NULL       | ALL            | NULL          | NULL    | NULL    | NULL |   19 |   100.00 | Using where |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | t_sqoop_web_test | NULL       | index_subquery | PRIMARY       | PRIMARY | 767     | func |    1 |    16.67 | Using where |</span><br><span class="line">+----+--------------------+------------------+------------+----------------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">2 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure><h2 id="DEPENDENT-UNION"><a href="#DEPENDENT-UNION" class="headerlink" title="DEPENDENT UNION"></a>DEPENDENT UNION</h2><p>满足以下条件:</p><ol><li>UNION和UNION ALL的子查询</li><li>每个子查询都是相关子查询</li></ol><p>则除了最左边为DEPENDENT SUBQUERY外，其他的都为DEPENDENT UNION：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = &apos;a&apos; UNION SELECT key1 FROM s1 WHERE key1 = &apos;b&apos;);</span><br><span class="line">+----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br><span class="line">| id | select_type        | table      | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra                    |</span><br><span class="line">+----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br><span class="line">|  1 | PRIMARY            | s1         | NULL       | ALL  | NULL          | NULL     | NULL    | NULL  | 9688 |   100.00 | Using where              |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | s2         | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |   12 |   100.00 | Using where; Using index |</span><br><span class="line">|  3 | DEPENDENT UNION    | s1         | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | Using where; Using index |</span><br><span class="line">| NULL | UNION RESULT       | &lt;union2,3&gt; | NULL       | ALL  | NULL          | NULL     | NULL    | NULL  | NULL |     NULL | Using temporary          |</span><br><span class="line">+----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br><span class="line">4 rows in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure><h2 id="DERIVED"><a href="#DERIVED" class="headerlink" title="DERIVED"></a>DERIVED</h2><p>对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的select_type就是DERIVED</p><h2 id="MATERIALIZED"><a href="#MATERIALIZED" class="headerlink" title="MATERIALIZED"></a>MATERIALIZED</h2><p>当查询优化器在执行包含子查询的语句时，选择将<code>子查询物化之后与外层查询进行连接查询</code>时，该子查询对应的select_type属性就是MATERIALIZED：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2);</span><br><span class="line">+----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+</span><br><span class="line">| id | select_type  | table       | partitions | type   | possible_keys | key        | key_len | ref               | rows | filtered | Extra       |</span><br><span class="line">+----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE       | s1          | NULL       | ALL    | idx_key1      | NULL       | NULL    | NULL              | 9688 |   100.00 | Using where |</span><br><span class="line">|  1 | SIMPLE       | &lt;subquery2&gt; | NULL       | eq_ref | &lt;auto_key&gt;    | &lt;auto_key&gt; | 303     | xiaohaizi.s1.key1 |    1 |   100.00 | NULL        |</span><br><span class="line">|  2 | MATERIALIZED | s2          | NULL       | index  | idx_key1      | idx_key1   | 303     | NULL              | 9954 |   100.00 | Using index |</span><br><span class="line">+----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+</span><br><span class="line">3 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><h1 id="table"><a href="#table" class="headerlink" title="table"></a>table</h1><p>表示使用到的表名</p><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>type代表访问的方式，主要有以下类型：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>system</td><td></td></tr><tr><td>const</td><td></td></tr><tr><td>eq_ref</td><td></td></tr><tr><td>ref</td><td></td></tr><tr><td>fulltext</td><td></td></tr><tr><td>ref_or_null</td><td></td></tr><tr><td>index_merge</td><td></td></tr><tr><td>unique_subquery</td><td></td></tr><tr><td>index_subquery</td><td></td></tr><tr><td>range</td><td></td></tr><tr><td>index</td><td></td></tr><tr><td>ALL</td><td></td></tr></tbody></table><p>效率的快慢排序：<br>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p>满足条件：</p><ol><li>表中只有一条记录</li><li>存储引擎统计数据是精确的，如myisam（注：innodb不是精确统计）</li></ol><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>满足条件：</p><ol><li>根据主键或者唯一二级索引列与常数进行等值匹配</li></ol><h3 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h3><p>满足条件：</p><ol><li>连接查询</li><li>被驱动表通过主键或者唯一二级索引列进行等值匹配的，被驱动表会显示eq_ref</li></ol><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>满足条件：</p><ol><li>普通二级索引列与常量等值匹配查询</li></ol><h3 id="fulltext"><a href="#fulltext" class="headerlink" title="fulltext"></a>fulltext</h3><p>满足条件：</p><ol><li>用导全文索引列进行查询</li></ol><h3 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h3><p>满足条件：</p><ol><li>二级索引等值匹配</li><li>该列值可以为null</li></ol><h3 id="index-merge"><a href="#index-merge" class="headerlink" title="index_merge"></a>index_merge</h3><p>满足条件：</p><ol><li>索引为单独索引</li><li>多个索引列进行查询</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; explain select * from t_articles_info_0 where u_tags = &apos;&apos; or oid = &apos;&apos;;  </span><br><span class="line">+----+-------------+-------------------+------------+-------------+--------------------+--------------------+---------+------+--------+----------+----------------------------------------------+</span><br><span class="line">| id | select_type | table             | partitions | type        | possible_keys      | key                | key_len | ref  | rows   | filtered | Extra                                        |</span><br><span class="line">+----+-------------+-------------------+------------+-------------+--------------------+--------------------+---------+------+--------+----------+----------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t_articles_info_0 | NULL       | index_merge | idx_oid,idx_u_tags | idx_u_tags,idx_oid | 1,98    | NULL | 101073 |   100.00 | Using union(idx_u_tags,idx_oid); Using where |</span><br><span class="line">+----+-------------+-------------------+------------+-------------+--------------------+--------------------+---------+------+--------+----------+----------------------------------------------+</span><br><span class="line">1 row in set (0.03 sec)</span><br></pre></td></tr></table></figure><p>u_tags 和 oid 是单独的索引列</p><h3 id="unique-subquery"><a href="#unique-subquery" class="headerlink" title="unique_subquery"></a>unique_subquery</h3><p>满足条件：</p><ol><li>包含in子查询</li><li>in子查询转换为EXISTS子查询</li><li>子查询返回的是主键</li></ol><h3 id="index-subquery"><a href="#index-subquery" class="headerlink" title="index_subquery"></a>index_subquery</h3><p>满足条件：</p><ol><li>包含in子查询</li><li>in子查询转换为EXISTS子查询</li><li>子查询返回的是普通索引</li></ol><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>满足条件：</p><ol><li>使用索引获取范围区间：</li></ol><blockquote><p>EXPLAIN SELECT * FROM s1 WHERE key1 IN (‘a’, ‘b’, ‘c’);<br>EXPLAIN SELECT * FROM s1 WHERE key1 &gt; ‘a’ AND key1 &lt; ‘b’;</p></blockquote><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>满足条件：</p><ol><li>表中有联合索引</li><li>条件语句和筛选语句都是联合索引中的列：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = &apos;a&apos;;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                    |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | index | NULL          | idx_key_part | 909     | NULL | 9688 |    10.00 | Using where; Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>key_part2和key_part3是联合索引，where语句用到key_part3，select语句用到key_part2</p><h3 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h3><p>满足条件：</p><ol><li>全表扫描</li></ol><h2 id="possible-keys和key"><a href="#possible-keys和key" class="headerlink" title="possible_keys和key"></a>possible_keys和key</h2><p>possible_keys：可能用到的索引<br>key：实际用到的索引</p><p>possible_key越多，查询优化器计算查询成本花费时间越多，所以尽可能删除无用索引</p><h2 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h2><p>用到的索引的最大长度，这个计算涉及到页的概念，所以暂时不分析</p><h2 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h2><p>指的是当索引列进行等值查询时，和索引列进行等值查询的是个啥玩意：<br>即type类型为：const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery时，对应的索引列和什么玩意进行匹配</p><p>主要有几种情况：</p><ol><li><p>和常量进行匹配的，ref会显示const</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &apos;a&apos;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure></li><li><p>连接查询用主键进行等值匹配的，ref显示的是s1表的id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref             | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL            | 9688 |   100.00 | NULL  |</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | xiaohaizi.s1.id |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>用函数对列进行处理后做等值查询的，ref显示的是func<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s2.key1 = UPPER(s1.key1);</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL     | NULL    | NULL | 9688 |   100.00 | NULL                  |</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | func |    1 |   100.00 | Using index condition |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>预计要扫描的行数</p><h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>估计出需要访问的行数的百分比，最后所扫描的行数为 <code>row*filtered</code></p><h2 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h2><p>主要介绍几个常见Extra</p><h3 id="No-tables-used"><a href="#No-tables-used" class="headerlink" title="No tables used"></a>No tables used</h3><p>查询语句没有from子句时</p><h3 id="Impossible-WHERE"><a href="#Impossible-WHERE" class="headerlink" title="Impossible WHERE"></a>Impossible WHERE</h3><p>查询语句的where子句永远为FALSE时</p><h3 id="No-matching-min-max-row"><a href="#No-matching-min-max-row" class="headerlink" title="No matching min/max row"></a>No matching min/max row</h3><p>查询语句中有max和min聚集函数，但没有符合where子句搜索条件记录时</p><h3 id="Using-index"><a href="#Using-index" class="headerlink" title="Using index"></a>Using index</h3><p>当使用索引覆盖的情况加，会显示</p><h3 id="Using-index-condition"><a href="#Using-index-condition" class="headerlink" title="Using index condition"></a>Using index condition</h3><p>搜索条件出现索引，但不能使用索引时，如：</p><blockquote><p>select * from t1 where key1 &gt; ‘z’ and key1 like ‘%x’;</p></blockquote><h3 id="Using-where"><a href="#Using-where" class="headerlink" title="Using where"></a>Using where</h3><p>全表扫描 + 使用where子句有针对该表的搜索条件，会出现</p><h3 id="Using-join-buffer-（Block-Nested-Loop）"><a href="#Using-join-buffer-（Block-Nested-Loop）" class="headerlink" title="Using join buffer （Block Nested Loop）"></a>Using join buffer （Block Nested Loop）</h3><p>连接查询中，如果驱动表无法用索引加快访问，mysql会分配join buffer的内存加快查询速度</p><h3 id="Not-exists"><a href="#Not-exists" class="headerlink" title="Not exists"></a>Not exists</h3><p>连接查询中，驱动表中有 = null语句，但该列不允许为null时</p><h3 id="Zero-limit"><a href="#Zero-limit" class="headerlink" title="Zero limit"></a>Zero limit</h3><p>limit 0时</p><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> mysql知识 </category>
          
          <category> explain简介 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> explain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人学习阶段总结及博客未来计划</title>
      <link href="/posts/c2af516c/"/>
      <url>/posts/c2af516c/</url>
      
        <content type="html"><![CDATA[<p>近一个月，我坚持每天早上7点左右起床，并通过看各专栏和书籍学习技术，晚上如果不用加班，我也会去学习算法或者一些新技术的基本概念。如今月底了，回顾这一个月，我发现自己的技术能力确实有些许提高，整体而言，整个过程与我的预期虽然还有差距，但自己的坚持和努力还是有明显成效，这个值得肯定。</p><p>然而，抛开自己与女友去玩耍约会的时间，抛开因为工作原因必须加班坚守阵地的时间，我在学习上的时间其实并不算少，但我却感觉到自己并没有真正吸收全部知识。</p><p>当然，如果吸收全部知识这个前提本身是无法完成的，那我不会纠结，而我纠结就在于这个前提可实现，实现的方法论有很多，并且我在整个学习过程中也进行了不少总结，所以基于这个点，我要把自己的方法论结合自身情况，做一个简单的规划和总结。</p><h2 id="学习感悟"><a href="#学习感悟" class="headerlink" title="学习感悟"></a>学习感悟</h2><p>首先我要先做一个深刻的反省，吾日三省吾身，好的总结习惯，会让我们明白自身问题，并做到真正意义上的进步，而不是停留在意淫阶段。</p><p>在整个学习的阶段，我曾迷茫和焦虑过，迷茫于这么多知识我该从哪入手，焦虑于工作没有完成我该如何有效规划时间，去学习新知识，巩固旧概念。所以有段时间，我陷入了一学习就焦虑的状况，为啥呀？因为感觉学着碗里的，盼着锅里的，想着看看mysql底层实现，又觉得spark源码还有那么多没读过，另一边工作上flink又是刚接触，心底没有一个整体概念，怎么也得先深入学习下flink吧。如此这般循环，最后沦入深深无力感中，啥也没干好，时间却呼啦啦消逝。</p><p>这是一个大问题。</p><p>另外一边，学习成效上，我没有认真去执行高效学习的理论。何为高效学习的理论？就个人阅读的书籍总结而言，就是围绕<code>记忆和学习方法</code>做的一些优化手段。这些手段在普通人眼里是耗费时间的，于是没有去执行和遵守，最后却发现自己现在的行为才是冤大头。譬如我，我知道艾宾浩斯遗忘曲线，我知道总结并不等于了解，所以正确的学习姿势应该是：</p><blockquote><p>把每天学习的知识总结，并根据遗忘曲线的遗忘效率进行及时有效的复习，直到知识点巩固，最后再做命题测验，深入了解知识点内部原理。  </p></blockquote><p>而我呢，没有这么做，因为我在想，总结和复习是耗费时间的，我要做的应该是不断学习新知识，或者想着在一段时间的专题学习后，再回顾总结。然而，现实总比预期残酷，命运的捉弄不在乎who are u，绝大部分人的记忆都离不开遗忘曲线的作用范围，所以不及时复习的学习，只会花费更多时间才能巩固和记忆。</p><h2 id="个人问题解决方案"><a href="#个人问题解决方案" class="headerlink" title="个人问题解决方案"></a>个人问题解决方案</h2><p>发现了问题，那就得解决问题。</p><h3 id="学习焦虑解决方案"><a href="#学习焦虑解决方案" class="headerlink" title="学习焦虑解决方案"></a>学习焦虑解决方案</h3><p>焦虑的产生核心点在<code>不可掌握</code>，不可掌握又分为两点，其一为要做的事情太多，其二为没有事情可做。事情太多则头绪混乱，不知所措。无事可做则担心淘汰，无法生存。而不可掌握的感知，就在注意力。如果把注意力集中在做，而不是需要做的，那焦虑就会不攻而破。</p><p>所以解决方案很简单，两个问题两个解决的点</p><h4 id="解决一：攻破精神陷阱"><a href="#解决一：攻破精神陷阱" class="headerlink" title="解决一：攻破精神陷阱"></a>解决一：攻破精神陷阱</h4><p>我们要明白焦虑是精神陷阱，是人给自己带来的精神压力，最近明星自杀和明星猝死的新闻越发增多，这让我明白，学习与进步是必须要做的，但不能牺牲健康，精神压力过大，也是不健康的表现。</p><p>顶着巨大精神压力去生活，去工作，去进步，它的效率是<code>事倍功半</code>的，那是自我安慰的努力，毫成效可言。此时如果放下执念，放平心态，做一个简单的休息，整装待续，精神焕发，来个深呼吸，感受生命气息，再重新起步，才会明白努力的意义。</p><p>在这个方案中，我想特别提一个前提，那就是：<code>精神的丰富是必要的</code>。举个例子，我叫你休息，你去刷抖音，这在你眼里是休息，但却是另一种注意力耗散，会让你更加疲惫。那你问我，你该如何休息，我说，我不知道，只有你知道，然后你说，你知道的就是刷抖音，但其实<code>这里所说的你，是经过丰富阅读，丰富人生经历，丰富思考造就的你</code>，相比幼稚的你，这时的你是智慧的，了解自己，了解世界，了解心与灵魂的需求。相信我，这时的你不会把刷抖音当作休息的唯一途径。</p><p>所以一个人在<code>他的精神生活是丰富的前提下</code>，他才会真正明白自己所想要的，也才会明白什么是休息，什么是人生，什么是当下最重要的事情。</p><p>于是，我提倡，不要因为工作泯灭人性，不要因为学习忘记天的蓝，不要因为害怕躲避生命的风险。</p><h4 id="解决二：把注意力放到执行上"><a href="#解决二：把注意力放到执行上" class="headerlink" title="解决二：把注意力放到执行上"></a>解决二：把注意力放到执行上</h4><p>如果要把注意力放执行上，必须有个前提 —— 我知道该做什么。</p><p>所以关于这个的解决方案，我给自己设立了四象限的学习维度。分别是：</p><ol><li>简单的</li><li>复杂的</li><li>重要的</li><li>紧急的</li></ol><p>优先级应该是这样：<br>紧急 &gt; 简单 &gt;= 重要 &gt;= 复杂</p><p>然后把当前的事情归类，做一个学习规划。在规划的过程中，必须要认真谨慎，考虑各种不同因素和情况。做好规划后，坚定执行，不考虑规划外的事情，只考虑怎么把当前事情做好，如此这般，注意力集中就会少焦虑的产生。</p><h3 id="学习理论的实践方案"><a href="#学习理论的实践方案" class="headerlink" title="学习理论的实践方案"></a>学习理论的实践方案</h3><p>学习理论的实践，我推荐李笑来的《把时间当做朋友》和采铜的《精进》和《刻意练习》，这三本书有学习的理论，我这就不展开谈。</p><p>学习本身就是记忆和加工的过程，而记忆如果没东西，那加工啥玩意。所以记忆很重要，加工也很重要。所以关于学习理论的实践，主要有两个点需要攻破。</p><h4 id="解决一：遗忘曲线"><a href="#解决一：遗忘曲线" class="headerlink" title="解决一：遗忘曲线"></a>解决一：遗忘曲线</h4><p>遗忘曲线的核心在不同的遗忘点，进行不同程度的复习。关于复习，必须精简。我们在最初的学习阶段，会涉及很多概念去堆砌出最后的结论，而我们的复习阶段则是记忆结论。为何？因为时间有限。所以想要复习，离不开<code>总结</code>，而总结有讲究，个人认为有几个点：</p><ol><li>总结不是复制粘贴，而要把新知识和知识框架进行融合后输出</li><li>总结需要归纳，归纳需要层级，总结结论如何生成，要有简单过程</li><li>总结需要有：<blockquote><p>知识本身 + 给知识分维度（如简单、未理解、易错等） + 实践和展望（融合自身情况）</p></blockquote></li></ol><h4 id="解决二：加工方案"><a href="#解决二：加工方案" class="headerlink" title="解决二：加工方案"></a>解决二：加工方案</h4><p>当脑子有很多材料时，我们该如何进行加工，就会决定我们最后加工的效率和东西的质地。</p><h5 id="知识体系构建"><a href="#知识体系构建" class="headerlink" title="知识体系构建"></a>知识体系构建</h5><p>加工的过程离不开知识体系的构建，这个知识体系不是指专业的知识体系，而是上文所讲的，<code>体验</code>所产生的知识体系，这个知识体系会包含各个学科的知识，并且夹杂自身独特的人生经历和思考。丰富的知识体系会给大脑提供源源不断的灵感，所以专业并非好，而我们所说专业好，这不过是因为在人有限精力和注意力下的最好解决方案。</p><p>但知识体系这玩意不是短时间能搞定的，这个需要时间的积累，需要注意力的堆砌，当我们清楚，我们所作的每一次学习都会为日后提供构建知识体系的原材料时，我们每做的一件事都会谨慎和深邃许多。</p><h5 id="一段时间只做一件事情"><a href="#一段时间只做一件事情" class="headerlink" title="一段时间只做一件事情"></a>一段时间只做一件事情</h5><p>在上文的学习规划中，我没有提到一个很重要的点，叫做<code>一段时间只做一件事情</code>。这是我结合刻意练习和自身出现问题所做的总结。</p><p>前段时间我经历了一个星期做几个知识点学习的规划，但整体下来，我好像都没做好，并且产生焦虑。后来我放下追求完美的念头后，我根据优先级排序，规定了一段时间只做一件事情，我发现焦虑消失了，并且学习更加深入。</p><p>在学习领域，有两个区域需要注意，一个叫展示区，一个叫学习区。展示区是你利用现有知识去解决问题的阶段，而学习区，则是刻意练习中说到的有目的性学习。在刻意练习中讲到的<code>有目的性去学习</code>意思是，带着问题，带着规划去学习。这个过程，我们发现，有目的性学习就会有反馈，有反馈就会有成功与失败，有失败就能总结然后进步。这明显是个正向循环。</p><p>有目的性学习和一段时间只做一件事情的好处很明显，因为它们能让你深入理解一个知识点。在你规划一段时间有目的性学习的时候，一定要找到每个知识点的核心内容，譬如：明白spark的运行原理，如果要你设计，或者遇到类似知识点问题，你就能很快速解决。</p><h2 id="博客规划"><a href="#博客规划" class="headerlink" title="博客规划"></a>博客规划</h2><p>综上所述，我分析了自身问题，并提供解决方案，最后我想利用博客做一个简单规划和实践。每天我会把自己的技术学习进行总结汇报，记录到博客。但这个过程中，总会出现电脑不在身边或者今天因为某些原因没有学习的情况，如果是因为没有学习当天则不做记录，如果因为电脑不在，我会找时间上传到博客。</p><p>总结规划：</p><ol><li>写每日博客</li><li>阶段性学习后，做整体学习总结</li><li>每天写博客前复习上一篇和上上篇博客内容</li></ol><p>以上，愿自己坚持到完成个人目标</p><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
          <category> 阶段总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习总结 </tag>
            
            <tag> 个人总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm知识汇总</title>
      <link href="/posts/de2d575e/"/>
      <url>/posts/de2d575e/</url>
      
        <content type="html"><![CDATA[<p>这个栏目主要是把各jvm的知识模块进行链接汇总，方便自己的学习与复习</p><h1 id="jvm的内存结构"><a href="#jvm的内存结构" class="headerlink" title="jvm的内存结构"></a>jvm的内存结构</h1><h1 id="jvm的oom汇总"><a href="#jvm的oom汇总" class="headerlink" title="jvm的oom汇总"></a>jvm的oom汇总</h1><h1 id="jvm的jmm是什么"><a href="#jvm的jmm是什么" class="headerlink" title="jvm的jmm是什么"></a>jvm的jmm是什么</h1><h1 id="jvm的类加载过程"><a href="#jvm的类加载过程" class="headerlink" title="jvm的类加载过程"></a>jvm的类加载过程</h1><ol><li><a href="https://www.jianshu.com/p/202f6abb229c" target="_blank" rel="noopener">java类加载过程</a></li></ol><h1 id="双亲委派机制怎么理解"><a href="#双亲委派机制怎么理解" class="headerlink" title="双亲委派机制怎么理解"></a>双亲委派机制怎么理解</h1><h1 id="类加载器的实现原理"><a href="#类加载器的实现原理" class="headerlink" title="类加载器的实现原理"></a>类加载器的实现原理</h1><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
          <category> 汇总 </category>
          
          <category> hide </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表的算法题</title>
      <link href="/posts/63112dd/"/>
      <url>/posts/63112dd/</url>
      
        <content type="html"><![CDATA[<p>记得以前刚开始学习链表，对指针和方向的定义和判断难以理解，如今经过学习再回顾，慢慢知晓学习的本质就是反人性的重复，当达到一定的重复，所有的难理解不过是茶余饭后对过去愚笨自己的无奈。</p><p>针对链表，列出几个常面试的题目，便于后续自己的复习，持续更新。</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表统一代码实现"><a href="#链表统一代码实现" class="headerlink" title="链表统一代码实现"></a>链表统一代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表的定义可以自行百度了解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Node node_v1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        Node node_v2 = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        Node node_v3 = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        Node node_v4 = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        Node node_v5 = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        node_v1.next = node_v2;</span><br><span class="line">        node_v2.next = node_v3;</span><br><span class="line">        node_v3.next = node_v4;</span><br><span class="line">        node_v4.next = node_v5;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入一个单链表，输出该链表的反转链表</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个题目不难，链表是有指针的，把指针倒转过来就是反向链表。<br>如 1 -&gt; 2 -&gt; 3 -&gt; 4 的反向链表就是：<br>4 -&gt; 3 -&gt; 2 -&gt; 1</p><blockquote><p>核心点在：node.next = pre</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linked_Revered</span></span>&#123;</span><br><span class="line">    <span class="comment">// 非递归方案</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revered</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node pre = <span class="keyword">null</span>;</span><br><span class="line">        Node next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            next = node.next;</span><br><span class="line">            node.next = pre;</span><br><span class="line">            pre = node;</span><br><span class="line">            node = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归方案</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revered_digui</span><span class="params">(Node node,Node pre)</span></span>&#123;</span><br><span class="line">        Node next = node.next;</span><br><span class="line">        node.next = pre; <span class="comment">// 核心点，只要根据这个推导即可明白</span></span><br><span class="line">        revered_digui(next,node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revered_digui_v1</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span> || node.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为了递归到最后一个链表结点，用于后面反转</span></span><br><span class="line">        Node nextNode = revered_digui_v1(node.next);</span><br><span class="line">        <span class="comment">// 反转链表</span></span><br><span class="line">        node.next.next = node;</span><br><span class="line">        <span class="comment">// 把当前链表进行切断</span></span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求有环链表的入口结点"><a href="#求有环链表的入口结点" class="headerlink" title="求有环链表的入口结点"></a>求有环链表的入口结点</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>输入一个单链表，求他的环的入口结点</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>输入一个单链表，求环的入口，我们首先需要明确该链表是否有环，有环又该如何求入口结点，所以主要解决三个问题即可：</p><blockquote><ol><li>判断单链表是否有环</li><li>判断环的长度是多少，长度可用于协助计算入口结点</li><li>定位环的入口结点位置</li></ol></blockquote><p>话不多说，看代码马上明白每步的作用</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linked_Round</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">Detect_Round</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node fast = node;</span><br><span class="line">        Node slow = node;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个同时从头结点出发，一个一下走两步，一个走一步</span></span><br><span class="line"><span class="comment">        有两种情况：</span></span><br><span class="line"><span class="comment">        1、当 next 出现null的情况，说明没有环</span></span><br><span class="line"><span class="comment">        2、当 fast 和 slow 相遇了，说明有环</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">while</span>(slow.next != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算环的长度</span></span><br><span class="line">        len = <span class="number">1</span>;</span><br><span class="line">        Node currend_node = slow.next;</span><br><span class="line">        <span class="keyword">while</span>(slow.value != currend_node.value)</span><br><span class="line">            &#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                len ++;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用快慢指针，计算相遇时的结点，相遇结点就是入口结点</span></span><br><span class="line">        Node first_node = node; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            first_node = first_node.next;</span><br><span class="line">        </span><br><span class="line">        Node second_node = node;</span><br><span class="line">        <span class="keyword">while</span>(second_node.value != first_node.value)&#123;</span><br><span class="line">            second_node = second_node.next;</span><br><span class="line">            first_node = first_node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> second_node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有序链表合并"><a href="#有序链表合并" class="headerlink" title="有序链表合并"></a>有序链表合并</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>有点类似归并排序，只是归并用的是数组，这里用的是链表</p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedMixed</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Linked</span><span class="params">(Node node1,Node node2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node1 == <span class="keyword">null</span>) <span class="keyword">return</span> node2;</span><br><span class="line">        <span class="keyword">if</span>(node2 == <span class="keyword">null</span>) <span class="keyword">return</span> node1;</span><br><span class="line">                </span><br><span class="line">        Node head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 明确思路是：</span></span><br><span class="line"><span class="comment">        * 升序的话：每一层返回的都是小的</span></span><br><span class="line"><span class="comment">        * 降序的话：每一层返回的都是大的</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span>(node1.value &lt;= node2.value)&#123;</span><br><span class="line">            head = node1;</span><br><span class="line">            head.next = Linked(node1.next,node2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head = node2;</span><br><span class="line">            head.next = Linked(node1,node2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除单链表倒数第n个结点"><a href="#删除单链表倒数第n个结点" class="headerlink" title="删除单链表倒数第n个结点"></a>删除单链表倒数第n个结点</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这个思路和寻找入口结点的链表题目基本一致。用到快慢指针。代码逻辑主要两步：</p><blockquote><ol><li>用快慢指针方法确定需要删除的结点</li><li>如何删除结点</li></ol></blockquote><p>但这里需要考虑一种情况：</p><blockquote><p>如果只有一个结点，需要怎么处理</p></blockquote><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedLast</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">Linked</span><span class="params">(Node node,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        Node first = node;</span><br><span class="line">        Node sencond = node;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一个结点的情况</span></span><br><span class="line">        <span class="keyword">if</span>(first == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node.next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.确定删除结点位置</span></span><br><span class="line">        <span class="keyword">while</span>(first!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            sencond = sencond.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除结点</span></span><br><span class="line">        sencond.next = sencond.next.next;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java OOM 各情况分析</title>
      <link href="/posts/50474098/"/>
      <url>/posts/50474098/</url>
      
        <content type="html"><![CDATA[<p>最近在学习jvm，结合线上任务，最常见的就是java的oom，为了快速解决生产环境出现的oom问题，特此总结各oom解决方案  </p><p>本文基于jdk8版本探讨oom情况，不同于jdk8以前版本，jdk8用元空间代替永久代，所以不会有永久代的oom报错，取而代之的是元空间的oom报错。</p><p>这里记录一个小知识，我们常说的方法区其实是逻辑概念，永久代和元空间是实现这个概念的具体方案，所以其实可以把元空间当作是新的方法区实现。元空间利用的是直接内存，但会进行gc</p><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jvm oom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> java </tag>
            
            <tag> oom </tag>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer习题归纳（持续更新）</title>
      <link href="/posts/a95aad52/"/>
      <url>/posts/a95aad52/</url>
      
        <content type="html"><![CDATA[<p>参考：<br><a href="https://www.cnblogs.com/yongh/p/9637260.html" target="_blank" rel="noopener">剑指offer java实现</a><br><a href="https://study.163.com/course/introduction.htm?courseId=1002942008#/courseDetail?tab=1" target="_blank" rel="noopener">课程列表 可以当作学习方向</a></p><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 剑指offer归纳 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优先级队列 java实现</title>
      <link href="/posts/323450f/"/>
      <url>/posts/323450f/</url>
      
        <content type="html"><![CDATA[<p>最近有一个同事走了，去了美团风控，这几个月的面试，他手里拿了头条、携程的offer，羡慕之余，我还向他取了经。整体而言，他和我说，除了项目的介绍，对大数据框架的认识以外，特别需要关注的就是算法和数据结构。然而，自己在这方面的造诣确实很少，所以后续时间，我会按数据结构类型（着重链表、树等）刷题，并且总结到博客中。</p><p>回想和他的交流过程，印象里他提到了 <strong><em>优先级队列</em></strong> ，当时并不知道什么东西，回来一看，我才发现，这不就是堆排序的变种嘛。因为最近刚刷过堆排序，所以对实现方式了如指掌。</p><p>正当我大展身手，准备手写一番时，我无意之间看到java的优先级队列底层的源码实现，我那一个震惊，竟然有如此巧妙和简单的实现方式，刹那间，我对java那岂是简单的心生爱恋，简直爱不释手。就此，我便准备用java实现优先级队列。</p><h1 id="什么是优先级队列"><a href="#什么是优先级队列" class="headerlink" title="什么是优先级队列"></a>什么是优先级队列</h1><p>优先级队列的理解很简单，把这个词拆分成两个名词，马上就能明白，分别是 优先级 + 队列。</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>优先级指的是按照特定的排序算法，或者说比较算法，来实现队列元素的顺序提取。最简单的就是按数字的升序进行元素提取。所以核心点就在于</p><blockquote><p>如何确保 <strong><em>在乱序添加元素的前提下，还能有序的提取元素</em></strong></p></blockquote><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列就是一个数据结构，什么数据结构呢？</p><blockquote><p>元素按照顺序，先进先出的数据结构。具体实现方式可以用链表和数组。</p></blockquote><p>就像排队吃饭一样，排到前面的先吃饭，排到最后就没饭吃是一个道理。</p><h1 id="java实现及解释"><a href="#java实现及解释" class="headerlink" title="java实现及解释"></a>java实现及解释</h1><h2 id="实现优先级队列的算法"><a href="#实现优先级队列的算法" class="headerlink" title="实现优先级队列的算法"></a>实现优先级队列的算法</h2><p>其实实现优先级算法有挺多，最简单的就是每次添加元素就遍历队列，接着遍历出来的每个元素和添加的元素进行比较，然后把当前元素插入合适的位置。</p><p>但这种实现方式的时间复杂度为 O(n)，因为涉及到一个for循环。对于数据结构的实现，我们要优先考虑时间复杂度。那有啥好办法木有，有的，堆排序在众多排序中，时间复杂度是比较稳定的，为logn。所以对于优先级队列的默认实现，用到的是堆排序。（什么是堆排序，可以看我博客的 <a href="http://jskblog.xyz/posts/7ad6c44f/">十大排序中的堆排序</a>）</p><h2 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h2><p>关于java代码实现，主要两个点：</p><blockquote><ol><li>添加元素：需要元素上推构建堆逻辑</li><li>取出元素：需要元素下推构建堆逻辑</li></ol></blockquote><p>以上面两个为核心，进行逻辑实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">priQueue</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size_default = <span class="number">0</span>;</span><br><span class="line">    Object[] queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> default_size = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">priQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[default_size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> size,<span class="keyword">int</span> element)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 构建小顶堆</span></span><br><span class="line">        Comparable&lt;Integer&gt; element_com = element; <span class="comment">//把element变成可比较对象</span></span><br><span class="line">        <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = (size-<span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 取出父节点的下标</span></span><br><span class="line">            Object parent = queue[index]; <span class="comment">// 父节点的值</span></span><br><span class="line">            <span class="keyword">if</span>(element_com.compareTo((Integer) parent) &gt;= <span class="number">0</span>) <span class="comment">//父节点和当前元素进行比较</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 如果当前元素比父节点大，则跳出循环，直接添加到末尾</span></span><br><span class="line">            queue[size] = parent; <span class="comment">// 如果没有跳出循环，说明当前元素比父节点小，父节点放最后</span></span><br><span class="line">            size = index; <span class="comment">// size减少，用于上面index上推找父节点的父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue[size] = element;<span class="comment">//把添加元素添加到queue中</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = size_default; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(size&gt;=queue.length)&#123;<span class="comment">//延长数组</span></span><br><span class="line">            queue = Arrays.copyOf(queue,size+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size_default = size+<span class="number">1</span>;<span class="comment">//因为添加元素了，所以size+1</span></span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            queue[<span class="number">0</span>] = element;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            siftUp(size,element);<span class="comment">//上推构建顶堆</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> size,<span class="keyword">int</span> element)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 构建小顶堆，构建顶堆的过程，会直接替换掉原 size 下标的值</span></span><br><span class="line">        <span class="keyword">int</span> half = size_default &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 运算符运算 ：size/2 的意思 一半值</span></span><br><span class="line">        <span class="keyword">while</span>(size &lt; half)&#123;</span><br><span class="line">            <span class="keyword">int</span> child = (size &lt;&lt; <span class="number">1</span> ) + <span class="number">1</span>; <span class="comment">// size*2 + 1 size下标节点的左子节点</span></span><br><span class="line">            Object child_element = queue[child]; <span class="comment">// 左子节点</span></span><br><span class="line">            <span class="keyword">int</span> right = child+<span class="number">1</span>; <span class="comment">// 右子节点</span></span><br><span class="line">            <span class="keyword">if</span>(child++ &lt; half &amp;&amp;</span><br><span class="line">                    ((Comparable&lt;Integer&gt;)child_element).compareTo((Integer)queue[right]) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                child_element = queue[child = right]; <span class="comment">// 比较左右子节点哪个更小</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(((Comparable)element).compareTo(child_element) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//如果element 比 子节点还要小，不需要后续工作了，直接把element赋值给size下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            queue[size] = child_element; <span class="comment">// 如果上面没有跳出循环，说明子节点更小，把子节点值赋给size下标</span></span><br><span class="line">            size = child;<span class="comment">//size变成子节点下标，继续比较子节点的子节点大小，下推比较</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue[size] = element;<span class="comment">//把element赋值给size</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">poll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size_default == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//如果size没有了 直接返回null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s = -- size_default;<span class="comment">//s为下标值，size_default是数组长度，比下标多一位</span></span><br><span class="line">        Object result = queue[<span class="number">0</span>];<span class="comment">//取出首位</span></span><br><span class="line">        Object x = queue[s];<span class="comment">//取出末尾位</span></span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">0</span>)</span><br><span class="line">            siftDown(<span class="number">0</span>,(Integer) x);<span class="comment">//进行重构堆逻辑</span></span><br><span class="line">        <span class="keyword">return</span>  result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object[] return_queue()&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(queue,size_default);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 优先级队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 优先级队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序算法的实现和相关分析</title>
      <link href="/posts/7ad6c44f/"/>
      <url>/posts/7ad6c44f/</url>
      
        <content type="html"><![CDATA[<h1 id="排序说明"><a href="#排序说明" class="headerlink" title="排序说明"></a>排序说明</h1><p>因为室友面试被问到排序算法，当时他因为知识储备问题答不上，回来和我说起面试题，我想了想，发现自己对这块也不太熟悉，所以整理了一些重要的算法，进行python实现。</p><p>本文主要会涉及几个点：</p><ol><li>每个排序的python实现</li><li>一些排序思想的介绍</li><li>记录时间复杂度和空间复杂度</li><li>最后给自己留下题目，方便日后回顾</li></ol><h1 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h1><p>关于排序的大概介绍如下图：</p><p><img alt="各排序时间复杂度/空间复杂度/稳定性" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/sort_time.png" class="lozad"></p><blockquote><p>简单介绍一些概念：</p><blockquote><p>稳定性：在排序的过程中，相等的数是否会交换位置，会交换位置的算法则为 <strong><em>不稳定算法</em></strong><br>时间复杂度：通过大O算法进行初略进行算法的运行时间<br>空间复杂度：用到的内存初略计算</p></blockquote></blockquote><h1 id="各排序介绍"><a href="#各排序介绍" class="headerlink" title="各排序介绍"></a>各排序介绍</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><blockquote><p>最简单的排序算法<br>稳定性：稳定（如果里面的判断是= , 则为非稳定，正常默认冒泡排序为稳定算法）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    冒泡排序：</span></span><br><span class="line"><span class="string">    思路在 左右两个数 两两比较</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(arr)-i<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">                tmp = arr[j]</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>]</span><br><span class="line">                arr[j+<span class="number">1</span>] = tmp</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote><p>思路在：从头开始遍历，选择出最小值下标，然后进行最小值交换<br>稳定性：非稳定。<br>举例：5 8 5 2 1 第一次排序 2和5交换位置后，原先在前面的5到后面去了</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    选择排序：</span></span><br><span class="line"><span class="string">    思路在每次循环 选择最小的和当前循环的值进行转换</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    arr_len = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(arr_len):<span class="comment"># 循环数组长度</span></span><br><span class="line">        min_index = i <span class="comment"># 假设i为最小值的下标</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,arr_len,<span class="number">1</span>):<span class="comment"># 拿最小值下标和后面的数进行比较</span></span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[min_index]:</span><br><span class="line">                min_index = j <span class="comment"># 比较选出最小值</span></span><br><span class="line">        <span class="comment"># 交换最小值位置</span></span><br><span class="line">        tmp = arr[min_index]</span><br><span class="line">        arr[min_index] = arr[i]</span><br><span class="line">        arr[i] = tmp</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>思路在：current 为当前值，不断往前比较，确认达到最小/最大值 往那个index插入当前值<br>稳定性：稳定</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    插入排序：</span></span><br><span class="line"><span class="string">    思路在 current 为当前值，不断往前比较，确认达到最小/最大值 往那个index插入当前值</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    arr_len = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,arr_len):<span class="comment"># 注意是从1开始，而非0</span></span><br><span class="line">        index = i<span class="number">-1</span> <span class="comment"># 当前比较数下标的前一个index</span></span><br><span class="line">        current = arr[i] <span class="comment"># 当前需要进行比较的数</span></span><br><span class="line">        <span class="keyword">while</span> index&gt;=<span class="number">0</span> <span class="keyword">and</span> arr[index] &gt; current: <span class="comment"># 当前数和前一个数进行比较</span></span><br><span class="line">            arr[index+<span class="number">1</span>] = arr[index] <span class="comment"># 如果当前数比前一个数小，把前一个数的值赋给 当前比较数</span></span><br><span class="line">            index-=<span class="number">1</span> <span class="comment"># 继续往左比较</span></span><br><span class="line">        arr[index+<span class="number">1</span>] = current <span class="comment"># 比较结束后，如果上面没有进入循环，则index+1 其实就是当前比较数</span></span><br><span class="line">                                <span class="comment"># 如果进入了循环，右边的数不断往左移，跳出循环后，把当前数赋给index + 1 位置</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><blockquote><p>思想在：插入排序在小数据量的时候时间是教快的，希尔的思路在于，把大数据拆分成多个分区，不同分区用插入排序进行排序，最后融合<br>稳定性：非稳定</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shellSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    希尔排序：</span></span><br><span class="line"><span class="string">    思路在 分序列进行插入排序</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    arr_len = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(arr_len/<span class="number">2</span>):</span><br><span class="line">        插入排序</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote><p>快速排序是比较复杂的排序算法<br>思路在：<a href="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html" target="_blank" rel="noopener">快速排序参考资料（看完立马懂）</a><br>稳定性：非稳定</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(arr,start,end)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    快速排序：</span></span><br><span class="line"><span class="string">    思路在 选一个比较值 大的放右边 小的放左边 以此为逻辑递归执行</span></span><br><span class="line"><span class="string">    涉及递归，存在递归深度问题</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> start &gt;= end: <span class="keyword">return</span></span><br><span class="line">    temp = arr[start] <span class="comment"># 选出一个值作为比较值</span></span><br><span class="line">    left = start <span class="comment"># 开始下标</span></span><br><span class="line">    right = end <span class="comment"># 结束下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt; right: <span class="comment"># 判断下标没有碰面 才进行下一步操作</span></span><br><span class="line">        <span class="comment"># 外面的while用于判断是否继续进行循环比较</span></span><br><span class="line">        <span class="comment"># 里面的while用于控制范围缩小的区间</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> arr[right] &gt;= temp:<span class="comment"># 判断当前值是否小于比较值，当小于的时候则不继续循环，大于的时候则继续循环</span></span><br><span class="line">            right -= <span class="number">1</span> <span class="comment"># 一直往左进行范围缩小，直到小于比较值</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> arr[left] &lt;= temp: <span class="comment"># 和上面的循环判断相反</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; right: <span class="comment"># 交换两者的位置</span></span><br><span class="line">            arr[right] = arr[left] ^ arr[right]</span><br><span class="line">            arr[left] = arr[left] ^ arr[right]</span><br><span class="line">            arr[right] = arr[left] ^ arr[right]</span><br><span class="line">    <span class="comment"># 交换 比较值和left=right的值</span></span><br><span class="line">    arr[start] = arr[left]</span><br><span class="line">    arr[left] = temp</span><br><span class="line">    <span class="comment"># 以中间值左右划分，递归进行快速排序。递归会有深度问题，可以用栈的方式实现</span></span><br><span class="line">    quickSort(arr,start,left<span class="number">-1</span>)</span><br><span class="line">    quickSort(arr,left+<span class="number">1</span>,end)</span><br></pre></td></tr></table></figure><blockquote><p>下面是用栈的方式替代递归</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zhan_quickSort</span><span class="params">(arr,start,end)</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    stack.append(start)</span><br><span class="line">    stack.append(end)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">        end = stack.pop()</span><br><span class="line">        start = stack.pop()</span><br><span class="line"></span><br><span class="line">        index = baseSort(arr,start,end) <span class="comment"># 这一部分是上面去除quickSort递归前面的逻辑，直接返回中间值</span></span><br><span class="line">        <span class="keyword">if</span> index+<span class="number">1</span> &lt; right:</span><br><span class="line">            stack.append(index+<span class="number">1</span>)</span><br><span class="line">            stack.append(right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index<span class="number">-1</span> &gt; left:</span><br><span class="line">            stack.append(index<span class="number">-1</span>)</span><br><span class="line">            stack.append(left)</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote><p>思路在：用二分法 对数组进行切分，从最小值开始进行归并排序<br>稳定性：稳定</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(arr)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left,right)</span>:</span></span><br><span class="line">        merged = [] <span class="comment"># 创建一个数组</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># 下标判断，默认为0</span></span><br><span class="line">        left_len = len(left)</span><br><span class="line">        right_len = len(right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; left_len <span class="keyword">and</span> j &lt; right_len: <span class="comment"># 遍历传进来的两个数组，判断下标不会超过数组长度</span></span><br><span class="line">            <span class="keyword">if</span> left[i] &lt; right[j]: <span class="comment"># 对两个数组从0开始比较 符合条件的就把值添加到 新建的数组中</span></span><br><span class="line">                merged.append(left[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                merged.append(right[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 最后跳出循环，把剩余的元素给添加进 新建数组中</span></span><br><span class="line">        merged.extend(left[i:])</span><br><span class="line">        merged.extend(right[j:])</span><br><span class="line">        <span class="keyword">return</span> merged</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:<span class="keyword">return</span> arr <span class="comment"># 递归的返回条件</span></span><br><span class="line">    middle = len(arr)//<span class="number">2</span> <span class="comment"># 二分出左右两边数组</span></span><br><span class="line">    <span class="comment"># 递归左右两边数组</span></span><br><span class="line">    left = mergeSort(arr[:middle])</span><br><span class="line">    right = mergeSort(arr[middle:])</span><br><span class="line">    <span class="keyword">return</span> merge(left,right)</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><blockquote><p>堆排序是一个有意思的排序。思路在 构建顶堆，然后交换顶堆和最后的值<br>这里涉及两个概念：大顶堆 和 小顶堆<br>堆的概念: 堆指的是完全二叉树的数组对象，完全二叉树指的是 1、倒数第一层以前都为满节点 2、最后一层节点都靠左<br>大顶堆：节点值比子节点大（每个子树间比较），构建大顶堆最后排序为：升序<br>小顶堆：节点值比子节点小（每个子树间比较），构建小顶堆最后排序为：降序<br>稳定性：非稳定<br>参考资料：<a href="https://www.jianshu.com/p/d174f1862601" target="_blank" rel="noopener">堆排序[1]</a> <a href="https://www.cnblogs.com/shiqi17/p/9694938.html" target="_blank" rel="noopener">堆排序[2]</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(elems)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路在 先构建顶堆 然后 交换头和尾节点 再从头开始构建顶堆</span></span><br><span class="line"><span class="string">    :param elems:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">siftdown</span><span class="params">(elems, begin, end)</span>:</span> <span class="comment">#向下筛选</span></span><br><span class="line">        i, j = begin, begin*<span class="number">2</span>+<span class="number">1</span> <span class="comment">#i为父节点，j为i的左子结点</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; end:</span><br><span class="line">            <span class="keyword">if</span> j+<span class="number">1</span> &lt; end <span class="keyword">and</span> elems[j] &gt; elems[j+<span class="number">1</span>]: <span class="comment">#如果左子结点大于右子结点</span></span><br><span class="line">                j += <span class="number">1</span>                              <span class="comment">#则将j指向右子结点</span></span><br><span class="line">            <span class="keyword">if</span> elems[i] &lt; elems[j]: <span class="comment">#j已经指向两个子结点中较小的位置，</span></span><br><span class="line">                <span class="keyword">break</span>        <span class="comment">#如果插入元素e小于j位置的值，则为3者中最小的</span></span><br><span class="line">            elems[i],elems[j] = elems[j],elems[i] <span class="comment"># 交换两个值，子节点替代父节点</span></span><br><span class="line">            i,j = j,j*<span class="number">2</span>+<span class="number">1</span> <span class="comment"># 把j的下标赋给i，j的值变成原j的子节点，这一步是为了交换节点后，对新的子树进行顶堆建立</span></span><br><span class="line"></span><br><span class="line">    end = len(elems)<span class="number">-1</span></span><br><span class="line">    parent = end//<span class="number">2</span><span class="number">-1</span> <span class="comment"># 取出所有有子节点的父节点</span></span><br><span class="line">    <span class="keyword">while</span> parent &gt;= <span class="number">0</span>: <span class="comment"># 构建顶堆</span></span><br><span class="line">        siftdown(elems,parent,end)</span><br><span class="line">        parent -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> end &gt; <span class="number">0</span>:</span><br><span class="line">        elems[end],elems[<span class="number">0</span>] = elems[<span class="number">0</span>],elems[end] <span class="comment"># 交换顶值和最后值</span></span><br><span class="line">        siftdown(elems,<span class="number">0</span>,end) <span class="comment"># 以首位作为父节点，重新构建顶堆</span></span><br><span class="line">        end -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elems</span><br></pre></td></tr></table></figure><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><blockquote><p>思路在 构建一个新数组 它的下标为需要排序的数组值 它的值为该数出现的次数，最后遍历新数组按顺序取出值<br>计数排序是特殊的桶排序<br>稳定性：稳定</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countingSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路在 构建一个新数组 它的下标为需要排序的数组值 它的值为该数出现的次数</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    max_value = max(arr) <span class="comment"># 计数排序需要获取最大值</span></span><br><span class="line">    count = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(max_value+<span class="number">1</span>)] <span class="comment"># 下标为arr的值 值为计数总数</span></span><br><span class="line">    last_value = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        count[arr[i]] += <span class="number">1</span> <span class="comment"># 把需要排序的值 做为下标 进行计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(count)):</span><br><span class="line">        <span class="keyword">while</span> count[i] &gt; <span class="number">0</span>: <span class="comment"># 遍历计数值 如果大于0 则把下标添加到新的数组</span></span><br><span class="line">            last_value.append(i)</span><br><span class="line">            count[i] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> last_value</span><br></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><blockquote><p>思路在：过个人方式把数据划分到不同的桶中（抽象概念，可以用数组实现） 然后桶内排序（桶内排序需要用到别的排序算法），遍历出来即是有序数组<br>稳定性：稳定</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路在：</span></span><br><span class="line"><span class="string">    通过个人方式把数据划分到不同的桶中（抽象概念，可以用数组实现） 然后桶内排序（桶内排序需要用到别的排序算法），遍历出来即是有序数组</span></span><br><span class="line"><span class="string">    :param array:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 1.创建n个空桶</span></span><br><span class="line">    min_value = min(array)</span><br><span class="line">    max_value = max(array)</span><br><span class="line">    bucket_size = max_value-min_value+<span class="number">1</span></span><br><span class="line">    new_list = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(bucket_size)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.把arr[i] 插入到bucket[n*array[i]]</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> array:</span><br><span class="line">        <span class="comment"># 核心步骤在 如何划分桶 即index 的生成逻辑</span></span><br><span class="line">        index = (data-min_value)</span><br><span class="line">        new_list[index].append(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.桶内排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(bucket_size):</span><br><span class="line">        new_list[i].sort()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4.产生新的排序后的列表</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(bucket_size):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(new_list[i])):</span><br><span class="line">            array[index] = new_list[i][j]</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><blockquote><p>不介绍了</p></blockquote><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>稳定和不稳定的排序算法有哪些？</li><li>哪个算法最稳定，哪个算法最快？</li><li>哪个算法使用空间最大？</li><li>列出各算法的稳定性、时间复杂度、空间复杂度 和 可手写各算法（着重在快速排序、堆排序、归并排序、插入排序）</li><li>python排序的实现：<a href="https://blog.csdn.net/yangzhongblog/article/details/8184707" target="_blank" rel="noopener">time sort</a></li></ol><hr><center>谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建windows flink idea开发测试环境</title>
      <link href="/posts/b4bb247c/"/>
      <url>/posts/b4bb247c/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建说明"><a href="#搭建说明" class="headerlink" title="搭建说明"></a>搭建说明</h1><h2 id="难易"><a href="#难易" class="headerlink" title="难易"></a>难易</h2><p>windows flink搭建十分简单，官网都有说明，我一路走下来基本没有坑</p><h2 id="记录原因"><a href="#记录原因" class="headerlink" title="记录原因"></a>记录原因</h2><p>简单却记录的原因在于：</p><blockquote><p>1、整合资料，方便快速搭建<br>2、我之前见同事搭建过，觉得牛逼，便想请教下搭建方式，询问是否有教程。结果对方回应说没有教程，靠他一点点摸索，当时听完，对方在我心目中地位瞬间上升很多档次，深刻感知自己的弱小。如今看来，不是我弱小，而是我愚蠢。我百度一番，也没发现全流程教程，所以借此记录，方便后续新手的搭建</p></blockquote><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>windows 结合 idea，可以有效快速熟悉flink语法，作为入门是很好的方式</p><h1 id="搭建步骤："><a href="#搭建步骤：" class="headerlink" title="搭建步骤："></a>搭建步骤：</h1><h2 id="基本环境"><a href="#基本环境" class="headerlink" title="基本环境"></a>基本环境</h2><blockquote><p>1、java1.8以上<br>2、scala 2.1.1 或者 scala 2.1.2 （我下载的是2.1.2）<br>3、maven 最新版本<br>4、idea 社区版<br>上面的环境，可自行百度（我都是去对应官网下载）</p></blockquote><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>这两个是官网的链接，有先后顺序。如果不想看我的教程，可以直接查看官网教程<br><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/zh/dev/projectsetup/java_api_quickstart.html" target="_blank" rel="noopener">参考链接</a><br><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/zh/dev/projectsetup/dependencies.html" target="_blank" rel="noopener">参考链接</a></p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><blockquote><p>具体步骤只有两步：1、maven创建项目 2、配置依赖</p></blockquote><h4 id="maven创建项目"><a href="#maven创建项目" class="headerlink" title="maven创建项目"></a>maven创建项目</h4><ul><li>打开idea，创建maven工程，按如下配置进行添加。看配置参数可知，我搭建的是1.9版本，对应的版本可以根据自己需求来<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mvn archetype:generate                               \</span><br><span class="line">  -DarchetypeGroupId=org.apache.flink              \</span><br><span class="line">  -DarchetypeArtifactId=flink-quickstart-java      \</span><br><span class="line">  -DarchetypeVersion=1.9.0</span><br></pre></td></tr></table></figure><img alt="操作图" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/flink_windows.jpg" class="lozad"></li></ul><p>配置完毕后，会进行mvn操作，等待maven操作完成，进行下一步</p><h3 id="配置依赖"><a href="#配置依赖" class="headerlink" title="配置依赖"></a>配置依赖</h3><ul><li>打开pom.xml，我们会发现有两个错误项，把那两个删除，换成下面的依赖，更新maven完成搭建</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote><p>在上面的依赖配置中，我们发现scope这个选项，如果要在本地测试，需要把scope的值设置成compile。对应maven scope的解释请看<a href="http://jskblog.xyz/posts/2d6fc607/">maven scope</a>。</p></blockquote><p>简单解释即:<br>scope为compile时，代表强依赖，打包会把依赖添加到jar包中<br>scope为provided时，打包时，依赖不添加到jar包中</p><p>flink对两种scope的使用：</p><ol><li>compile：<strong><em>用于本地测试</em></strong></li><li>provided：<strong><em>用于线上部署运行</em></strong>。依赖不需要打包到jar包中的原因是：flink线上环境有相应的jar包，如果强依赖会出现jar包冲突情况</li></ol><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
          <category> flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows flink </tag>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven中scope的区别</title>
      <link href="/posts/2d6fc607/"/>
      <url>/posts/2d6fc607/</url>
      
        <content type="html"><![CDATA[<h1 id="依赖的Scope"><a href="#依赖的Scope" class="headerlink" title="依赖的Scope"></a>依赖的Scope</h1><p>最近在本地搭建flink想要熟悉语法，根据官网搭建过程中，发现maven的个别概念不熟悉，就此做个记录。<br>scope定义了类包在项目的使用阶段。项目阶段包括： 编译，运行，测试和发布。</p><h1 id="分类说明"><a href="#分类说明" class="headerlink" title="分类说明"></a>分类说明</h1><ul><li>compile<br>默认scope为compile，表示为当前依赖参与项目的编译、测试和运行阶段，属于强依赖。打包之时，会达到包里去。</li><li>test<br>该依赖仅仅参与测试相关的内容，包括测试用例的编译和执行，比如定性的Junit。</li><li>runtime<br>依赖仅参与运行周期中的使用。一般这种类库都是接口与实现相分离的类库，比如JDBC类库，在编译之时仅依赖相关的接口，在具体的运行之时，才需要具体的mysql、oracle等等数据的驱动程序。<br>此类的驱动都是为runtime的类库。</li><li>provided<br>该依赖在打包过程中，不需要打进去，这个由运行的环境来提供，比如tomcat或者基础类库等等，事实上，该依赖可以参与编译、测试和运行等周期，与compile等同。区别在于打包阶段进行了exclude操作。</li><li>system<br>使用上与provided相同，不同之处在于该依赖不从maven仓库中提取，而是从本地文件系统中提取，其会参照systemPath的属性进行提取依赖。</li><li>import<br>这个是maven2.0.9版本后出的属性，import只能在dependencyManagement的中使用，能解决maven单继承问题，import依赖关系实际上并不参与限制依赖关系的传递性。</li><li>systemPath<br>当maven依赖本地而非repository中的jar包，sytemPath指明本地jar包路径,例如：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupid</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupid</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactid</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systempath</span>&gt;</span>$&#123;basedir&#125;/WebContent/WEB-INF/lib/hamcrest-core-1.3.jar<span class="tag">&lt;/<span class="name">systempath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="dependency中的type"><a href="#dependency中的type" class="headerlink" title="dependency中的type"></a>dependency中的type</h1><p>引入某一个依赖时，必须指定type，这是因为用于匹配dependency引用和dependencyManagement部分的最小信息集实际上是{groupId，artifactId，type，classifier}。在很多情况下，这些依赖关系将引用没有classifier的jar依赖。这允许我们将标识设置为{groupId，artifactId}，因为type的默认值是jar，并且默认classifier为null。<br>type的值一般有jar、war、pom等，声明引入的依赖的类型</p><hr><center>谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 技术技巧 </category>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven scope </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装jar包后如何用maven调用</title>
      <link href="/posts/abf5534d/"/>
      <url>/posts/abf5534d/</url>
      
        <content type="html"><![CDATA[<h1 id="安装jar包后如何用maven调用"><a href="#安装jar包后如何用maven调用" class="headerlink" title="安装jar包后如何用maven调用"></a>安装jar包后如何用maven调用</h1><p>最近有使用maven，故此做一个maven的简单记录，防止后续需要</p><p>安装自定义jar包到本地Maven库<br>当出现下列情况时：<br>1.要使用的 jar 不存在于 Maven 的中心储存库中。<br>2.您创建了一个自定义的 jar ，而另一个 Maven 项目需要使用。</p><p>远程服务器需要在settings.xml中配置server用户名密码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>n<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">username</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">password</span>&gt;</span>12345<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要手动将所需要的jar包存放至Maven本地资源库，可以再cmd中输入以下命令：</p><blockquote><p>mvn install:install-file -Dfile=c:\userdefined-1.0.jar -DgroupId=pers.test.code -DartifactId=userdefined -Dversion={1.0} -Dpackaging=jar</p></blockquote><p>远程库命令如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mvn</span> <span class="attr">deploy:deploy-file</span> <span class="bullet">-DgroupId=com.abc.com3rd.policy</span> <span class="bullet">-DartifactId=policy-sdk</span> <span class="bullet">-Dversion=20180502102622</span> <span class="bullet">-Dpackaging=jar</span> <span class="bullet">-Dfile=D:\jar\local_policy.jar</span> <span class="bullet">-DrepositoryId=repo-huotu</span> <span class="bullet">-Durl=http://repo.abc.com:8081/nexus/content/repositories/releases/</span> <span class="bullet">-DgeneratePom=false</span></span><br><span class="line"><span class="string">各参数代表含义为：</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span><span class="string">Dmaven.test.skip=true</span>                              <span class="string">//跳过编译、测试</span></span><br><span class="line"><span class="bullet">-</span><span class="string">Dfile=D:\MvnProject\service-mvn-1.0.0.jar</span>          <span class="string">//jar包文件地址,绝对路径</span></span><br><span class="line"><span class="bullet">-</span><span class="string">DgroupId=pri.roy.mvn.test</span>                          <span class="string">//gruopId--pom坐标，自定义</span></span><br><span class="line"><span class="bullet">-</span><span class="string">DartifactId=mvn-api</span>                                <span class="string">//artifactId--pom坐标，自定义</span></span><br><span class="line"><span class="bullet">-</span><span class="string">Dversion</span>                                           <span class="string">//版本号</span></span><br><span class="line"><span class="bullet">-</span><span class="string">Dpackaging</span>                                         <span class="string">//打包方式</span></span><br><span class="line"><span class="bullet">-</span><span class="string">DrepositoryId</span>                                      <span class="string">//远程库服务器ID</span></span><br><span class="line"><span class="bullet">-</span><span class="string">Durl</span>                                               <span class="string">//远程库服务器地址</span></span><br></pre></td></tr></table></figure><p>安装成功后，在pom.xml文件中可以使用了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>pers.test.code<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>userdefined <span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><center>谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 技术技巧 </category>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
            <tag> jar包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsdelivr加速读取github文件</title>
      <link href="/posts/5a5aec9f/"/>
      <url>/posts/5a5aec9f/</url>
      
        <content type="html"><![CDATA[<h2 id="jsdelivr是什么"><a href="#jsdelivr是什么" class="headerlink" title="jsdelivr是什么"></a>jsdelivr是什么</h2><p>github：<a href="https://github.com/jsdelivr/jsdelivr" target="_blank" rel="noopener">https://github.com/jsdelivr/jsdelivr</a><br>官网：<a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">https://www.jsdelivr.com/</a><br>免费的公用CDN加速服务网（CDN是就近服务器访问，所以会加速）</p><h2 id="作用是什么"><a href="#作用是什么" class="headerlink" title="作用是什么"></a>作用是什么</h2><p>可以加速访问文件、图片，而本文章则介绍如何利用jsdelivr加速访问github照片为主<br>之所以需要用到jsdelivr加速访问照片，在于可<strong>方便快速</strong>管理 hexo 里面的图片链接</p><h2 id="如何操作"><a href="#如何操作" class="headerlink" title="如何操作"></a>如何操作</h2><p>举我个人例子的大致过程：</p><ol><li>生成新的github仓库</li><li>构建文件夹用于存放照片文件 <a href="https://github.com/JSK520/blog_web/blob/master/photos/person.jpg" target="_blank" rel="noopener">github目录</a></li><li>关键一步：点击项目上端的<strong>release</strong> 创建版本：<br><img alt="release的创建简介" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/photos/release_v1.jpg" class="lozad"></li><li>创建好后，点击进入图片链接：<br>那我的做例子，进入github照片路径为：<br><a href="https://github.com/JSK520/blog_web/blob/v1.1/photos/release_v1.jpg" target="_blank" rel="noopener">https://github.com/JSK520/blog_web/blob/v1.1/photos/release_v1.jpg</a></li><li>把对应路径变更为以下方式即可<br><a href="https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/photos/release_v1.jpg" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/photos/release_v1.jpg</a></li></ol><p>仔细看我们发现：<br><a href="https://github.com/JSK520/blog_web/blob/v1.1/" target="_blank" rel="noopener">https://github.com/JSK520/blog_web/blob/v1.1/</a><br>这个前缀替换成了<br><a href="https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/</a><br>而 /photos/release_v1.jpg 是github的文件名</p><hr><center>谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> jsdelivr </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jsdelivr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown 样式总结</title>
      <link href="/posts/c491c9ac/"/>
      <url>/posts/c491c9ac/</url>
      
        <content type="html"><![CDATA[<blockquote><p>markdown的样式总结</p></blockquote><hr><p><strong>本文由佳境协助完成，就此感谢他，做个小广告：</strong></p><blockquote><ul><li>Welcome To <a href="http://shmily-qjj.top/" target="_blank" rel="noopener">佳境博客</a></li><li>他的<a href="https://github.com/Shmilyqjj" target="_blank" rel="noopener">GitHub</a>地址</li><li>他的<a href="http://music.163.com/artist?id=13610347" target="_blank" rel="noopener">CloudMusic</a>地址</li></ul></blockquote><h3 id="HEXO目录结构"><a href="#HEXO目录结构" class="headerlink" title="HEXO目录结构"></a>HEXO目录结构</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">|--</span> <span class="string">_config.yml</span>     <span class="string">全局配置（网站名称作者主题部署等）</span></span><br><span class="line"><span class="string">|--</span> <span class="string">package.json</span>    <span class="string">框架参数（框架依赖拆件及其版本）</span></span><br><span class="line"><span class="string">|--</span> <span class="string">scaffolds</span>       <span class="string">脚手架（通用MarkDown模板，新建文章时，hexo根据这个目录的文件进行构建）</span></span><br><span class="line"><span class="string">|--</span> <span class="string">source</span>          <span class="string">网页资源（css,js,images,文章等）</span></span><br><span class="line">   <span class="string">|--</span> <span class="string">_posts</span>       <span class="string">博客文章（写文章的地方）</span></span><br><span class="line"><span class="string">|--</span> <span class="string">themes</span>          <span class="string">主题目录</span></span><br><span class="line"><span class="string">|--</span> <span class="string">.gitignore</span>      <span class="string">Git忽略文件或目录</span></span><br><span class="line"><span class="string">|--</span> <span class="string">package.json</span>    <span class="string">框架参数（框架依赖拆件及其版本）</span></span><br></pre></td></tr></table></figure><hr><h1 id="MarkDown语法字典"><a href="#MarkDown语法字典" class="headerlink" title="MarkDown语法字典"></a>MarkDown语法字典</h1><ul><li><p>标题</p><h1 id="一级标题-最大"><a href="#一级标题-最大" class="headerlink" title="一级标题(最大)"></a>一级标题(最大)</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></li><li><p>字体</p></li><li><p>斜体文本*<br><em>斜体文本</em></p></li><li><p><em>粗体文本*</em><br><strong>粗体文本</strong></p></li><li><p><strong>粗斜体文本*</strong><br><strong><em>粗斜体文本</em></strong><br><u>带下划线文本</u></p></li><li><p>脚注</p></li></ul><ul><li><p>列表<br>无序列表用* + -三种符号表示</p><ul><li>列表嵌套</li></ul><ol><li>有序列表第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素<blockquote><p>列表中可以使用区块<br>列表中可以使用区块</p></blockquote></li></ul></li><li>有序列表第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素<ul><li>最多第三层嵌套</li></ul><ul><li>最多第三层嵌套</li></ul><ul><li>最多第三层嵌套</li></ul></li></ul></li></ol></li><li><p>区块引用</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套…</p><blockquote><p>第二层嵌套…</p></blockquote></blockquote><ul><li>list</li><li>list</li></ul><ul><li>list</li></ul></blockquote></li><li><p>代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">        System.out.<span class="title">println</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">//tab或者四个空格</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = []</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">copy.copy(l)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qjj = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//定义代码块并指定语言-&gt;显示高亮</span></span><br></pre></td></tr></table></figure><ul><li>链接<br>这是我的云音乐主页<a href="http://music.163.com/artist?id=13610347" target="_blank" rel="noopener">CloudMusic</a><br>直接显示链接地址: <a href="http://music.163.com/artist?id=13610347" target="_blank" rel="noopener">http://music.163.com/artist?id=13610347</a><br>我的网易云主页高级链接<a href="http://music.163.com/artist?id=13610347" target="_blank" rel="noopener">cm-1</a><br>我的网易云主页高级链接<a href="http://music.163.com/artist?id=13610347" target="_blank" rel="noopener">cm-2</a></li></ul><ul><li><p>添加图片<br><img alt="alt lalala" data-src="http://m.qpic.cn/psb?/V10aWFGB3ChSVt/4Onwe7wF*pBhD4*iWs0KetAXGTu6fMrAUJrxWkkB4fk!/b/dL8AAAAAAAAA&bo=hANYAgAAAAADB*8!&rf=viewer_4" class="lozad"><br><img alt="alt hahaha" title="图片注释呀!鼠标放那会弹出注释!" data-src="http://m.qpic.cn/psb?/V10aWFGB3ChSVt/4Onwe7wF*pBhD4*iWs0KetAXGTu6fMrAUJrxWkkB4fk!/b/dL8AAAAAAAAA&bo=hANYAgAAAAADB*8!&rf=viewer_4" class="lozad"></p><img width="30%" title="可以使用html的标签,控制图片大小,title悬停显示文字" data-src="http://m.qpic.cn/psb?/V10aWFGB3ChSVt/4Onwe7wF*pBhD4*iWs0KetAXGTu6fMrAUJrxWkkB4fk!/b/dL8AAAAAAAAA&bo=hANYAgAAAAADB*8!&rf=viewer_4" class="lozad"></li><li><p>图片链接<br><a href="https://www.alluxio.io/slack" target="_blank" rel="noopener"><img alt="Slack" data-src="https://slackin.alluxio.io/badge.svg" class="lozad"></a><br><a href="https://www.alluxio.io/download" target="_blank" rel="noopener"><img alt="Release" data-src="https://img.shields.io/github/release/alluxio/alluxio/all.svg" class="lozad"></a><br><a href="https://hub.docker.com/r/alluxio/alluxio" target="_blank" rel="noopener"><img alt="Docker Pulls" data-src="https://img.shields.io/docker/pulls/alluxio/alluxio.svg" class="lozad"></a><br><a href="https://www.alluxio.io/docs" target="_blank" rel="noopener"><img alt="Documentation" data-src="https://img.shields.io/badge/docs-reference-blue.svg" class="lozad"></a><br><a href="https://twitter.com/intent/follow?screen_name=alluxio" target="_blank" rel="noopener"><img alt="Twitter Follow" data-src="https://img.shields.io/twitter/follow/alluxio.svg?label=Follow&style=social" class="lozad"></a><br><a href="https://github.com/Alluxio/alluxio/blob/master/LICENSE" target="_blank" rel="noopener"><img alt="License" data-src="https://img.shields.io/github/license/alluxio/alluxio.svg" class="lozad"></a></p></li></ul><ul><li>添加表格<br><code>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行</code><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>表格</td><td>表格</td></tr><tr><td>表格</td><td>表格</td></tr><tr><td>表格</td><td>表格</td></tr></tbody></table></li></ul><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><ul><li>对HTML的支持<br><code>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Ctrl<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span>+<span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Alt<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span>+<span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Del<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span> 重启电脑</span><br></pre></td></tr></table></figure><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><p><strong>文本加粗</strong><br><strong>*正常显示*号配合文本加粗体\</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">以下支持反斜杠转义</span></span><br><span class="line"><span class="string">\</span>   <span class="string">反斜线</span></span><br><span class="line"><span class="string">`</span>   <span class="string">反引号</span></span><br><span class="line"><span class="string">*</span>   <span class="string">星号</span></span><br><span class="line"><span class="string">_</span>   <span class="string">下划线</span></span><br><span class="line"><span class="string">&#123;&#125;</span>  <span class="string">花括号</span></span><br><span class="line"><span class="string">[]</span>  <span class="string">方括号</span></span><br><span class="line"><span class="string">()</span>  <span class="string">小括号</span></span><br><span class="line"><span class="comment">#   井字号</span></span><br><span class="line"><span class="string">+</span>   <span class="string">加号</span></span><br><span class="line"><span class="bullet">-</span>   <span class="string">减号</span></span><br><span class="line"><span class="string">.</span>   <span class="string">英文句点</span></span><br><span class="line"><span class="string">!</span>   <span class="string">感叹号</span></span><br></pre></td></tr></table></figure><ul><li>数学公式  需要开启 mathjax: 0 0改为1<br><code>当需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现</code></li></ul><p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>$$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}<br>$$</p><hr><h3 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks:"></a>Thanks:</h3><p><a href="https://github.com/mashirozx/Sakura/" target="_blank" rel="noopener">Sakura</a> Hexo theme.</p><p><a href="https://sakura.hojun.cn" target="_blank" rel="noopener">hojun</a> Modified into the theme.</p><hr><center>谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 总结</title>
      <link href="/posts/424111dd/"/>
      <url>/posts/424111dd/</url>
      
        <content type="html"><![CDATA[<p>无法提交theme：<br>下面以yelee做例子<br>cd theme/<br>删除 .git文件<br>git rm -cached yelee/<br>git add yelee</p><p>如果出现 lock情况：<br>rm -f xx/.git/index.lock</p><h2 id="github照片上传："><a href="#github照片上传：" class="headerlink" title="github照片上传："></a>github照片上传：</h2><p>查看远程仓库的版本：<br>git ls-remote</p><p>直接覆盖线上版本：<br>git push -f origin master:tags/v1.1</p><h2 id="部署命令"><a href="#部署命令" class="headerlink" title="部署命令"></a>部署命令</h2><p>hexo -g;hexo d</p><h2 id="新建模板文章"><a href="#新建模板文章" class="headerlink" title="新建模板文章"></a>新建模板文章</h2><p>hexo new post post-jvm-collection</p><hr><center>谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
