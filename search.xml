<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql锁机制优化汇总</title>
      <link href="/posts/cdbb5827/"/>
      <url>/posts/cdbb5827/</url>
      
        <content type="html"><![CDATA[<h1 id="文章思路"><a href="#文章思路" class="headerlink" title="文章思路"></a>文章思路</h1><p>根据以下思路进行介绍：</p><ol><li>锁有哪些</li><li>各个锁的使用场景和简单介绍</li><li>innodb和myisam引擎锁的简单介绍</li><li>如何加锁</li><li>锁可能会出现的问题</li><li>如何优化锁相关机制</li></ol><h1 id="锁分类"><a href="#锁分类" class="headerlink" title="锁分类"></a>锁分类</h1><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>乐观锁指的是，数据库很乐观，觉得每次查询和修改数据库数据都不会出现冲突情况，只在提交操作时检查是否违反数据完整性，适合多读情况</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>通过版本来进行控制，每次修改完数据，都会拿当前版本信息和读取时的版本信息进行对比，如果版本信息变化了，就认为是过期数据</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作</p><h3 id="悲观锁和存储引擎"><a href="#悲观锁和存储引擎" class="headerlink" title="悲观锁和存储引擎"></a>悲观锁和存储引擎</h3><p>mysql的存储引擎是可插拔的，mysql通过api使用存储引擎进行存储。不同的存储引擎会支持不同的锁。我这里只总结innodb和myisam的区别</p><table><thead><tr><th>存储引擎</th><th>级别锁</th><th>支持的锁</th></tr></thead><tbody><tr><td>myisam引擎</td><td>表级锁</td><td>表级共享锁、表级排他锁</td></tr><tr><td><code>innodb引擎</code></td><td>表级锁</td><td>意向共享锁、意向排他锁</td></tr><tr><td>mysisam引擎</td><td>行级锁</td><td>无</td></tr><tr><td><code>innodb引擎</code></td><td>行级锁</td><td>行级共享锁、行级排他锁、间隙锁、next-key锁、插入意向锁</td></tr></tbody></table><h3 id="myisam悲观锁介绍"><a href="#myisam悲观锁介绍" class="headerlink" title="myisam悲观锁介绍"></a>myisam悲观锁介绍</h3><p>上面表格看到，myisam只支持表级锁：</p><ol><li>对myisam表的读操作（表级共享锁）：<code>不会阻塞</code>对同一表的<code>读操作</code>，但会阻塞同一表的写操作</li><li>对myisam表的写操作（表级排他锁）：<code>会阻塞</code>对同一表的<code>读写操作</code></li></ol><blockquote><p>表级锁：会以表做为粒度加锁</p></blockquote><p>优化建议：</p><ol><li>concurrent_insert：主要可以调整并发策略</li><li>low_priority_updates：设置1则读优先写</li><li>给系统参数max_write_lock_count设置一个合适的值，当一个表的读锁达到这个值后，MySQL就暂时将写请求的优先级降低，给读进程一定获得锁的机会。</li></ol><h3 id="innodb悲观锁介绍"><a href="#innodb悲观锁介绍" class="headerlink" title="innodb悲观锁介绍"></a>innodb悲观锁介绍</h3><p>在做innodb锁介绍前，先对innodb的锁进行分类（根据上面表格分类）：</p><blockquote><p>行级锁：共享锁、排他锁、间隙锁、next-key锁、插入意向锁<br>表级锁：意向共享锁、意向排他锁</p></blockquote><p>这里先做简单的介绍，关于什么时候会用什么锁可以看下文的<code>如何加锁</code></p><h4 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h4><ol><li>共享锁（S）：Shared Locks 也称为读锁，读锁允许多个连接同时并发读同一资源</li><li>排他锁（X）：Exclusive Locks 也称为写锁，保证只有一个资源在进行写操作，并写阻塞其他用户对该资源读写操作</li></ol><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>意向锁分为：</p><ol><li>意向共享锁：An intention shared lock (IS)</li><li>意向排他锁：An intention exclusive lock (IX)</li></ol><p>意向锁是innodb中<code>粒度较粗锁度较弱</code>的锁，他的作用主要做<code>意向预判</code>，即如果你连表级锁都没法获取，就没必要花资源去找行级锁了。那它是如何做到预判的？主要通过和行锁的兼容来预判（下面的表也是各博客的常客）：</p><table><thead><tr><th></th><th>X</th><th>IX</th><th>S</th><th>IS</th></tr></thead><tbody><tr><td>X</td><td>不兼容</td><td>不兼容</td><td>不兼容</td><td>不兼容</td></tr><tr><td>IX</td><td>不兼容</td><td>兼容</td><td>不兼容</td><td>兼容</td></tr><tr><td>S</td><td>不兼容</td><td>不兼容</td><td>兼容</td><td>兼容</td></tr><tr><td>IS</td><td>不兼容</td><td>兼容</td><td>兼容</td><td>兼容</td></tr></tbody></table><h4 id="索引行锁（Record-Locks）"><a href="#索引行锁（Record-Locks）" class="headerlink" title="索引行锁（Record Locks）"></a>索引行锁（Record Locks）</h4><p>通过名字可以看得出这是一个对索引进行加锁的锁机制。如果执行的语句中没有索引的话，就会给加上表锁，原因是通过索引我们可以快速找到需要加锁的行，但没有索引，执行计划就是需要扫描全表，扫描表的过程中会给每条记录加上<code>next-key锁</code>。但哪怕用到了索引，如果执行计划觉得没必要用到索引，譬如数据量很小，那还是会加表锁。所以这是基于执行计划的锁机制。</p><p>有些博客说到的点我没测出来：</p><blockquote><p>由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。</p></blockquote><p>我使用的版本是5.7.21-20，如果用相同的索引键并不会锁冲突，但如果是相同值，则会锁冲突，即<code>我所发现的是锁记录，而非锁索引键</code>。</p><p>innodb中，如果没有显式的为表加锁，表也会有个隐式的字段用来做主键，这点主要原因是innodb聚簇索引的特性所致。</p><h4 id="间隙锁（gap锁）"><a href="#间隙锁（gap锁）" class="headerlink" title="间隙锁（gap锁）"></a>间隙锁（gap锁）</h4><p>间隙锁是给间隙设置的锁。如果加间隙锁，则会在指定值前面的间隙加锁。</p><h4 id="next-key锁"><a href="#next-key锁" class="headerlink" title="next-key锁"></a>next-key锁</h4><p>next-key锁是索引行锁和间隙锁的集合。即如果用到next-key锁，则会把记录和该记录的前一个间隙加锁。</p><p>加next-key锁的目的：</p><ol><li>为了满足幻读</li><li>为了满足恢复与复制：并发的插入和更新需要控制顺序，不然会导致binlog的顺序错乱。binlog作用主要在主从同步和数据恢复。</li></ol><p>会产生next-key锁的情况：</p><ol><li>使用范围的加锁机制</li><li>等值加锁不存在的值</li></ol><h4 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h4><p>插入意向锁本质是gap锁，但它不会阻塞别的操作（如果插入数据不一致，插入意向锁间是兼容的，对别的语句而言也是共享的），主要目的是为了<code>提高并发插入</code>。插入意向锁会在获取gap锁，然后希望在这个gap区域插入数据时，获取到插入意向锁。举个例子就会秒懂：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">假设现在有记录 10， 30， 50， 70 ；且为主键 ，需要插入记录 25 。</span><br><span class="line"></span><br><span class="line">找到 小于等于25的记录 ，这里是 10</span><br><span class="line">找到 记录10的下一条记录 ，这里是 30</span><br><span class="line">判断 下一条记录30 上是否有锁</span><br><span class="line">1. 判断 30 上面如果 没有锁 ，则可以插入</span><br><span class="line">2. 判断 30 上面如果有Record Lock，则可以插入</span><br><span class="line">3. 判断 30 上面如果有Gap Lock/Next-Key Lock，则无法插入，因为锁的范围是 (10, 30) /（10, 30] ；在30上增加insert intention lock（ 此时处于waiting状态），当 Gap Lock / Next-Key Lock 释放时，等待的事物（ transaction）将被 唤醒 ，此时 记录30 上才能获得 insert intention lock ，然后再插入 记录25</span><br><span class="line">注意：一个事物 insert 25 且没有提交，另一个事物 delete 25 时，记录25上会有 Record Lock</span><br></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title></a></h4><h1 id="如何加锁"><a href="#如何加锁" class="headerlink" title="如何加锁"></a>如何加锁</h1><p>关于加锁的介绍其实各博客都已经写烂了，我只是做汇总，但有个问题困惑过我，我想做记录：</p><blockquote><p>如果我不用加锁语句，语句会加锁吗？mysql是如何做到事务隔离级别的？</p></blockquote><p>关于这个问题，需要先介绍两个概念，分别是显式锁和隐式锁</p><h2 id="显式锁"><a href="#显式锁" class="headerlink" title="显式锁"></a>显式锁</h2><p>顾名思义是手动添加的锁，也是博客常用的显示加锁：</p><p>添加共享锁</p><blockquote><p>select * from table where id = ? lock in share mode;</p></blockquote><p>添加排他锁</p><blockquote><p>select * from table where id = ? for update</p></blockquote><h2 id="隐式锁"><a href="#隐式锁" class="headerlink" title="隐式锁"></a>隐式锁</h2><p>默认存储引擎会根据不同的隔离级别进行加锁。</p><h3 id="myisam的隐式锁"><a href="#myisam的隐式锁" class="headerlink" title="myisam的隐式锁"></a>myisam的隐式锁</h3><p>在使用 MyISAM 存储引擎时。执行 SQL 语句，会自动为 SELECT 语句加上共享锁，为 UDI（更新，删除，插入）操作加上排他锁。</p><h3 id="innodb的隐式锁"><a href="#innodb的隐式锁" class="headerlink" title="innodb的隐式锁"></a>innodb的隐式锁</h3><p>innodb的隐式锁会根据事务级别进行处理</p><p><img alt data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/photos/lock_photo1.jpg" class="lozad"></p><p><img alt data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/photos/lock_photo2.jpg" class="lozad"></p><h1 id="使用锁需要注意的问题"><a href="#使用锁需要注意的问题" class="headerlink" title="使用锁需要注意的问题"></a>使用锁需要注意的问题</h1><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁是指两个或多个事务在同一个资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。</p><p>产生原因：</p><ol><li>真正的数据冲突</li><li>存储引擎的实现方式</li></ol><p>解决方案(部分或完全回滚其中一个事务)：</p><ol><li><code>wait-for graph 算法来主动进行死锁检测</code>。InnoDB处理死锁的方法：将持有最少行级的排它锁的事务进行回滚(比较简单的回滚算法)</li><li><code>innodb_lock_wait_timeout等待锁超时回滚事务</code>。死锁超时机制，超时后放弃对锁的请求</li></ol><h2 id="优化锁机制"><a href="#优化锁机制" class="headerlink" title="优化锁机制"></a>优化锁机制</h2><ol><li>尽量使用较低的隔离级别；</li><li>精心设计索引， 并尽量使用索引访问数据， 使加锁更精确， 从而减少锁冲突的机会</li><li>选择合理的事务大小，小事务发生锁冲突的几率也更小</li><li>给记录集显示加锁时，最好一次性请求足够级别的锁。比如要修改数据的话，最好直接申请排他锁，而不是先申请共享锁，修改时再请求排他锁，这样容易产生死锁</li><li>不同的程序访问一组表时，应尽量约定以相同的顺序访问各表，对一个表而言，尽可能以固定的顺序存取表中的行。这样可以大大减少死锁的机会</li><li>尽量用相等条件访问数据，这样可以避免间隙锁对并发插入的影响</li><li>不要申请超过实际需要的锁级别</li><li><code>除非必须，查询时不要显示加锁。</code>  MySQL的MVCC可以实现事务中的查询不用加锁，优化事务性能；MVCC只在COMMITTED READ（读提交）和REPEATABLE READ（可重复读）两种隔离级别下工作</li><li>对于一些特定的事务，可以使用表锁来提高处理速度或减少死锁的可能</li></ol><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/29150809" target="_blank" rel="noopener">参考1</a><br><a href="https://juejin.im/post/5b82e0196fb9a019f47d1823" target="_blank" rel="noopener">参考2</a><br><a href="https://juejin.im/post/5cb6c4ef51882532b70e6ff0" target="_blank" rel="noopener">参考3</a><br><a href="https://blog.csdn.net/mysteryhaohao/article/details/51669741" target="_blank" rel="noopener">参考4</a><br><a href="https://www.cnblogs.com/rjzheng/p/9950951.html" target="_blank" rel="noopener">参考5</a></p><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
          <category> 锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm 逃逸分析</title>
      <link href="/posts/5d514306/"/>
      <url>/posts/5d514306/</url>
      
        <content type="html"><![CDATA[<blockquote><p>撑着油纸伞，独自<br>彷徨在悠长、悠长<br>又寂寥的雨巷，<br>我希望飘过<br>一个丁香一样地<br>结着愁怨的姑娘<br>——《雨巷》戴望舒</p></blockquote><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>逃逸分析是java JIT的一个优化方案。</p><h2 id="什么是逃逸分析"><a href="#什么是逃逸分析" class="headerlink" title="什么是逃逸分析"></a>什么是逃逸分析</h2><p>逃逸分析需要分开两个词讨论，分别是逃逸和分析</p><h3 id="什么是逃逸"><a href="#什么是逃逸" class="headerlink" title="什么是逃逸"></a>什么是逃逸</h3><p>逃逸分析的基本行为就是分析对象动态<code>作用域</code>：当一个对象在方法中被定义后，它可能<code>被外部方法所引用</code>，例如作为调用参数传递到其他地方中，称为<code>方法逃逸</code>。甚至还有可能被外部线程访问到，比如赋值给类变量或可以在其他线程中访问的实例变量，称为<code>线程逃逸</code>。如果能证明一个对象不会逃逸到方法或线程之外，也就是别的方法或者线程无法通过任何途径访问到这个对象，则可能为这个变量进行一些高效的优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">skip</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> String[] skip()&#123;</span><br><span class="line">       String[] str = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">       <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面对象定义后，return出方法，这种现象就叫逃逸</p><h1 id="逃逸分析的作用"><a href="#逃逸分析的作用" class="headerlink" title="逃逸分析的作用"></a>逃逸分析的作用</h1><p>使用逃逸分析可以优化三个方面：</p><ol><li>同步省略</li><li>栈上分配</li><li>分离对象或标量替换</li></ol><h2 id="同步省略"><a href="#同步省略" class="headerlink" title="同步省略"></a>同步省略</h2><p>如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p><blockquote><p>即如果一个加了锁的方法，我发现该方法并没有逃逸，可以把锁消除</p></blockquote><h2 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h2><p>如果一个对象没有逃逸出方法，可能会把对象分配到栈上（正常分配到堆上），好处在：不需要gc，会跟着线程生命周期而结束。</p><h2 id="分离对象或标量替换"><a href="#分离对象或标量替换" class="headerlink" title="分离对象或标量替换"></a>分离对象或标量替换</h2><p>如果逃逸分析证明一个对象不会被外部访问。并且这个对象可以被拆散的话，那程序真正执行的时候可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来替换。</p><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>java7以后默认开启，关闭要指定：-XX:-DoEscapeAnalysis</p><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
          <category> 逃逸分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 逃逸分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql事务隔离和mvcc</title>
      <link href="/posts/1c92a0d/"/>
      <url>/posts/1c92a0d/</url>
      
        <content type="html"><![CDATA[<blockquote><p>风雨沉沉的夜里，前面一片荒郊<br>走尽荒郊，便是人们底道</p><p>呀？黑暗里歧路万千，叫我怎样走好？<br>“上帝！快给我些光明吧，让我好向前跑！”</p><p>上帝慌着说，“光明？我没处给你找”<br>“你要光明，你自己去造”<br>—— 朱自清《光明》</p></blockquote><p>回想30号写的总结，现在过去六天了，在这六天里，因为工作原因和个人特殊原因没能及时学习。但哪怕是及时学习了，我发现简单的几个知识点，看完需要花1个小时，总结却可能远远不止，因为正如我总结那篇所说，总结是需要结合自己的知识框架去思考，这个过程并非如我想象的简单，但不管如何，我会坚持下来，能日更就日更。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在文章开始前，想抛出一个结论，这个问题困扰了我一段时间：<code>mysql mvcc能不能解决幻读问题</code>，结论如下：</p><ol><li>在快照读读情况下，mysql通过mvcc来避免幻读。（快照读指的是简单的select语句）</li><li>在当前读读情况下，mysql通过next-key来避免幻读。（当前读指的是增删改的操作）</li></ol><h2 id="当前读"><a href="#当前读" class="headerlink" title="当前读"></a>当前读</h2><p>在读提交和可重复读两种事务隔离级别下，使用“当前读”的操作包括：<br>1、SELECT LOCK IN SHARE MODE（加锁语句）<br>2、SELECT FOR UPDATE（加锁语句）<br>3、DELETE\UPDATE\INSERT INTO\REPLACE INTO</p><p>当前读读到的是数据库最新的数据</p><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>学习事物隔离需要先理解什么是事务</p><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h3 id="事务的概念"><a href="#事务的概念" class="headerlink" title="事务的概念"></a>事务的概念</h3><p>事务的主要目的是让<code>数据库操作符合现实世界状态转换规则</code>，原意是交易，翻译成了事务。ACID是老生常谈的四大事务因素。</p><h3 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h3><p>所有操作都是连续的，要么都成功，要么都不成功，譬如转账，不能有转到一半的情况</p><h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>数据库数据符合现实世界的约束，称为一致性。譬如转账，a给b转了10元，那在转账前a和b的金钱总额 = 转账后a和b的金钱总额</p><h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>数据库为每一个用户开一个事务，多个并发事务间需要相互隔离，主要为状态转换做隔离。譬如a给b转账10元，和，b给a转账5元，两个事务要隔离，不然最后的金额会出现问题。</p><h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>转换结果永久保留</p><h2 id="关于mysql对事务的支持"><a href="#关于mysql对事务的支持" class="headerlink" title="关于mysql对事务的支持"></a>关于mysql对事务的支持</h2><h3 id="开启事务"><a href="#开启事务" class="headerlink" title="开启事务"></a>开启事务</h3><ol><li><p>BEGIN</p><blockquote><p>mysql&gt; BEGIN;<br>mysql&gt; insert into t1 value(“v1”);<br>mysql&gt; ROOLBACK;/COMMIT;</p></blockquote></li><li><p>START TRANSACTION<br>不做详细介绍</p></li></ol><h3 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h3><p>默认情况下，mysql会自动提交事务，mysql有个系统变量<code>autocommit</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE &apos;autocommit&apos;;</span><br><span class="line">+---------------+-------+</span><br><span class="line">| Variable_name | Value |</span><br><span class="line">+---------------+-------+</span><br><span class="line">| autocommit    | ON    |</span><br><span class="line">+---------------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>该autocommit默认值为ON，一条语句相当于一个事务</p><h3 id="隐式提交"><a href="#隐式提交" class="headerlink" title="隐式提交"></a>隐式提交</h3><ol><li>使用DDL语言（create、alter、drop：可以理解为让表存在的语言）</li><li>隐式使用和修改mysql数据库表</li><li>事务控制和关于锁定语句</li><li>加载数据的语句</li><li>关于mysql复制语句</li></ol><h3 id="保存点"><a href="#保存点" class="headerlink" title="保存点"></a>保存点</h3><p>不细说：该作用在可以为每条操作做保存点，回滚可以回滚到指定保存点位置。</p><h2 id="事务并发可能遇到的问题"><a href="#事务并发可能遇到的问题" class="headerlink" title="事务并发可能遇到的问题"></a>事务并发可能遇到的问题</h2><h3 id="脏写"><a href="#脏写" class="headerlink" title="脏写"></a>脏写</h3><p>一个事务修改了另一个未提交事务修改过的数据</p><p>关键在：</p><ol><li>一个事务未提交</li><li>另一个事务读到中间状态，修改了中间状态值</li><li>因为未提交，所以修改的中间状态值后得出的结果是有问题的</li></ol><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>一个事务读到另一个未提交事务修改过的数据</p><p>关键在：</p><ol><li>一个事务未提交</li><li>另一个事务读到中间状态</li><li>因为未提交，所以读到的数据无法回溯</li></ol><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>一个事务无法重复读取到相同值，原因在别的事务修改的值影响到另一个事务读取值范围</p><p>关键在：</p><ol><li>一个事务不断修改数据，但都不是最终数据</li><li>另一个事务不断读到修改后的数据</li><li>这时导致中间读到的数据都不是最终结果</li></ol><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>一个事务相同条件下多次读取记录，读到了之前没有读到的记录</p><p>关键在：</p><ol><li>一个事务在修改数据</li><li>另一个事务相同条件下，读到了之前没有读到的记录（强调新增）</li><li>删除操作导致数据读不到，属于<code>不可重复读</code></li></ol><blockquote><p>以上的问题级别由大到小：脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读</p></blockquote><h2 id="隔离级别划分"><a href="#隔离级别划分" class="headerlink" title="隔离级别划分"></a>隔离级别划分</h2><blockquote><p>注：possible = 可能发生  |  Not possible = 不可能发生<br>因为脏写太严重，所以所有隔离级别都不允许</p></blockquote><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED（未提交读）</td><td>possible</td><td>possible</td><td>possible</td></tr><tr><td>READ COMMITTED（已提交读）</td><td>Not possible</td><td>possible</td><td>possible</td></tr><tr><td>REPEATABLE READ（可重复读）</td><td>Not possible</td><td>Not possible</td><td>possible</td></tr><tr><td>SERIALIZABLE（可串行化）</td><td>Not possible</td><td>Not possible</td><td>Not possible</td></tr></tbody></table><p>上面的是sql标准做的隔离级别，不同的数据库会有不同的实现，<code>mysql在REPEATABLE READ隔离级别下，已经可以做到禁止幻读的问题</code></p><h1 id="MVCC-原理"><a href="#MVCC-原理" class="headerlink" title="MVCC 原理"></a>MVCC 原理</h1><blockquote><p>注：MVCC原理主要用于mysql innodb引擎上，所以innodb的所有设计思想在这里充分体现</p></blockquote><h2 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h2><p>innodb存储的最小单位是页，页里面存储的是每条数据，innodb中存储数据的数据结构后面有机会我会讲到，目前我们先假设我们学习过相关知识。</p><p>在数据的数据结构中，聚簇索引有两个必要的隐藏列：</p><ol><li>trx_id：存储事务id，每次一个事务对数据进行改动时都会赋值</li><li>roll_pointer：指向undo日志的地址（undo日志的结构后面会总结，简单理解就是每次修改操作的记录）</li></ol><h3 id="insert-undo"><a href="#insert-undo" class="headerlink" title="insert undo"></a>insert undo</h3><p>指向insert undo（insert的操作）的链接会在提交事务时就没用了，日志文件会被系统回收，所以没有版本链</p><h3 id="update-undo"><a href="#update-undo" class="headerlink" title="update undo"></a>update undo</h3><p>每修改一条记录，都会有相应的undo日志，roll_pointer把这些undo日志链接成链表，这个链表就称为版本链。版本链的头结点就是当前记录当前的值，每个版本都有相应的事务id（即上文说的trx_id），该事务id是用来识别判断当前查询应该返回的数据。</p><h2 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h2><p>对于<code>ReadCommit</code>和<code>repeatableRead</code>的隔离级别来说，都必须保证读到的是已经提交的事务，所以如果未提交的事务，这两个级别是不允许访问的。为了做到这点，mysql里面用<code>ReadView</code>结合<code>版本链</code>来实现这个功能。核心功能在：<code>判断版本链中的哪个版本是当前事务可见的</code></p><p>关于ReadView有四个概念需要先理解：</p><ol><li>m_ids:在生成ReadView时，数据库活跃的事务id列表</li><li>min_trx_id:活跃事务id的最小值，即m_ids列表中的最小值</li><li>max_trx_id:生成ReadView时，系统分配的下一个事务id（不是最大事务id）</li><li>creator_trx_id:生成ReadView事务的事务id</li></ol><p>有了ReadView，应该访问哪个版本的数据会经过下面步骤：<br>（总步骤：会遍历<code>版本链</code>中每个版本的trx_id和当前ReadView的属性值做比较）</p><ol><li>trx_id的值与creator_trx_id值<code>相等</code>，说明是访问自己事务的数据</li><li>trx_id的值<code>小于</code>min_trx_id值，说明这个版本的事务已经提交，可以被当前事务访问</li><li>trx_id的值<code>大于</code>max_trx_id值，说明该版本在ReadView生成后才生成，不可以被当前事务访问</li><li>trx_id的值在min_trx_id和max_trx_id<code>之间</code>，首先判断是否在m_ids里面，如果在，说明该版本是属于当前活跃版本，不可以访问。如果不在，说明该版本的事务已提交，可以访问数据</li></ol><h2 id="read-commit的ReadView"><a href="#read-commit的ReadView" class="headerlink" title="read commit的ReadView"></a>read commit的ReadView</h2><p>read commit的隔离级别是：不会出现脏读，而脏读产生的原因是因为：<code>一个事务读到另一个事务没有提交的数据</code>，所以解决这个问题的方案就是：进行每次查询操作的时候，都产生一个ReadView</p><h2 id="repeatable-Read的ReadView"><a href="#repeatable-Read的ReadView" class="headerlink" title="repeatable Read的ReadView"></a>repeatable Read的ReadView</h2><p>repeatable Read的隔离级别是：可以重复读和避免了幻读，而产生不可重复读的原因是：<code>一个事务读到另一个事务一直修改的数据</code>，产生幻读的原因是：<code>一个事务读到另一个事务添加的数据</code>，所以解决这个问题的方案是：进行第一次查询操作的时候，产生一个ReadView，后面每次查询都用这个ReadView判断可读版本</p><blockquote><p>上面两个概念我没有讲的很仔细，因为我主要做复习的笔记记录，如果没有基础可能需要先深入学习相关概念，看以后如果有时间我会添加图文再做详细解释</p></blockquote><h2 id="关于purge"><a href="#关于purge" class="headerlink" title="关于purge"></a>关于purge</h2><p>为了MVCC，update undo和delete操作（会做delete mark）的数据会保留一段时间。随着系统的运行，在确定系统中包含最早产生的那个ReadView的事务不会再访问某些update undo日志以及被打了删除标记的记录后，有一个后台运行的purge线程会把它们真正的删除掉。</p><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> mysql知识 </category>
          
          <category> mvcc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> mvcc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql explain简介</title>
      <link href="/posts/9aa2b4bd/"/>
      <url>/posts/9aa2b4bd/</url>
      
        <content type="html"><![CDATA[<blockquote><p>那时的我们<br>关于文学<br>关于爱情<br>关于穿越世界的旅行</p><p>如今我们深夜饮酒<br>杯子碰到一起<br>都是梦破碎的声音</p><p>—— 北岛《波兰来客》</p></blockquote><h1 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h1><p>explain用于mysql的调优是有好处的，所以本篇做简单参数介绍和使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT 1;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><p>如上面例子，在mysql客户端的查询语句前加explain可以查看执行计划，每一列都有其含义，我接下来做简单句记录。</p><table><thead><tr><th>列名</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在一个大查询里，每个select关键字对应一个唯一id，但有些子查询会被优化成连接查询，而连接查询会共用一个id，所以不能仅仅判断查询语句select的个数来判断id数。</td></tr><tr><td>select_type</td><td>select关键字对应的查询类型，有专门分类，后面会讲</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区信息</td></tr><tr><td>type</td><td>针对单表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际上用到的索引</td></tr><tr><td>key_len</td><td>实际使用的索引长度</td></tr><tr><td>ref</td><td>索引用等值查询时，与索引等值匹配的对象信息</td></tr><tr><td>rows</td><td>预估需要读的记录数</td></tr><tr><td>filtered</td><td>经过搜索条件过滤后剩余记录的百分比</td></tr><tr><td>Extra</td><td>额外信息，官网有很多，这里介绍几种重要的</td></tr></tbody></table><h1 id="id"><a href="#id" class="headerlink" title="id"></a>id</h1><p>关于id主要有三种情况</p><ol><li>简单一个select<blockquote><p>select * from t1;</p></blockquote></li><li>子查询<blockquote><p>select * from t1 where c1 in (select c2 from t2);</p></blockquote></li><li>union<blockquote><p>select * from t1 union select * from t2</p></blockquote></li></ol><h2 id="简单一个select"><a href="#简单一个select" class="headerlink" title="简单一个select"></a>简单一个select</h2><p>第一种情况，只会有一个id</p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询本身有几种：</p><ol><li>where子查询：需要看优化器是否会优化</li><li>from子查询：子查询会变成一张临时表，最终也只会有一个id</li><li>exists子查询：会有两个id，看下图<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t_sqoop_web where exists (select * from t_sqoop_web);    </span><br><span class="line">+----+-------------+-------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table       | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | t_sqoop_web | NULL       | ALL   | NULL          | NULL    | NULL    | NULL |   19 |   100.00 | NULL        |</span><br><span class="line">|  2 | SUBQUERY    | t_sqoop_web | NULL       | index | NULL          | PRIMARY | 1534    | NULL |   19 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure></li></ol><p>where子查询需要分两种情况：</p><h3 id="优化器不优化成连接查询"><a href="#优化器不优化成连接查询" class="headerlink" title="优化器不优化成连接查询"></a>优化器不优化成连接查询</h3><p>这种情况，会出现两个id：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &apos;a&apos;;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 9688 |   100.00 | Using where |</span><br><span class="line">|  2 | SUBQUERY    | s2    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9954 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">2 rows in set, 1 warning (0.02 sec)</span><br></pre></td></tr></table></figure><h3 id="优化器优化成连接查询"><a href="#优化器优化成连接查询" class="headerlink" title="优化器优化成连接查询"></a>优化器优化成连接查询</h3><p>这种情况，只会出现一个id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2 WHERE common_field = &apos;a&apos;);</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra                        |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ALL  | idx_key3      | NULL     | NULL    | NULL              | 9954 |    10.00 | Using where; Start temporary |</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s2.key3 |    1 |   100.00 | End temporary                |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><h2 id="union语句"><a href="#union语句" class="headerlink" title="union语句"></a>union语句</h2><p>union情况需要解释一番，看下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t_sqoop_web union select * from t_sqoop_web_test; </span><br><span class="line">+----+--------------+------------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">| id | select_type  | table            | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |</span><br><span class="line">+----+--------------+------------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">|  1 | PRIMARY      | t_sqoop_web      | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   19 |   100.00 | NULL            |</span><br><span class="line">|  2 | UNION        | t_sqoop_web_test | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    6 |   100.00 | NULL            |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt;       | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |</span><br><span class="line">+----+--------------+------------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">3 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure><p>我们看到除了1，2两个id，还出现了null的情况，这是因为union会涉及去重，而<code>在mysql中的去重会生成临时表用来去重</code>，所以null id的那一行会生一个名为&lt;union1,2&gt;的临时表</p><h1 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h1><p>每个select查询都会对应有这个select的类型，在explain中就用select_type做展示，主要的select_type有：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>SIMPLE</td><td>不包含子查询和union的查询</td></tr><tr><td>PRIMARY</td><td>包含union、unionAll、子查询的最左边查询的select_type为PRIMARY</td></tr><tr><td>UNION</td><td>包含union、unionAll，且除了PRIMARY外的其他类型</td></tr><tr><td>UNION RESULT</td><td>Result of a UNION</td></tr><tr><td>SUBQUERY</td><td>First SELECT in subquery</td></tr><tr><td>DEPENDENT SUBQUERY</td><td>First SELECT in subquery, dependent on outer query</td></tr><tr><td>DEPENDENT UNION</td><td>Second or later SELECT statement in a UNION, dependent on outer query</td></tr><tr><td>DERIVED</td><td>Derived table</td></tr><tr><td>MATERIALIZED</td><td>Materialized subquery</td></tr><tr><td>UNCACHEABLE SUBQUERY</td><td>A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td></tr><tr><td>UNCACHEABLE UNION</td><td>The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td></tr></tbody></table><h2 id="SIMPLE"><a href="#SIMPLE" class="headerlink" title="SIMPLE"></a>SIMPLE</h2><p>只要不包含子查询和union的查询都算是SIMPLE类型，这种类型是最简单的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t_sqoop_web;</span><br><span class="line">+----+-------------+-------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table       | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | t_sqoop_web | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   19 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure><blockquote><p>连接查询也是属于SIMPLE类型</p></blockquote><h2 id="PRIMARY"><a href="#PRIMARY" class="headerlink" title="PRIMARY"></a>PRIMARY</h2><p>由几个小查询组成的查询语句，最左边的查询select_type就是PRIMARY：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t_sqoop_web union select * from t_sqoop_web_test; </span><br><span class="line">+----+--------------+------------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">| id | select_type  | table            | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |</span><br><span class="line">+----+--------------+------------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">|  1 | PRIMARY      | t_sqoop_web      | NULL       | ALL  | NULL          | NULL | NULL    | NULL |   19 |   100.00 | NULL            |</span><br><span class="line">|  2 | UNION        | t_sqoop_web_test | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    6 |   100.00 | NULL            |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt;       | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |</span><br><span class="line">+----+--------------+------------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">3 rows in set (0.02 sec)</span><br></pre></td></tr></table></figure><h2 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h2><p>包含union和unionAll的除了最左边为PRIMARY外，其他的为UNION，可以看上图</p><h2 id="UNION-RESULT"><a href="#UNION-RESULT" class="headerlink" title="UNION RESULT"></a>UNION RESULT</h2><p>用于union的临时表去重，上表 id为NULL的那行就是</p><h2 id="SUBQUERY"><a href="#SUBQUERY" class="headerlink" title="SUBQUERY"></a>SUBQUERY</h2><p>如果子查询满足以下两种情况：</p><ol><li>不能优化成join语句</li><li>不是相关子查询，并且子查询被物化</li></ol><p>那么子查询的第一个select 就是SUBQUERY：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 = &apos;a&apos;;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 9688 |   100.00 | Using where |</span><br><span class="line">|  2 | SUBQUERY    | s2    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9954 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">2 rows in set, 1 warning (0.02 sec)</span><br></pre></td></tr></table></figure><p>上面条件说到会被物化，所以子查询只出现只执行一次</p><p>什么是相关子查询和不相关子查询：</p><blockquote><p>相关子查询：子查询需要依赖外查询进行查询——如果子查询where语句用到外查询的字段，则可以认为是相关子查询<br>不相关子查询：子查询不需要依赖外查询进行查询——如果子查询是一个单独的查询语句，不依赖任何外部表的字段，则可以认为是不相关子查询</p></blockquote><h2 id="DEPENDENT-SUBQUERY"><a href="#DEPENDENT-SUBQUERY" class="headerlink" title="DEPENDENT SUBQUERY"></a>DEPENDENT SUBQUERY</h2><p>如果满足以下两个情况：</p><ol><li>不能优化成join语句</li><li>子查询是相关子查询</li></ol><p>则子查询的第一个select关键字为 DEPENDENT SUBQUERY：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; explain select * from t_sqoop_web where mysql_db_tb in (select mysql_db_tb from t_sqoop_web_test where t_sqoop_web.hive_db = t_sqoop_web_test.hive_db) or sqoop_type = &apos;&apos;;</span><br><span class="line">+----+--------------------+------------------+------------+----------------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type        | table            | partitions | type           | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+--------------------+------------------+------------+----------------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY            | t_sqoop_web      | NULL       | ALL            | NULL          | NULL    | NULL    | NULL |   19 |   100.00 | Using where |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | t_sqoop_web_test | NULL       | index_subquery | PRIMARY       | PRIMARY | 767     | func |    1 |    16.67 | Using where |</span><br><span class="line">+----+--------------------+------------------+------------+----------------+---------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">2 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure><h2 id="DEPENDENT-UNION"><a href="#DEPENDENT-UNION" class="headerlink" title="DEPENDENT UNION"></a>DEPENDENT UNION</h2><p>满足以下条件:</p><ol><li>UNION和UNION ALL的子查询</li><li>每个子查询都是相关子查询</li></ol><p>则除了最左边为DEPENDENT SUBQUERY外，其他的都为DEPENDENT UNION：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 = &apos;a&apos; UNION SELECT key1 FROM s1 WHERE key1 = &apos;b&apos;);</span><br><span class="line">+----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br><span class="line">| id | select_type        | table      | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra                    |</span><br><span class="line">+----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br><span class="line">|  1 | PRIMARY            | s1         | NULL       | ALL  | NULL          | NULL     | NULL    | NULL  | 9688 |   100.00 | Using where              |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | s2         | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |   12 |   100.00 | Using where; Using index |</span><br><span class="line">|  3 | DEPENDENT UNION    | s1         | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | Using where; Using index |</span><br><span class="line">| NULL | UNION RESULT       | &lt;union2,3&gt; | NULL       | ALL  | NULL          | NULL     | NULL    | NULL  | NULL |     NULL | Using temporary          |</span><br><span class="line">+----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br><span class="line">4 rows in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure><h2 id="DERIVED"><a href="#DERIVED" class="headerlink" title="DERIVED"></a>DERIVED</h2><p>对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的select_type就是DERIVED</p><h2 id="MATERIALIZED"><a href="#MATERIALIZED" class="headerlink" title="MATERIALIZED"></a>MATERIALIZED</h2><p>当查询优化器在执行包含子查询的语句时，选择将<code>子查询物化之后与外层查询进行连接查询</code>时，该子查询对应的select_type属性就是MATERIALIZED：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2);</span><br><span class="line">+----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+</span><br><span class="line">| id | select_type  | table       | partitions | type   | possible_keys | key        | key_len | ref               | rows | filtered | Extra       |</span><br><span class="line">+----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE       | s1          | NULL       | ALL    | idx_key1      | NULL       | NULL    | NULL              | 9688 |   100.00 | Using where |</span><br><span class="line">|  1 | SIMPLE       | &lt;subquery2&gt; | NULL       | eq_ref | &lt;auto_key&gt;    | &lt;auto_key&gt; | 303     | xiaohaizi.s1.key1 |    1 |   100.00 | NULL        |</span><br><span class="line">|  2 | MATERIALIZED | s2          | NULL       | index  | idx_key1      | idx_key1   | 303     | NULL              | 9954 |   100.00 | Using index |</span><br><span class="line">+----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+</span><br><span class="line">3 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure><h1 id="table"><a href="#table" class="headerlink" title="table"></a>table</h1><p>表示使用到的表名</p><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>type代表访问的方式，主要有以下类型：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>system</td><td></td></tr><tr><td>const</td><td></td></tr><tr><td>eq_ref</td><td></td></tr><tr><td>ref</td><td></td></tr><tr><td>fulltext</td><td></td></tr><tr><td>ref_or_null</td><td></td></tr><tr><td>index_merge</td><td></td></tr><tr><td>unique_subquery</td><td></td></tr><tr><td>index_subquery</td><td></td></tr><tr><td>range</td><td></td></tr><tr><td>index</td><td></td></tr><tr><td>ALL</td><td></td></tr></tbody></table><p>效率的快慢排序：<br>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p>满足条件：</p><ol><li>表中只有一条记录</li><li>存储引擎统计数据是精确的，如myisam（注：innodb不是精确统计）</li></ol><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>满足条件：</p><ol><li>根据主键或者唯一二级索引列与常数进行等值匹配</li></ol><h3 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h3><p>满足条件：</p><ol><li>连接查询</li><li>被驱动表通过主键或者唯一二级索引列进行等值匹配的，被驱动表会显示eq_ref</li></ol><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p>满足条件：</p><ol><li>普通二级索引列与常量等值匹配查询</li></ol><h3 id="fulltext"><a href="#fulltext" class="headerlink" title="fulltext"></a>fulltext</h3><p>满足条件：</p><ol><li>用导全文索引列进行查询</li></ol><h3 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h3><p>满足条件：</p><ol><li>二级索引等值匹配</li><li>该列值可以为null</li></ol><h3 id="index-merge"><a href="#index-merge" class="headerlink" title="index_merge"></a>index_merge</h3><p>满足条件：</p><ol><li>索引为单独索引</li><li>多个索引列进行查询</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; explain select * from t_articles_info_0 where u_tags = &apos;&apos; or oid = &apos;&apos;;  </span><br><span class="line">+----+-------------+-------------------+------------+-------------+--------------------+--------------------+---------+------+--------+----------+----------------------------------------------+</span><br><span class="line">| id | select_type | table             | partitions | type        | possible_keys      | key                | key_len | ref  | rows   | filtered | Extra                                        |</span><br><span class="line">+----+-------------+-------------------+------------+-------------+--------------------+--------------------+---------+------+--------+----------+----------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | t_articles_info_0 | NULL       | index_merge | idx_oid,idx_u_tags | idx_u_tags,idx_oid | 1,98    | NULL | 101073 |   100.00 | Using union(idx_u_tags,idx_oid); Using where |</span><br><span class="line">+----+-------------+-------------------+------------+-------------+--------------------+--------------------+---------+------+--------+----------+----------------------------------------------+</span><br><span class="line">1 row in set (0.03 sec)</span><br></pre></td></tr></table></figure><p>u_tags 和 oid 是单独的索引列</p><h3 id="unique-subquery"><a href="#unique-subquery" class="headerlink" title="unique_subquery"></a>unique_subquery</h3><p>满足条件：</p><ol><li>包含in子查询</li><li>in子查询转换为EXISTS子查询</li><li>子查询返回的是主键</li></ol><h3 id="index-subquery"><a href="#index-subquery" class="headerlink" title="index_subquery"></a>index_subquery</h3><p>满足条件：</p><ol><li>包含in子查询</li><li>in子查询转换为EXISTS子查询</li><li>子查询返回的是普通索引</li></ol><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>满足条件：</p><ol><li>使用索引获取范围区间：</li></ol><blockquote><p>EXPLAIN SELECT * FROM s1 WHERE key1 IN (‘a’, ‘b’, ‘c’);<br>EXPLAIN SELECT * FROM s1 WHERE key1 &gt; ‘a’ AND key1 &lt; ‘b’;</p></blockquote><h3 id="index"><a href="#index" class="headerlink" title="index"></a>index</h3><p>满足条件：</p><ol><li>表中有联合索引</li><li>条件语句和筛选语句都是联合索引中的列：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 = &apos;a&apos;;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                    |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | index | NULL          | idx_key_part | 909     | NULL | 9688 |    10.00 | Using where; Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure><p>key_part2和key_part3是联合索引，where语句用到key_part3，select语句用到key_part2</p><h3 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h3><p>满足条件：</p><ol><li>全表扫描</li></ol><h2 id="possible-keys和key"><a href="#possible-keys和key" class="headerlink" title="possible_keys和key"></a>possible_keys和key</h2><p>possible_keys：可能用到的索引<br>key：实际用到的索引</p><p>possible_key越多，查询优化器计算查询成本花费时间越多，所以尽可能删除无用索引</p><h2 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h2><p>用到的索引的最大长度，这个计算涉及到页的概念，所以暂时不分析</p><h2 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h2><p>指的是当索引列进行等值查询时，和索引列进行等值查询的是个啥玩意：<br>即type类型为：const、eq_ref、ref、ref_or_null、unique_subquery、index_subquery时，对应的索引列和什么玩意进行匹配</p><p>主要有几种情况：</p><ol><li><p>和常量进行匹配的，ref会显示const</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 = &apos;a&apos;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure></li><li><p>连接查询用主键进行等值匹配的，ref显示的是s1表的id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id = s2.id;</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref             | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL            | 9688 |   100.00 | NULL  |</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | xiaohaizi.s1.id |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>用函数对列进行处理后做等值查询的，ref显示的是func<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s2.key1 = UPPER(s1.key1);</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL     | NULL    | NULL | 9688 |   100.00 | NULL                  |</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | func |    1 |   100.00 | Using index condition |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure></li></ol><h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>预计要扫描的行数</p><h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>估计出需要访问的行数的百分比，最后所扫描的行数为 <code>row*filtered</code></p><h2 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h2><p>主要介绍几个常见Extra</p><h3 id="No-tables-used"><a href="#No-tables-used" class="headerlink" title="No tables used"></a>No tables used</h3><p>查询语句没有from子句时</p><h3 id="Impossible-WHERE"><a href="#Impossible-WHERE" class="headerlink" title="Impossible WHERE"></a>Impossible WHERE</h3><p>查询语句的where子句永远为FALSE时</p><h3 id="No-matching-min-max-row"><a href="#No-matching-min-max-row" class="headerlink" title="No matching min/max row"></a>No matching min/max row</h3><p>查询语句中有max和min聚集函数，但没有符合where子句搜索条件记录时</p><h3 id="Using-index"><a href="#Using-index" class="headerlink" title="Using index"></a>Using index</h3><p>当使用索引覆盖的情况加，会显示</p><h3 id="Using-index-condition"><a href="#Using-index-condition" class="headerlink" title="Using index condition"></a>Using index condition</h3><p>搜索条件出现索引，但不能使用索引时，如：</p><blockquote><p>select * from t1 where key1 &gt; ‘z’ and key1 like ‘%x’;</p></blockquote><h3 id="Using-where"><a href="#Using-where" class="headerlink" title="Using where"></a>Using where</h3><p>全表扫描 + 使用where子句有针对该表的搜索条件，会出现</p><h3 id="Using-join-buffer-（Block-Nested-Loop）"><a href="#Using-join-buffer-（Block-Nested-Loop）" class="headerlink" title="Using join buffer （Block Nested Loop）"></a>Using join buffer （Block Nested Loop）</h3><p>连接查询中，如果驱动表无法用索引加快访问，mysql会分配join buffer的内存加快查询速度</p><h3 id="Not-exists"><a href="#Not-exists" class="headerlink" title="Not exists"></a>Not exists</h3><p>连接查询中，驱动表中有 = null语句，但该列不允许为null时</p><h3 id="Zero-limit"><a href="#Zero-limit" class="headerlink" title="Zero limit"></a>Zero limit</h3><p>limit 0时</p><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> mysql知识 </category>
          
          <category> explain简介 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> explain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人学习阶段总结及博客未来计划</title>
      <link href="/posts/c2af516c/"/>
      <url>/posts/c2af516c/</url>
      
        <content type="html"><![CDATA[<p>近一个月，我坚持每天早上7点左右起床，并通过看各专栏和书籍学习技术，晚上如果不用加班，我也会去学习算法或者一些新技术的基本概念。如今月底了，回顾这一个月，我发现自己的技术能力确实有些许提高，整体而言，整个过程与我的预期虽然还有差距，但自己的坚持和努力还是有明显成效，这个值得肯定。</p><p>然而，抛开自己与女友去玩耍约会的时间，抛开因为工作原因必须加班坚守阵地的时间，我在学习上的时间其实并不算少，但我却感觉到自己并没有真正吸收全部知识。</p><p>当然，如果吸收全部知识这个前提本身是无法完成的，那我不会纠结，而我纠结就在于这个前提可实现，实现的方法论有很多，并且我在整个学习过程中也进行了不少总结，所以基于这个点，我要把自己的方法论结合自身情况，做一个简单的规划和总结。</p><h2 id="学习感悟"><a href="#学习感悟" class="headerlink" title="学习感悟"></a>学习感悟</h2><p>首先我要先做一个深刻的反省，吾日三省吾身，好的总结习惯，会让我们明白自身问题，并做到真正意义上的进步，而不是停留在意淫阶段。</p><p>在整个学习的阶段，我曾迷茫和焦虑过，迷茫于这么多知识我该从哪入手，焦虑于工作没有完成我该如何有效规划时间，去学习新知识，巩固旧概念。所以有段时间，我陷入了一学习就焦虑的状况，为啥呀？因为感觉学着碗里的，盼着锅里的，想着看看mysql底层实现，又觉得spark源码还有那么多没读过，另一边工作上flink又是刚接触，心底没有一个整体概念，怎么也得先深入学习下flink吧。如此这般循环，最后沦入深深无力感中，啥也没干好，时间却呼啦啦消逝。</p><p>这是一个大问题。</p><p>另外一边，学习成效上，我没有认真去执行高效学习的理论。何为高效学习的理论？就个人阅读的书籍总结而言，就是围绕<code>记忆和学习方法</code>做的一些优化手段。这些手段在普通人眼里是耗费时间的，于是没有去执行和遵守，最后却发现自己现在的行为才是冤大头。譬如我，我知道艾宾浩斯遗忘曲线，我知道总结并不等于了解，所以正确的学习姿势应该是：</p><blockquote><p>把每天学习的知识总结，并根据遗忘曲线的遗忘效率进行及时有效的复习，直到知识点巩固，最后再做命题测验，深入了解知识点内部原理。  </p></blockquote><p>而我呢，没有这么做，因为我在想，总结和复习是耗费时间的，我要做的应该是不断学习新知识，或者想着在一段时间的专题学习后，再回顾总结。然而，现实总比预期残酷，命运的捉弄不在乎who are u，绝大部分人的记忆都离不开遗忘曲线的作用范围，所以不及时复习的学习，只会花费更多时间才能巩固和记忆。</p><h2 id="个人问题解决方案"><a href="#个人问题解决方案" class="headerlink" title="个人问题解决方案"></a>个人问题解决方案</h2><p>发现了问题，那就得解决问题。</p><h3 id="学习焦虑解决方案"><a href="#学习焦虑解决方案" class="headerlink" title="学习焦虑解决方案"></a>学习焦虑解决方案</h3><p>焦虑的产生核心点在<code>不可掌握</code>，不可掌握又分为两点，其一为要做的事情太多，其二为没有事情可做。事情太多则头绪混乱，不知所措。无事可做则担心淘汰，无法生存。而不可掌握的感知，就在注意力。如果把注意力集中在做，而不是需要做的，那焦虑就会不攻而破。</p><p>所以解决方案很简单，两个问题两个解决的点</p><h4 id="解决一：攻破精神陷阱"><a href="#解决一：攻破精神陷阱" class="headerlink" title="解决一：攻破精神陷阱"></a>解决一：攻破精神陷阱</h4><p>我们要明白焦虑是精神陷阱，是人给自己带来的精神压力，最近明星自杀和明星猝死的新闻越发增多，这让我明白，学习与进步是必须要做的，但不能牺牲健康，精神压力过大，也是不健康的表现。</p><p>顶着巨大精神压力去生活，去工作，去进步，它的效率是<code>事倍功半</code>的，那是自我安慰的努力，毫成效可言。此时如果放下执念，放平心态，做一个简单的休息，整装待续，精神焕发，来个深呼吸，感受生命气息，再重新起步，才会明白努力的意义。</p><p>在这个方案中，我想特别提一个前提，那就是：<code>精神的丰富是必要的</code>。举个例子，我叫你休息，你去刷抖音，这在你眼里是休息，但却是另一种注意力耗散，会让你更加疲惫。那你问我，你该如何休息，我说，我不知道，只有你知道，然后你说，你知道的就是刷抖音，但其实<code>这里所说的你，是经过丰富阅读，丰富人生经历，丰富思考造就的你</code>，相比幼稚的你，这时的你是智慧的，了解自己，了解世界，了解心与灵魂的需求。相信我，这时的你不会把刷抖音当作休息的唯一途径。</p><p>所以一个人在<code>他的精神生活是丰富的前提下</code>，他才会真正明白自己所想要的，也才会明白什么是休息，什么是人生，什么是当下最重要的事情。</p><p>于是，我提倡，不要因为工作泯灭人性，不要因为学习忘记天的蓝，不要因为害怕躲避生命的风险。</p><h4 id="解决二：把注意力放到执行上"><a href="#解决二：把注意力放到执行上" class="headerlink" title="解决二：把注意力放到执行上"></a>解决二：把注意力放到执行上</h4><p>如果要把注意力放执行上，必须有个前提 —— 我知道该做什么。</p><p>所以关于这个的解决方案，我给自己设立了四象限的学习维度。分别是：</p><ol><li>简单的</li><li>复杂的</li><li>重要的</li><li>紧急的</li></ol><p>优先级应该是这样：<br>紧急 &gt; 简单 &gt;= 重要 &gt;= 复杂</p><p>然后把当前的事情归类，做一个学习规划。在规划的过程中，必须要认真谨慎，考虑各种不同因素和情况。做好规划后，坚定执行，不考虑规划外的事情，只考虑怎么把当前事情做好，如此这般，注意力集中就会少焦虑的产生。</p><h3 id="学习理论的实践方案"><a href="#学习理论的实践方案" class="headerlink" title="学习理论的实践方案"></a>学习理论的实践方案</h3><p>学习理论的实践，我推荐李笑来的《把时间当做朋友》和采铜的《精进》和《刻意练习》，这三本书有学习的理论，我这就不展开谈。</p><p>学习本身就是记忆和加工的过程，而记忆如果没东西，那加工啥玩意。所以记忆很重要，加工也很重要。所以关于学习理论的实践，主要有两个点需要攻破。</p><h4 id="解决一：遗忘曲线"><a href="#解决一：遗忘曲线" class="headerlink" title="解决一：遗忘曲线"></a>解决一：遗忘曲线</h4><p>遗忘曲线的核心在不同的遗忘点，进行不同程度的复习。关于复习，必须精简。我们在最初的学习阶段，会涉及很多概念去堆砌出最后的结论，而我们的复习阶段则是记忆结论。为何？因为时间有限。所以想要复习，离不开<code>总结</code>，而总结有讲究，个人认为有几个点：</p><ol><li>总结不是复制粘贴，而要把新知识和知识框架进行融合后输出</li><li>总结需要归纳，归纳需要层级，总结结论如何生成，要有简单过程</li><li>总结需要有：<blockquote><p>知识本身 + 给知识分维度（如简单、未理解、易错等） + 实践和展望（融合自身情况）</p></blockquote></li></ol><h4 id="解决二：加工方案"><a href="#解决二：加工方案" class="headerlink" title="解决二：加工方案"></a>解决二：加工方案</h4><p>当脑子有很多材料时，我们该如何进行加工，就会决定我们最后加工的效率和东西的质地。</p><h5 id="知识体系构建"><a href="#知识体系构建" class="headerlink" title="知识体系构建"></a>知识体系构建</h5><p>加工的过程离不开知识体系的构建，这个知识体系不是指专业的知识体系，而是上文所讲的，<code>体验</code>所产生的知识体系，这个知识体系会包含各个学科的知识，并且夹杂自身独特的人生经历和思考。丰富的知识体系会给大脑提供源源不断的灵感，所以专业并非好，而我们所说专业好，这不过是因为在人有限精力和注意力下的最好解决方案。</p><p>但知识体系这玩意不是短时间能搞定的，这个需要时间的积累，需要注意力的堆砌，当我们清楚，我们所作的每一次学习都会为日后提供构建知识体系的原材料时，我们每做的一件事都会谨慎和深邃许多。</p><h5 id="一段时间只做一件事情"><a href="#一段时间只做一件事情" class="headerlink" title="一段时间只做一件事情"></a>一段时间只做一件事情</h5><p>在上文的学习规划中，我没有提到一个很重要的点，叫做<code>一段时间只做一件事情</code>。这是我结合刻意练习和自身出现问题所做的总结。</p><p>前段时间我经历了一个星期做几个知识点学习的规划，但整体下来，我好像都没做好，并且产生焦虑。后来我放下追求完美的念头后，我根据优先级排序，规定了一段时间只做一件事情，我发现焦虑消失了，并且学习更加深入。</p><p>在学习领域，有两个区域需要注意，一个叫展示区，一个叫学习区。展示区是你利用现有知识去解决问题的阶段，而学习区，则是刻意练习中说到的有目的性学习。在刻意练习中讲到的<code>有目的性去学习</code>意思是，带着问题，带着规划去学习。这个过程，我们发现，有目的性学习就会有反馈，有反馈就会有成功与失败，有失败就能总结然后进步。这明显是个正向循环。</p><p>有目的性学习和一段时间只做一件事情的好处很明显，因为它们能让你深入理解一个知识点。在你规划一段时间有目的性学习的时候，一定要找到每个知识点的核心内容，譬如：明白spark的运行原理，如果要你设计，或者遇到类似知识点问题，你就能很快速解决。</p><h2 id="博客规划"><a href="#博客规划" class="headerlink" title="博客规划"></a>博客规划</h2><p>综上所述，我分析了自身问题，并提供解决方案，最后我想利用博客做一个简单规划和实践。每天我会把自己的技术学习进行总结汇报，记录到博客。但这个过程中，总会出现电脑不在身边或者今天因为某些原因没有学习的情况，如果是因为没有学习当天则不做记录，如果因为电脑不在，我会找时间上传到博客。</p><p>总结规划：</p><ol><li>写每日博客</li><li>阶段性学习后，做整体学习总结</li><li>每天写博客前复习上一篇和上上篇博客内容</li></ol><p>以上，愿自己坚持到完成个人目标</p><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 个人总结 </category>
          
          <category> 阶段总结 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习总结 </tag>
            
            <tag> 个人总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm知识汇总</title>
      <link href="/posts/de2d575e/"/>
      <url>/posts/de2d575e/</url>
      
        <content type="html"><![CDATA[<p>这个栏目主要是把各jvm的知识模块进行链接汇总，方便自己的学习与复习</p><h1 id="jvm的内存结构"><a href="#jvm的内存结构" class="headerlink" title="jvm的内存结构"></a>jvm的内存结构</h1><h1 id="jvm的oom汇总"><a href="#jvm的oom汇总" class="headerlink" title="jvm的oom汇总"></a>jvm的oom汇总</h1><h1 id="jvm的jmm是什么"><a href="#jvm的jmm是什么" class="headerlink" title="jvm的jmm是什么"></a>jvm的jmm是什么</h1><h1 id="jvm的类加载过程"><a href="#jvm的类加载过程" class="headerlink" title="jvm的类加载过程"></a>jvm的类加载过程</h1><ol><li><a href="https://www.jianshu.com/p/202f6abb229c" target="_blank" rel="noopener">java类加载过程</a></li></ol><h1 id="双亲委派机制怎么理解"><a href="#双亲委派机制怎么理解" class="headerlink" title="双亲委派机制怎么理解"></a>双亲委派机制怎么理解</h1><h1 id="类加载器的实现原理"><a href="#类加载器的实现原理" class="headerlink" title="类加载器的实现原理"></a>类加载器的实现原理</h1><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
          <category> 汇总 </category>
          
          <category> hide </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表的算法题</title>
      <link href="/posts/63112dd/"/>
      <url>/posts/63112dd/</url>
      
        <content type="html"><![CDATA[<p>记得以前刚开始学习链表，对指针和方向的定义和判断难以理解，如今经过学习再回顾，慢慢知晓学习的本质就是反人性的重复，当达到一定的重复，所有的难理解不过是茶余饭后对过去愚笨自己的无奈。</p><p>针对链表，列出几个常面试的题目，便于后续自己的复习，持续更新。</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="链表统一代码实现"><a href="#链表统一代码实现" class="headerlink" title="链表统一代码实现"></a>链表统一代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表的定义可以自行百度了解</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    Node next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Node node_v1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">        Node node_v2 = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line">        Node node_v3 = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">        Node node_v4 = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line">        Node node_v5 = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">        node_v1.next = node_v2;</span><br><span class="line">        node_v2.next = node_v3;</span><br><span class="line">        node_v3.next = node_v4;</span><br><span class="line">        node_v4.next = node_v5;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表反转"><a href="#链表反转" class="headerlink" title="链表反转"></a>链表反转</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入一个单链表，输出该链表的反转链表</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这个题目不难，链表是有指针的，把指针倒转过来就是反向链表。<br>如 1 -&gt; 2 -&gt; 3 -&gt; 4 的反向链表就是：<br>4 -&gt; 3 -&gt; 2 -&gt; 1</p><blockquote><p>核心点在：node.next = pre</p></blockquote><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linked_Revered</span></span>&#123;</span><br><span class="line">    <span class="comment">// 非递归方案</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revered</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node pre = <span class="keyword">null</span>;</span><br><span class="line">        Node next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="keyword">null</span>)&#123;</span><br><span class="line">            next = node.next;</span><br><span class="line">            node.next = pre;</span><br><span class="line">            pre = node;</span><br><span class="line">            node = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归方案</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revered_digui</span><span class="params">(Node node,Node pre)</span></span>&#123;</span><br><span class="line">        Node next = node.next;</span><br><span class="line">        node.next = pre; <span class="comment">// 核心点，只要根据这个推导即可明白</span></span><br><span class="line">        revered_digui(next,node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">revered_digui_v1</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="keyword">null</span> || node.next == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为了递归到最后一个链表结点，用于后面反转</span></span><br><span class="line">        Node nextNode = revered_digui_v1(node.next);</span><br><span class="line">        <span class="comment">// 反转链表</span></span><br><span class="line">        node.next.next = node;</span><br><span class="line">        <span class="comment">// 把当前链表进行切断</span></span><br><span class="line">        node.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求有环链表的入口结点"><a href="#求有环链表的入口结点" class="headerlink" title="求有环链表的入口结点"></a>求有环链表的入口结点</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>输入一个单链表，求他的环的入口结点</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>输入一个单链表，求环的入口，我们首先需要明确该链表是否有环，有环又该如何求入口结点，所以主要解决三个问题即可：</p><blockquote><ol><li>判断单链表是否有环</li><li>判断环的长度是多少，长度可用于协助计算入口结点</li><li>定位环的入口结点位置</li></ol></blockquote><p>话不多说，看代码马上明白每步的作用</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Linked_Round</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">Detect_Round</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">        Node fast = node;</span><br><span class="line">        Node slow = node;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        两个同时从头结点出发，一个一下走两步，一个走一步</span></span><br><span class="line"><span class="comment">        有两种情况：</span></span><br><span class="line"><span class="comment">        1、当 next 出现null的情况，说明没有环</span></span><br><span class="line"><span class="comment">        2、当 fast 和 slow 相遇了，说明有环</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">while</span>(slow.next != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(fast == slow)&#123;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算环的长度</span></span><br><span class="line">        len = <span class="number">1</span>;</span><br><span class="line">        Node currend_node = slow.next;</span><br><span class="line">        <span class="keyword">while</span>(slow.value != currend_node.value)</span><br><span class="line">            &#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                len ++;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用快慢指针，计算相遇时的结点，相遇结点就是入口结点</span></span><br><span class="line">        Node first_node = node; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">            first_node = first_node.next;</span><br><span class="line">        </span><br><span class="line">        Node second_node = node;</span><br><span class="line">        <span class="keyword">while</span>(second_node.value != first_node.value)&#123;</span><br><span class="line">            second_node = second_node.next;</span><br><span class="line">            first_node = first_node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> second_node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有序链表合并"><a href="#有序链表合并" class="headerlink" title="有序链表合并"></a>有序链表合并</h1><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>有点类似归并排序，只是归并用的是数组，这里用的是链表</p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedMixed</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Linked</span><span class="params">(Node node1,Node node2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node1 == <span class="keyword">null</span>) <span class="keyword">return</span> node2;</span><br><span class="line">        <span class="keyword">if</span>(node2 == <span class="keyword">null</span>) <span class="keyword">return</span> node1;</span><br><span class="line">                </span><br><span class="line">        Node head = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 明确思路是：</span></span><br><span class="line"><span class="comment">        * 升序的话：每一层返回的都是小的</span></span><br><span class="line"><span class="comment">        * 降序的话：每一层返回的都是大的</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="keyword">if</span>(node1.value &lt;= node2.value)&#123;</span><br><span class="line">            head = node1;</span><br><span class="line">            head.next = Linked(node1.next,node2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            head = node2;</span><br><span class="line">            head.next = Linked(node1,node2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="删除单链表倒数第n个结点"><a href="#删除单链表倒数第n个结点" class="headerlink" title="删除单链表倒数第n个结点"></a>删除单链表倒数第n个结点</h1><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这个思路和寻找入口结点的链表题目基本一致。用到快慢指针。代码逻辑主要两步：</p><blockquote><ol><li>用快慢指针方法确定需要删除的结点</li><li>如何删除结点</li></ol></blockquote><p>但这里需要考虑一种情况：</p><blockquote><p>如果只有一个结点，需要怎么处理</p></blockquote><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedLast</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">Linked</span><span class="params">(Node node,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        Node first = node;</span><br><span class="line">        Node sencond = node;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一个结点的情况</span></span><br><span class="line">        <span class="keyword">if</span>(first == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> node.next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 1.确定删除结点位置</span></span><br><span class="line">        <span class="keyword">while</span>(first!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            sencond = sencond.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除结点</span></span><br><span class="line">        sencond.next = sencond.next.next;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java OOM 各情况分析</title>
      <link href="/posts/50474098/"/>
      <url>/posts/50474098/</url>
      
        <content type="html"><![CDATA[<p>最近在学习jvm，结合线上任务，最常见的就是java的oom，为了快速解决生产环境出现的oom问题，特此总结各oom解决方案  </p><p>本文基于jdk8版本探讨oom情况，不同于jdk8以前版本，jdk8用元空间代替永久代，所以不会有永久代的oom报错，取而代之的是元空间的oom报错。</p><p>这里记录一个小知识，我们常说的方法区其实是逻辑概念，永久代和元空间是实现这个概念的具体方案，所以其实可以把元空间当作是新的方法区实现。元空间利用的是直接内存，但会进行gc</p><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
          <category> jvm oom </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> java </tag>
            
            <tag> hide </tag>
            
            <tag> oom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer习题归纳（持续更新）</title>
      <link href="/posts/a95aad52/"/>
      <url>/posts/a95aad52/</url>
      
        <content type="html"><![CDATA[<p>参考：<br><a href="https://www.cnblogs.com/yongh/p/9637260.html" target="_blank" rel="noopener">剑指offer java实现</a><br><a href="https://study.163.com/course/introduction.htm?courseId=1002942008#/courseDetail?tab=1" target="_blank" rel="noopener">课程列表 可以当作学习方向</a></p><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 剑指offer归纳 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 剑指offer </tag>
            
            <tag> hide </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优先级队列 java实现</title>
      <link href="/posts/323450f/"/>
      <url>/posts/323450f/</url>
      
        <content type="html"><![CDATA[<p>最近有一个同事走了，去了美团风控，这几个月的面试，他手里拿了头条、携程的offer，羡慕之余，我还向他取了经。整体而言，他和我说，除了项目的介绍，对大数据框架的认识以外，特别需要关注的就是算法和数据结构。然而，自己在这方面的造诣确实很少，所以后续时间，我会按数据结构类型（着重链表、树等）刷题，并且总结到博客中。</p><p>回想和他的交流过程，印象里他提到了 <strong><em>优先级队列</em></strong> ，当时并不知道什么东西，回来一看，我才发现，这不就是堆排序的变种嘛。因为最近刚刷过堆排序，所以对实现方式了如指掌。</p><p>正当我大展身手，准备手写一番时，我无意之间看到java的优先级队列底层的源码实现，我那一个震惊，竟然有如此巧妙和简单的实现方式，刹那间，我对java那岂是简单的心生爱恋，简直爱不释手。就此，我便准备用java实现优先级队列。</p><h1 id="什么是优先级队列"><a href="#什么是优先级队列" class="headerlink" title="什么是优先级队列"></a>什么是优先级队列</h1><p>优先级队列的理解很简单，把这个词拆分成两个名词，马上就能明白，分别是 优先级 + 队列。</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>优先级指的是按照特定的排序算法，或者说比较算法，来实现队列元素的顺序提取。最简单的就是按数字的升序进行元素提取。所以核心点就在于</p><blockquote><p>如何确保 <strong><em>在乱序添加元素的前提下，还能有序的提取元素</em></strong></p></blockquote><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列就是一个数据结构，什么数据结构呢？</p><blockquote><p>元素按照顺序，先进先出的数据结构。具体实现方式可以用链表和数组。</p></blockquote><p>就像排队吃饭一样，排到前面的先吃饭，排到最后就没饭吃是一个道理。</p><h1 id="java实现及解释"><a href="#java实现及解释" class="headerlink" title="java实现及解释"></a>java实现及解释</h1><h2 id="实现优先级队列的算法"><a href="#实现优先级队列的算法" class="headerlink" title="实现优先级队列的算法"></a>实现优先级队列的算法</h2><p>其实实现优先级算法有挺多，最简单的就是每次添加元素就遍历队列，接着遍历出来的每个元素和添加的元素进行比较，然后把当前元素插入合适的位置。</p><p>但这种实现方式的时间复杂度为 O(n)，因为涉及到一个for循环。对于数据结构的实现，我们要优先考虑时间复杂度。那有啥好办法木有，有的，堆排序在众多排序中，时间复杂度是比较稳定的，为logn。所以对于优先级队列的默认实现，用到的是堆排序。（什么是堆排序，可以看我博客的 <a href="http://jskblog.xyz/posts/7ad6c44f/">十大排序中的堆排序</a>）</p><h2 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h2><p>关于java代码实现，主要两个点：</p><blockquote><ol><li>添加元素：需要元素上推构建堆逻辑</li><li>取出元素：需要元素下推构建堆逻辑</li></ol></blockquote><p>以上面两个为核心，进行逻辑实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">priQueue</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size_default = <span class="number">0</span>;</span><br><span class="line">    Object[] queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> default_size = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">priQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[default_size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> size,<span class="keyword">int</span> element)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 构建小顶堆</span></span><br><span class="line">        Comparable&lt;Integer&gt; element_com = element; <span class="comment">//把element变成可比较对象</span></span><br><span class="line">        <span class="keyword">while</span>(size&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> index = (size-<span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 取出父节点的下标</span></span><br><span class="line">            Object parent = queue[index]; <span class="comment">// 父节点的值</span></span><br><span class="line">            <span class="keyword">if</span>(element_com.compareTo((Integer) parent) &gt;= <span class="number">0</span>) <span class="comment">//父节点和当前元素进行比较</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 如果当前元素比父节点大，则跳出循环，直接添加到末尾</span></span><br><span class="line">            queue[size] = parent; <span class="comment">// 如果没有跳出循环，说明当前元素比父节点小，父节点放最后</span></span><br><span class="line">            size = index; <span class="comment">// size减少，用于上面index上推找父节点的父节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue[size] = element;<span class="comment">//把添加元素添加到queue中</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> element)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = size_default; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span>(size&gt;=queue.length)&#123;<span class="comment">//延长数组</span></span><br><span class="line">            queue = Arrays.copyOf(queue,size+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        size_default = size+<span class="number">1</span>;<span class="comment">//因为添加元素了，所以size+1</span></span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">            queue[<span class="number">0</span>] = element;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            siftUp(size,element);<span class="comment">//上推构建顶堆</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> size,<span class="keyword">int</span> element)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 构建小顶堆，构建顶堆的过程，会直接替换掉原 size 下标的值</span></span><br><span class="line">        <span class="keyword">int</span> half = size_default &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 运算符运算 ：size/2 的意思 一半值</span></span><br><span class="line">        <span class="keyword">while</span>(size &lt; half)&#123;</span><br><span class="line">            <span class="keyword">int</span> child = (size &lt;&lt; <span class="number">1</span> ) + <span class="number">1</span>; <span class="comment">// size*2 + 1 size下标节点的左子节点</span></span><br><span class="line">            Object child_element = queue[child]; <span class="comment">// 左子节点</span></span><br><span class="line">            <span class="keyword">int</span> right = child+<span class="number">1</span>; <span class="comment">// 右子节点</span></span><br><span class="line">            <span class="keyword">if</span>(child++ &lt; half &amp;&amp;</span><br><span class="line">                    ((Comparable&lt;Integer&gt;)child_element).compareTo((Integer)queue[right]) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                child_element = queue[child = right]; <span class="comment">// 比较左右子节点哪个更小</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(((Comparable)element).compareTo(child_element) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//如果element 比 子节点还要小，不需要后续工作了，直接把element赋值给size下标</span></span><br><span class="line">            &#125;</span><br><span class="line">            queue[size] = child_element; <span class="comment">// 如果上面没有跳出循环，说明子节点更小，把子节点值赋给size下标</span></span><br><span class="line">            size = child;<span class="comment">//size变成子节点下标，继续比较子节点的子节点大小，下推比较</span></span><br><span class="line">        &#125;</span><br><span class="line">        queue[size] = element;<span class="comment">//把element赋值给size</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">poll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size_default == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">//如果size没有了 直接返回null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> s = -- size_default;<span class="comment">//s为下标值，size_default是数组长度，比下标多一位</span></span><br><span class="line">        Object result = queue[<span class="number">0</span>];<span class="comment">//取出首位</span></span><br><span class="line">        Object x = queue[s];<span class="comment">//取出末尾位</span></span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(s &gt; <span class="number">0</span>)</span><br><span class="line">            siftDown(<span class="number">0</span>,(Integer) x);<span class="comment">//进行重构堆逻辑</span></span><br><span class="line">        <span class="keyword">return</span>  result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object[] return_queue()&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(queue,size_default);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 优先级队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 优先级队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java对象内存计算</title>
      <link href="/posts/a1f3afe4/"/>
      <url>/posts/a1f3afe4/</url>
      
        <content type="html"><![CDATA[<h1 id="java对象内存计算意义"><a href="#java对象内存计算意义" class="headerlink" title="java对象内存计算意义"></a>java对象内存计算意义</h1><p>最近在学习jvm的内存模型，学到参数调优的时候，我发现这个过程需要学会计算对象大小，并且根据具体场景模拟每秒进入内存的对象大小，以此为依据进行新生代和老年代的参数设置。</p><p>在我看着文章一段段说某个方法的大小是多少，然后假设每秒可以预估多少内存进入堆中，我陷入了惶恐，这说的都是啥玩意。</p><p>为了弥补这个知识盲点，方便个人日后的学习，或者在工作中的深入调优，对象的大小计算还是需要了解的。</p><p>当然如果是需要具体的对象大小，有相关工具和方法可以测量，但在具体生产调优中，我们更多的只是需要一个预估值，学习相关知识对预估是有一定帮助的。</p><h1 id="对象大小需要考虑的点"><a href="#对象大小需要考虑的点" class="headerlink" title="对象大小需要考虑的点"></a>对象大小需要考虑的点</h1><p>需要考虑的点不多，主要三点：</p><ol><li>对象头大小</li><li>数据类型大小</li><li>对齐填充</li></ol><p>如下图：</p><p><img alt="对象大小计算" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/java_class_photo.jpg" class="lozad"></p><h2 id="对象头大小"><a href="#对象头大小" class="headerlink" title="对象头大小"></a>对象头大小</h2><h3 id="对象头主要有两部分："><a href="#对象头主要有两部分：" class="headerlink" title="对象头主要有两部分："></a>对象头主要有两部分：</h3><ol><li>markoop（对象标记）：<blockquote><p>存储对象为：对象运行时数据，如哈希码、GC标记、锁信息、线程关联信息<br>占用内存大小：64为jvm上占用 8 字节</p></blockquote></li><li>klassoop（类元信息）：<blockquote><p>存储对象为：指向方法区的instanceKlass<br>占用内存大小：4个字节</p></blockquote></li></ol><p><strong><em>由上可知：对象头占的空间是 12字节，这是固定的</em></strong></p><h3 id="markoop-和-klassoop的简单介绍"><a href="#markoop-和-klassoop的简单介绍" class="headerlink" title="markoop 和 klassoop的简单介绍"></a>markoop 和 klassoop的简单介绍</h3><p>关于这两个点，可以很深入的去研究，但我们目前只需要知道类加载后，这两者生成的大概流程即可：</p><blockquote><p>一个java类被加载到vm时，会在方法区（如果不清楚，可以等待博主后续对jvm的更新）创建一个instanceKlass，来表示类的class信息。当我们的类用new创建新对象时，会在jvm的堆上创建一个instanceOopDesc对象。该对象就包含了对象头，对象头即包含上面说的两部分。然后这个实例对象会在对应的线程栈上创建一个引用，指向该实例对象。</p></blockquote><h2 id="数据类型大小"><a href="#数据类型大小" class="headerlink" title="数据类型大小"></a>数据类型大小</h2><p>这个是java的基础知识，相信大家对下面的表不会陌生：</p><table><thead><tr><th>类型</th><th>默认值</th><th>占用内存（字节）</th></tr></thead><tbody><tr><td>boolean</td><td>false</td><td>1</td></tr><tr><td>byte</td><td>0</td><td>1</td></tr><tr><td>short</td><td>0</td><td>2</td></tr><tr><td>char</td><td>\u00001</td><td>2</td></tr><tr><td>int</td><td>0</td><td>4</td></tr><tr><td>long</td><td>0</td><td>8</td></tr><tr><td>double</td><td>0</td><td>8</td></tr><tr><td>float</td><td>0</td><td>4</td></tr></tbody></table><p>上面是8种基本类型，但在对象内存占用计算中，还需要<strong><em>第九种类型</em></strong></p><table><thead><tr><th>类型</th><th>默认值</th><th>占用内存（字节）</th></tr></thead><tbody><tr><td>对象引用变量（Refrence Varible）</td><td>null</td><td>4</td></tr></tbody></table><p>假设对象引用变量简称refV，实际对象（Referred Object）为：refO：</p><blockquote><p>refV存储引用指向的实际对象的存储地址的首地址。可以直接用==做等值判断。作为对象的引用变量，refV无论指向包装类，集合类，字符串类，自定义类，还是数组，均占用4字节。<br>refO最小占用12字节，即只有对象头，但是要对齐填充，所以最小分配的内存空间是16字节。</p></blockquote><p><strong><em>如果用jvm知识解答，refV其实是会存放到方法栈中，与本文堆存储无关，但做为统一计算的学习也无可厚非</em></strong></p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>对象的存储空间的分配单位是8字节，当对象大小不是8的整数倍的时候需要填充对齐。譬如如果对象的总大小为 22 字节，为了填充成8的整数倍，则实际的内存大小为 24 字节。</p><h2 id="样例分析"><a href="#样例分析" class="headerlink" title="样例分析"></a>样例分析</h2><p>看下面几段java代码：</p><p>样例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> test_field;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的内存大小为：</p><blockquote><p>int类型 4 字节 + 对象头 12 字节 = 16字节</p></blockquote><p>样例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> age; </span><br><span class="line">    test test_instance = <span class="keyword">new</span> test();</span><br><span class="line">    test2 test2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的内存大小为：</p><blockquote><p>double类型 8 字节 + test_instance的refv 4字节 + test2 的 4字节 + 对象头 12字节 = 8 + 4 + 4 + 12 = 28</p></blockquote><p><strong><em>因为28不是8的整数倍，所以最后为：32字节</em></strong></p><h3 id="样例2解答"><a href="#样例2解答" class="headerlink" title="样例2解答"></a>样例2解答</h3><blockquote><p>样例2中有两个对象初始化，无论是指向实例对象还是未指向实例对象，只要有类对象的引用，每个变量都占用 4 字节</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://yq.aliyun.com/articles/594507?utm_content=m_50650" target="_blank" rel="noopener">参考[1]</a><br><a href="https://juejin.im/post/5cafe99a6fb9a068553e14d2" target="_blank" rel="noopener">参考[2]</a></p><hr><center>谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
          <category> 对象内存计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> 对象头 </tag>
            
            <tag> 内存计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大排序算法的实现和相关分析</title>
      <link href="/posts/7ad6c44f/"/>
      <url>/posts/7ad6c44f/</url>
      
        <content type="html"><![CDATA[<h1 id="排序说明"><a href="#排序说明" class="headerlink" title="排序说明"></a>排序说明</h1><p>因为室友面试被问到排序算法，当时他因为知识储备问题答不上，回来和我说起面试题，我想了想，发现自己对这块也不太熟悉，所以整理了一些重要的算法，进行python实现。</p><p>本文主要会涉及几个点：</p><ol><li>每个排序的python实现</li><li>一些排序思想的介绍</li><li>记录时间复杂度和空间复杂度</li><li>最后给自己留下题目，方便日后回顾</li></ol><h1 id="排序问题"><a href="#排序问题" class="headerlink" title="排序问题"></a>排序问题</h1><p>关于排序的大概介绍如下图：</p><p><img alt="各排序时间复杂度/空间复杂度/稳定性" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/sort_time.png" class="lozad"></p><blockquote><p>简单介绍一些概念：</p><blockquote><p>稳定性：在排序的过程中，相等的数是否会交换位置，会交换位置的算法则为 <strong><em>不稳定算法</em></strong><br>时间复杂度：通过大O算法进行初略进行算法的运行时间<br>空间复杂度：用到的内存初略计算</p></blockquote></blockquote><h1 id="各排序介绍"><a href="#各排序介绍" class="headerlink" title="各排序介绍"></a>各排序介绍</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><blockquote><p>最简单的排序算法<br>稳定性：稳定（如果里面的判断是= , 则为非稳定，正常默认冒泡排序为稳定算法）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubbleSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    冒泡排序：</span></span><br><span class="line"><span class="string">    思路在 左右两个数 两两比较</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)<span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(arr)-i<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">                tmp = arr[j]</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>]</span><br><span class="line">                arr[j+<span class="number">1</span>] = tmp</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><blockquote><p>思路在：从头开始遍历，选择出最小值下标，然后进行最小值交换<br>稳定性：非稳定。<br>举例：5 8 5 2 1 第一次排序 2和5交换位置后，原先在前面的5到后面去了</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    选择排序：</span></span><br><span class="line"><span class="string">    思路在每次循环 选择最小的和当前循环的值进行转换</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    arr_len = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(arr_len):<span class="comment"># 循环数组长度</span></span><br><span class="line">        min_index = i <span class="comment"># 假设i为最小值的下标</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>,arr_len,<span class="number">1</span>):<span class="comment"># 拿最小值下标和后面的数进行比较</span></span><br><span class="line">            <span class="keyword">if</span> arr[j] &lt; arr[min_index]:</span><br><span class="line">                min_index = j <span class="comment"># 比较选出最小值</span></span><br><span class="line">        <span class="comment"># 交换最小值位置</span></span><br><span class="line">        tmp = arr[min_index]</span><br><span class="line">        arr[min_index] = arr[i]</span><br><span class="line">        arr[i] = tmp</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><blockquote><p>思路在：current 为当前值，不断往前比较，确认达到最小/最大值 往那个index插入当前值<br>稳定性：稳定</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    插入排序：</span></span><br><span class="line"><span class="string">    思路在 current 为当前值，不断往前比较，确认达到最小/最大值 往那个index插入当前值</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    arr_len = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,arr_len):<span class="comment"># 注意是从1开始，而非0</span></span><br><span class="line">        index = i<span class="number">-1</span> <span class="comment"># 当前比较数下标的前一个index</span></span><br><span class="line">        current = arr[i] <span class="comment"># 当前需要进行比较的数</span></span><br><span class="line">        <span class="keyword">while</span> index&gt;=<span class="number">0</span> <span class="keyword">and</span> arr[index] &gt; current: <span class="comment"># 当前数和前一个数进行比较</span></span><br><span class="line">            arr[index+<span class="number">1</span>] = arr[index] <span class="comment"># 如果当前数比前一个数小，把前一个数的值赋给 当前比较数</span></span><br><span class="line">            index-=<span class="number">1</span> <span class="comment"># 继续往左比较</span></span><br><span class="line">        arr[index+<span class="number">1</span>] = current <span class="comment"># 比较结束后，如果上面没有进入循环，则index+1 其实就是当前比较数</span></span><br><span class="line">                                <span class="comment"># 如果进入了循环，右边的数不断往左移，跳出循环后，把当前数赋给index + 1 位置</span></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><blockquote><p>思想在：插入排序在小数据量的时候时间是教快的，希尔的思路在于，把大数据拆分成多个分区，不同分区用插入排序进行排序，最后融合<br>稳定性：非稳定</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shellSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    希尔排序：</span></span><br><span class="line"><span class="string">    思路在 分序列进行插入排序</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">    arr_len = len(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(arr_len/<span class="number">2</span>):</span><br><span class="line">        插入排序</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><blockquote><p>快速排序是比较复杂的排序算法<br>思路在：<a href="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/fast-sort.html" target="_blank" rel="noopener">快速排序参考资料（看完立马懂）</a><br>稳定性：非稳定</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span><span class="params">(arr,start,end)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    快速排序：</span></span><br><span class="line"><span class="string">    思路在 选一个比较值 大的放右边 小的放左边 以此为逻辑递归执行</span></span><br><span class="line"><span class="string">    涉及递归，存在递归深度问题</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> start &gt;= end: <span class="keyword">return</span></span><br><span class="line">    temp = arr[start] <span class="comment"># 选出一个值作为比较值</span></span><br><span class="line">    left = start <span class="comment"># 开始下标</span></span><br><span class="line">    right = end <span class="comment"># 结束下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> left &lt; right: <span class="comment"># 判断下标没有碰面 才进行下一步操作</span></span><br><span class="line">        <span class="comment"># 外面的while用于判断是否继续进行循环比较</span></span><br><span class="line">        <span class="comment"># 里面的while用于控制范围缩小的区间</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> arr[right] &gt;= temp:<span class="comment"># 判断当前值是否小于比较值，当小于的时候则不继续循环，大于的时候则继续循环</span></span><br><span class="line">            right -= <span class="number">1</span> <span class="comment"># 一直往左进行范围缩小，直到小于比较值</span></span><br><span class="line">        <span class="keyword">while</span> left&lt;right <span class="keyword">and</span> arr[left] &lt;= temp: <span class="comment"># 和上面的循环判断相反</span></span><br><span class="line">            left += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left &lt; right: <span class="comment"># 交换两者的位置</span></span><br><span class="line">            arr[right] = arr[left] ^ arr[right]</span><br><span class="line">            arr[left] = arr[left] ^ arr[right]</span><br><span class="line">            arr[right] = arr[left] ^ arr[right]</span><br><span class="line">    <span class="comment"># 交换 比较值和left=right的值</span></span><br><span class="line">    arr[start] = arr[left]</span><br><span class="line">    arr[left] = temp</span><br><span class="line">    <span class="comment"># 以中间值左右划分，递归进行快速排序。递归会有深度问题，可以用栈的方式实现</span></span><br><span class="line">    quickSort(arr,start,left<span class="number">-1</span>)</span><br><span class="line">    quickSort(arr,left+<span class="number">1</span>,end)</span><br></pre></td></tr></table></figure><blockquote><p>下面是用栈的方式替代递归</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zhan_quickSort</span><span class="params">(arr,start,end)</span>:</span></span><br><span class="line">    stack = []</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    stack.append(start)</span><br><span class="line">    stack.append(end)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> len(stack) &gt; <span class="number">0</span>:</span><br><span class="line">        end = stack.pop()</span><br><span class="line">        start = stack.pop()</span><br><span class="line"></span><br><span class="line">        index = baseSort(arr,start,end) <span class="comment"># 这一部分是上面去除quickSort递归前面的逻辑，直接返回中间值</span></span><br><span class="line">        <span class="keyword">if</span> index+<span class="number">1</span> &lt; right:</span><br><span class="line">            stack.append(index+<span class="number">1</span>)</span><br><span class="line">            stack.append(right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> index<span class="number">-1</span> &gt; left:</span><br><span class="line">            stack.append(index<span class="number">-1</span>)</span><br><span class="line">            stack.append(left)</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><blockquote><p>思路在：用二分法 对数组进行切分，从最小值开始进行归并排序<br>稳定性：稳定</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span><span class="params">(arr)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left,right)</span>:</span></span><br><span class="line">        merged = [] <span class="comment"># 创建一个数组</span></span><br><span class="line">        i, j = <span class="number">0</span>, <span class="number">0</span> <span class="comment"># 下标判断，默认为0</span></span><br><span class="line">        left_len = len(left)</span><br><span class="line">        right_len = len(right)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> i &lt; left_len <span class="keyword">and</span> j &lt; right_len: <span class="comment"># 遍历传进来的两个数组，判断下标不会超过数组长度</span></span><br><span class="line">            <span class="keyword">if</span> left[i] &lt; right[j]: <span class="comment"># 对两个数组从0开始比较 符合条件的就把值添加到 新建的数组中</span></span><br><span class="line">                merged.append(left[i])</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                merged.append(right[j])</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 最后跳出循环，把剩余的元素给添加进 新建数组中</span></span><br><span class="line">        merged.extend(left[i:])</span><br><span class="line">        merged.extend(right[j:])</span><br><span class="line">        <span class="keyword">return</span> merged</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:<span class="keyword">return</span> arr <span class="comment"># 递归的返回条件</span></span><br><span class="line">    middle = len(arr)//<span class="number">2</span> <span class="comment"># 二分出左右两边数组</span></span><br><span class="line">    <span class="comment"># 递归左右两边数组</span></span><br><span class="line">    left = mergeSort(arr[:middle])</span><br><span class="line">    right = mergeSort(arr[middle:])</span><br><span class="line">    <span class="keyword">return</span> merge(left,right)</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><blockquote><p>堆排序是一个有意思的排序。思路在 构建顶堆，然后交换顶堆和最后的值<br>这里涉及两个概念：大顶堆 和 小顶堆<br>堆的概念: 堆指的是完全二叉树的数组对象，完全二叉树指的是 1、倒数第一层以前都为满节点 2、最后一层节点都靠左<br>大顶堆：节点值比子节点大（每个子树间比较），构建大顶堆最后排序为：升序<br>小顶堆：节点值比子节点小（每个子树间比较），构建小顶堆最后排序为：降序<br>稳定性：非稳定<br>参考资料：<a href="https://www.jianshu.com/p/d174f1862601" target="_blank" rel="noopener">堆排序[1]</a> <a href="https://www.cnblogs.com/shiqi17/p/9694938.html" target="_blank" rel="noopener">堆排序[2]</a></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(elems)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路在 先构建顶堆 然后 交换头和尾节点 再从头开始构建顶堆</span></span><br><span class="line"><span class="string">    :param elems:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">siftdown</span><span class="params">(elems, begin, end)</span>:</span> <span class="comment">#向下筛选</span></span><br><span class="line">        i, j = begin, begin*<span class="number">2</span>+<span class="number">1</span> <span class="comment">#i为父节点，j为i的左子结点</span></span><br><span class="line">        <span class="keyword">while</span> j &lt; end:</span><br><span class="line">            <span class="keyword">if</span> j+<span class="number">1</span> &lt; end <span class="keyword">and</span> elems[j] &gt; elems[j+<span class="number">1</span>]: <span class="comment">#如果左子结点大于右子结点</span></span><br><span class="line">                j += <span class="number">1</span>                              <span class="comment">#则将j指向右子结点</span></span><br><span class="line">            <span class="keyword">if</span> elems[i] &lt; elems[j]: <span class="comment">#j已经指向两个子结点中较小的位置，</span></span><br><span class="line">                <span class="keyword">break</span>        <span class="comment">#如果插入元素e小于j位置的值，则为3者中最小的</span></span><br><span class="line">            elems[i],elems[j] = elems[j],elems[i] <span class="comment"># 交换两个值，子节点替代父节点</span></span><br><span class="line">            i,j = j,j*<span class="number">2</span>+<span class="number">1</span> <span class="comment"># 把j的下标赋给i，j的值变成原j的子节点，这一步是为了交换节点后，对新的子树进行顶堆建立</span></span><br><span class="line"></span><br><span class="line">    end = len(elems)<span class="number">-1</span></span><br><span class="line">    parent = end//<span class="number">2</span><span class="number">-1</span> <span class="comment"># 取出所有有子节点的父节点</span></span><br><span class="line">    <span class="keyword">while</span> parent &gt;= <span class="number">0</span>: <span class="comment"># 构建顶堆</span></span><br><span class="line">        siftdown(elems,parent,end)</span><br><span class="line">        parent -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> end &gt; <span class="number">0</span>:</span><br><span class="line">        elems[end],elems[<span class="number">0</span>] = elems[<span class="number">0</span>],elems[end] <span class="comment"># 交换顶值和最后值</span></span><br><span class="line">        siftdown(elems,<span class="number">0</span>,end) <span class="comment"># 以首位作为父节点，重新构建顶堆</span></span><br><span class="line">        end -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> elems</span><br></pre></td></tr></table></figure><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><blockquote><p>思路在 构建一个新数组 它的下标为需要排序的数组值 它的值为该数出现的次数，最后遍历新数组按顺序取出值<br>计数排序是特殊的桶排序<br>稳定性：稳定</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countingSort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路在 构建一个新数组 它的下标为需要排序的数组值 它的值为该数出现的次数</span></span><br><span class="line"><span class="string">    :param arr:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    max_value = max(arr) <span class="comment"># 计数排序需要获取最大值</span></span><br><span class="line">    count = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(max_value+<span class="number">1</span>)] <span class="comment"># 下标为arr的值 值为计数总数</span></span><br><span class="line">    last_value = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        count[arr[i]] += <span class="number">1</span> <span class="comment"># 把需要排序的值 做为下标 进行计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(count)):</span><br><span class="line">        <span class="keyword">while</span> count[i] &gt; <span class="number">0</span>: <span class="comment"># 遍历计数值 如果大于0 则把下标添加到新的数组</span></span><br><span class="line">            last_value.append(i)</span><br><span class="line">            count[i] -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> last_value</span><br></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><blockquote><p>思路在：过个人方式把数据划分到不同的桶中（抽象概念，可以用数组实现） 然后桶内排序（桶内排序需要用到别的排序算法），遍历出来即是有序数组<br>稳定性：稳定</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(array)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    思路在：</span></span><br><span class="line"><span class="string">    通过个人方式把数据划分到不同的桶中（抽象概念，可以用数组实现） 然后桶内排序（桶内排序需要用到别的排序算法），遍历出来即是有序数组</span></span><br><span class="line"><span class="string">    :param array:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 1.创建n个空桶</span></span><br><span class="line">    min_value = min(array)</span><br><span class="line">    max_value = max(array)</span><br><span class="line">    bucket_size = max_value-min_value+<span class="number">1</span></span><br><span class="line">    new_list = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(bucket_size)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.把arr[i] 插入到bucket[n*array[i]]</span></span><br><span class="line">    <span class="keyword">for</span> data <span class="keyword">in</span> array:</span><br><span class="line">        <span class="comment"># 核心步骤在 如何划分桶 即index 的生成逻辑</span></span><br><span class="line">        index = (data-min_value)</span><br><span class="line">        new_list[index].append(data)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.桶内排序</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(bucket_size):</span><br><span class="line">        new_list[i].sort()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4.产生新的排序后的列表</span></span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(bucket_size):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(new_list[i])):</span><br><span class="line">            array[index] = new_list[i][j]</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><blockquote><p>不介绍了</p></blockquote><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ol><li>稳定和不稳定的排序算法有哪些？</li><li>哪个算法最稳定，哪个算法最快？</li><li>哪个算法使用空间最大？</li><li>列出各算法的稳定性、时间复杂度、空间复杂度 和 可手写各算法（着重在快速排序、堆排序、归并排序、插入排序）</li><li>python排序的实现：<a href="https://blog.csdn.net/yangzhongblog/article/details/8184707" target="_blank" rel="noopener">time sort</a></li></ol><hr><center>谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建windows flink idea开发测试环境</title>
      <link href="/posts/b4bb247c/"/>
      <url>/posts/b4bb247c/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建说明"><a href="#搭建说明" class="headerlink" title="搭建说明"></a>搭建说明</h1><h2 id="难易"><a href="#难易" class="headerlink" title="难易"></a>难易</h2><p>windows flink搭建十分简单，官网都有说明，我一路走下来基本没有坑</p><h2 id="记录原因"><a href="#记录原因" class="headerlink" title="记录原因"></a>记录原因</h2><p>简单却记录的原因在于：</p><blockquote><p>1、整合资料，方便快速搭建<br>2、我之前见同事搭建过，觉得牛逼，便想请教下搭建方式，询问是否有教程。结果对方回应说没有教程，靠他一点点摸索，当时听完，对方在我心目中地位瞬间上升很多档次，深刻感知自己的弱小。如今看来，不是我弱小，而是我愚蠢。我百度一番，也没发现全流程教程，所以借此记录，方便后续新手的搭建</p></blockquote><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>windows 结合 idea，可以有效快速熟悉flink语法，作为入门是很好的方式</p><h1 id="搭建步骤："><a href="#搭建步骤：" class="headerlink" title="搭建步骤："></a>搭建步骤：</h1><h2 id="基本环境"><a href="#基本环境" class="headerlink" title="基本环境"></a>基本环境</h2><blockquote><p>1、java1.8以上<br>2、scala 2.1.1 或者 scala 2.1.2 （我下载的是2.1.2）<br>3、maven 最新版本<br>4、idea 社区版<br>上面的环境，可自行百度（我都是去对应官网下载）</p></blockquote><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>这两个是官网的链接，有先后顺序。如果不想看我的教程，可以直接查看官网教程<br><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/zh/dev/projectsetup/java_api_quickstart.html" target="_blank" rel="noopener">参考链接</a><br><a href="https://ci.apache.org/projects/flink/flink-docs-release-1.9/zh/dev/projectsetup/dependencies.html" target="_blank" rel="noopener">参考链接</a></p><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><blockquote><p>具体步骤只有两步：1、maven创建项目 2、配置依赖</p></blockquote><h4 id="maven创建项目"><a href="#maven创建项目" class="headerlink" title="maven创建项目"></a>maven创建项目</h4><ul><li>打开idea，创建maven工程，按如下配置进行添加。看配置参数可知，我搭建的是1.9版本，对应的版本可以根据自己需求来<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mvn archetype:generate                               \</span><br><span class="line">  -DarchetypeGroupId=org.apache.flink              \</span><br><span class="line">  -DarchetypeArtifactId=flink-quickstart-java      \</span><br><span class="line">  -DarchetypeVersion=1.9.0</span><br></pre></td></tr></table></figure><img alt="操作图" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/flink_windows.jpg" class="lozad"></li></ul><p>配置完毕后，会进行mvn操作，等待maven操作完成，进行下一步</p><h3 id="配置依赖"><a href="#配置依赖" class="headerlink" title="配置依赖"></a>配置依赖</h3><ul><li>打开pom.xml，我们会发现有两个错误项，把那两个删除，换成下面的依赖，更新maven完成搭建</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote><p>在上面的依赖配置中，我们发现scope这个选项，如果要在本地测试，需要把scope的值设置成compile。对应maven scope的解释请看<a href="http://jskblog.xyz/posts/2d6fc607/">maven scope</a>。</p></blockquote><p>简单解释即:<br>scope为compile时，代表强依赖，打包会把依赖添加到jar包中<br>scope为provided时，打包时，依赖不添加到jar包中</p><p>flink对两种scope的使用：</p><ol><li>compile：<strong><em>用于本地测试</em></strong></li><li>provided：<strong><em>用于线上部署运行</em></strong>。依赖不需要打包到jar包中的原因是：flink线上环境有相应的jar包，如果强依赖会出现jar包冲突情况</li></ol><hr><center>创作不易，谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 环境搭建 </category>
          
          <category> flink </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows flink </tag>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>maven中scope的区别</title>
      <link href="/posts/2d6fc607/"/>
      <url>/posts/2d6fc607/</url>
      
        <content type="html"><![CDATA[<h1 id="依赖的Scope"><a href="#依赖的Scope" class="headerlink" title="依赖的Scope"></a>依赖的Scope</h1><p>最近在本地搭建flink想要熟悉语法，根据官网搭建过程中，发现maven的个别概念不熟悉，就此做个记录。<br>scope定义了类包在项目的使用阶段。项目阶段包括： 编译，运行，测试和发布。</p><h1 id="分类说明"><a href="#分类说明" class="headerlink" title="分类说明"></a>分类说明</h1><ul><li>compile<br>默认scope为compile，表示为当前依赖参与项目的编译、测试和运行阶段，属于强依赖。打包之时，会达到包里去。</li><li>test<br>该依赖仅仅参与测试相关的内容，包括测试用例的编译和执行，比如定性的Junit。</li><li>runtime<br>依赖仅参与运行周期中的使用。一般这种类库都是接口与实现相分离的类库，比如JDBC类库，在编译之时仅依赖相关的接口，在具体的运行之时，才需要具体的mysql、oracle等等数据的驱动程序。<br>此类的驱动都是为runtime的类库。</li><li>provided<br>该依赖在打包过程中，不需要打进去，这个由运行的环境来提供，比如tomcat或者基础类库等等，事实上，该依赖可以参与编译、测试和运行等周期，与compile等同。区别在于打包阶段进行了exclude操作。</li><li>system<br>使用上与provided相同，不同之处在于该依赖不从maven仓库中提取，而是从本地文件系统中提取，其会参照systemPath的属性进行提取依赖。</li><li>import<br>这个是maven2.0.9版本后出的属性，import只能在dependencyManagement的中使用，能解决maven单继承问题，import依赖关系实际上并不参与限制依赖关系的传递性。</li><li>systemPath<br>当maven依赖本地而非repository中的jar包，sytemPath指明本地jar包路径,例如：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupid</span>&gt;</span>org.hamcrest<span class="tag">&lt;/<span class="name">groupid</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactid</span>&gt;</span>hamcrest-core<span class="tag">&lt;/<span class="name">artifactid</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systempath</span>&gt;</span>$&#123;basedir&#125;/WebContent/WEB-INF/lib/hamcrest-core-1.3.jar<span class="tag">&lt;/<span class="name">systempath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="dependency中的type"><a href="#dependency中的type" class="headerlink" title="dependency中的type"></a>dependency中的type</h1><p>引入某一个依赖时，必须指定type，这是因为用于匹配dependency引用和dependencyManagement部分的最小信息集实际上是{groupId，artifactId，type，classifier}。在很多情况下，这些依赖关系将引用没有classifier的jar依赖。这允许我们将标识设置为{groupId，artifactId}，因为type的默认值是jar，并且默认classifier为null。<br>type的值一般有jar、war、pom等，声明引入的依赖的类型</p><hr><center>谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 技术技巧 </category>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven scope </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装jar包后如何用maven调用</title>
      <link href="/posts/abf5534d/"/>
      <url>/posts/abf5534d/</url>
      
        <content type="html"><![CDATA[<h1 id="安装jar包后如何用maven调用"><a href="#安装jar包后如何用maven调用" class="headerlink" title="安装jar包后如何用maven调用"></a>安装jar包后如何用maven调用</h1><p>最近有使用maven，故此做一个maven的简单记录，防止后续需要</p><p>安装自定义jar包到本地Maven库<br>当出现下列情况时：<br>1.要使用的 jar 不存在于 Maven 的中心储存库中。<br>2.您创建了一个自定义的 jar ，而另一个 Maven 项目需要使用。</p><p>远程服务器需要在settings.xml中配置server用户名密码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>n<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">username</span>&gt;</span>abc<span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">password</span>&gt;</span>12345<span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">server</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要手动将所需要的jar包存放至Maven本地资源库，可以再cmd中输入以下命令：</p><blockquote><p>mvn install:install-file -Dfile=c:\userdefined-1.0.jar -DgroupId=pers.test.code -DartifactId=userdefined -Dversion={1.0} -Dpackaging=jar</p></blockquote><p>远程库命令如下</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">mvn</span> <span class="attr">deploy:deploy-file</span> <span class="bullet">-DgroupId=com.abc.com3rd.policy</span> <span class="bullet">-DartifactId=policy-sdk</span> <span class="bullet">-Dversion=20180502102622</span> <span class="bullet">-Dpackaging=jar</span> <span class="bullet">-Dfile=D:\jar\local_policy.jar</span> <span class="bullet">-DrepositoryId=repo-huotu</span> <span class="bullet">-Durl=http://repo.abc.com:8081/nexus/content/repositories/releases/</span> <span class="bullet">-DgeneratePom=false</span></span><br><span class="line"><span class="string">各参数代表含义为：</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span><span class="string">Dmaven.test.skip=true</span>                              <span class="string">//跳过编译、测试</span></span><br><span class="line"><span class="bullet">-</span><span class="string">Dfile=D:\MvnProject\service-mvn-1.0.0.jar</span>          <span class="string">//jar包文件地址,绝对路径</span></span><br><span class="line"><span class="bullet">-</span><span class="string">DgroupId=pri.roy.mvn.test</span>                          <span class="string">//gruopId--pom坐标，自定义</span></span><br><span class="line"><span class="bullet">-</span><span class="string">DartifactId=mvn-api</span>                                <span class="string">//artifactId--pom坐标，自定义</span></span><br><span class="line"><span class="bullet">-</span><span class="string">Dversion</span>                                           <span class="string">//版本号</span></span><br><span class="line"><span class="bullet">-</span><span class="string">Dpackaging</span>                                         <span class="string">//打包方式</span></span><br><span class="line"><span class="bullet">-</span><span class="string">DrepositoryId</span>                                      <span class="string">//远程库服务器ID</span></span><br><span class="line"><span class="bullet">-</span><span class="string">Durl</span>                                               <span class="string">//远程库服务器地址</span></span><br></pre></td></tr></table></figure><p>安装成功后，在pom.xml文件中可以使用了</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>pers.test.code<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>userdefined <span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><center>谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> 技术技巧 </category>
          
          <category> maven </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
            <tag> jar包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jsdelivr加速读取github文件</title>
      <link href="/posts/5a5aec9f/"/>
      <url>/posts/5a5aec9f/</url>
      
        <content type="html"><![CDATA[<h2 id="jsdelivr是什么"><a href="#jsdelivr是什么" class="headerlink" title="jsdelivr是什么"></a>jsdelivr是什么</h2><p>github：<a href="https://github.com/jsdelivr/jsdelivr" target="_blank" rel="noopener">https://github.com/jsdelivr/jsdelivr</a><br>官网：<a href="https://www.jsdelivr.com/" target="_blank" rel="noopener">https://www.jsdelivr.com/</a><br>免费的公用CDN加速服务网（CDN是就近服务器访问，所以会加速）</p><h2 id="作用是什么"><a href="#作用是什么" class="headerlink" title="作用是什么"></a>作用是什么</h2><p>可以加速访问文件、图片，而本文章则介绍如何利用jsdelivr加速访问github照片为主<br>之所以需要用到jsdelivr加速访问照片，在于可<strong>方便快速</strong>管理 hexo 里面的图片链接</p><h2 id="如何操作"><a href="#如何操作" class="headerlink" title="如何操作"></a>如何操作</h2><p>举我个人例子的大致过程：</p><ol><li>生成新的github仓库</li><li>构建文件夹用于存放照片文件 <a href="https://github.com/JSK520/blog_web/blob/master/photos/person.jpg" target="_blank" rel="noopener">github目录</a></li><li>关键一步：点击项目上端的<strong>release</strong> 创建版本：<br><img alt="release的创建简介" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/photos/release_v1.jpg" class="lozad"></li><li>创建好后，点击进入图片链接：<br>那我的做例子，进入github照片路径为：<br><a href="https://github.com/JSK520/blog_web/blob/v1.1/photos/release_v1.jpg" target="_blank" rel="noopener">https://github.com/JSK520/blog_web/blob/v1.1/photos/release_v1.jpg</a></li><li>把对应路径变更为以下方式即可<br><a href="https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/photos/release_v1.jpg" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/photos/release_v1.jpg</a></li></ol><p>仔细看我们发现：<br><a href="https://github.com/JSK520/blog_web/blob/v1.1/" target="_blank" rel="noopener">https://github.com/JSK520/blog_web/blob/v1.1/</a><br>这个前缀替换成了<br><a href="https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/JSK520/blog_web@v1.1/</a><br>而 /photos/release_v1.jpg 是github的文件名</p><hr><center>谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> jsdelivr </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jsdelivr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown 样式总结</title>
      <link href="/posts/c491c9ac/"/>
      <url>/posts/c491c9ac/</url>
      
        <content type="html"><![CDATA[<blockquote><p>markdown的样式总结</p></blockquote><hr><p><strong>本文由佳境协助完成，就此感谢他，做个小广告：</strong></p><blockquote><ul><li>Welcome To <a href="http://shmily-qjj.top/" target="_blank" rel="noopener">佳境博客</a></li><li>他的<a href="https://github.com/Shmilyqjj" target="_blank" rel="noopener">GitHub</a>地址</li><li>他的<a href="http://music.163.com/artist?id=13610347" target="_blank" rel="noopener">CloudMusic</a>地址</li></ul></blockquote><h3 id="HEXO目录结构"><a href="#HEXO目录结构" class="headerlink" title="HEXO目录结构"></a>HEXO目录结构</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">|--</span> <span class="string">_config.yml</span>     <span class="string">全局配置（网站名称作者主题部署等）</span></span><br><span class="line"><span class="string">|--</span> <span class="string">package.json</span>    <span class="string">框架参数（框架依赖拆件及其版本）</span></span><br><span class="line"><span class="string">|--</span> <span class="string">scaffolds</span>       <span class="string">脚手架（通用MarkDown模板，新建文章时，hexo根据这个目录的文件进行构建）</span></span><br><span class="line"><span class="string">|--</span> <span class="string">source</span>          <span class="string">网页资源（css,js,images,文章等）</span></span><br><span class="line">   <span class="string">|--</span> <span class="string">_posts</span>       <span class="string">博客文章（写文章的地方）</span></span><br><span class="line"><span class="string">|--</span> <span class="string">themes</span>          <span class="string">主题目录</span></span><br><span class="line"><span class="string">|--</span> <span class="string">.gitignore</span>      <span class="string">Git忽略文件或目录</span></span><br><span class="line"><span class="string">|--</span> <span class="string">package.json</span>    <span class="string">框架参数（框架依赖拆件及其版本）</span></span><br></pre></td></tr></table></figure><hr><h1 id="MarkDown语法字典"><a href="#MarkDown语法字典" class="headerlink" title="MarkDown语法字典"></a>MarkDown语法字典</h1><ul><li><p>标题</p><h1 id="一级标题-最大"><a href="#一级标题-最大" class="headerlink" title="一级标题(最大)"></a>一级标题(最大)</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></li><li><p>字体</p></li><li><p>斜体文本*<br><em>斜体文本</em></p></li><li><p><em>粗体文本*</em><br><strong>粗体文本</strong></p></li><li><p><strong>粗斜体文本*</strong><br><strong><em>粗斜体文本</em></strong><br><u>带下划线文本</u></p></li><li><p>脚注</p></li></ul><ul><li><p>列表<br>无序列表用* + -三种符号表示</p><ul><li>列表嵌套</li></ul><ol><li>有序列表第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素<blockquote><p>列表中可以使用区块<br>列表中可以使用区块</p></blockquote></li></ul></li><li>有序列表第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素<ul><li>最多第三层嵌套</li></ul><ul><li>最多第三层嵌套</li></ul><ul><li>最多第三层嵌套</li></ul></li></ul></li></ol></li><li><p>区块引用</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套…</p><blockquote><p>第二层嵌套…</p></blockquote></blockquote><ul><li>list</li><li>list</li></ul><ul><li>list</li></ul></blockquote></li><li><p>代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">        System.out.<span class="title">println</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="comment">//tab或者四个空格</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l = []</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">copy.copy(l)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> qjj = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//定义代码块并指定语言-&gt;显示高亮</span></span><br></pre></td></tr></table></figure><ul><li>链接<br>这是我的云音乐主页<a href="http://music.163.com/artist?id=13610347" target="_blank" rel="noopener">CloudMusic</a><br>直接显示链接地址: <a href="http://music.163.com/artist?id=13610347" target="_blank" rel="noopener">http://music.163.com/artist?id=13610347</a><br>我的网易云主页高级链接<a href="http://music.163.com/artist?id=13610347" target="_blank" rel="noopener">cm-1</a><br>我的网易云主页高级链接<a href="http://music.163.com/artist?id=13610347" target="_blank" rel="noopener">cm-2</a></li></ul><ul><li><p>添加图片<br><img alt="alt lalala" data-src="http://m.qpic.cn/psb?/V10aWFGB3ChSVt/4Onwe7wF*pBhD4*iWs0KetAXGTu6fMrAUJrxWkkB4fk!/b/dL8AAAAAAAAA&bo=hANYAgAAAAADB*8!&rf=viewer_4" class="lozad"><br><img alt="alt hahaha" title="图片注释呀!鼠标放那会弹出注释!" data-src="http://m.qpic.cn/psb?/V10aWFGB3ChSVt/4Onwe7wF*pBhD4*iWs0KetAXGTu6fMrAUJrxWkkB4fk!/b/dL8AAAAAAAAA&bo=hANYAgAAAAADB*8!&rf=viewer_4" class="lozad"></p><img width="30%" title="可以使用html的标签,控制图片大小,title悬停显示文字" data-src="http://m.qpic.cn/psb?/V10aWFGB3ChSVt/4Onwe7wF*pBhD4*iWs0KetAXGTu6fMrAUJrxWkkB4fk!/b/dL8AAAAAAAAA&bo=hANYAgAAAAADB*8!&rf=viewer_4" class="lozad"></li><li><p>图片链接<br><a href="https://www.alluxio.io/slack" target="_blank" rel="noopener"><img alt="Slack" data-src="https://slackin.alluxio.io/badge.svg" class="lozad"></a><br><a href="https://www.alluxio.io/download" target="_blank" rel="noopener"><img alt="Release" data-src="https://img.shields.io/github/release/alluxio/alluxio/all.svg" class="lozad"></a><br><a href="https://hub.docker.com/r/alluxio/alluxio" target="_blank" rel="noopener"><img alt="Docker Pulls" data-src="https://img.shields.io/docker/pulls/alluxio/alluxio.svg" class="lozad"></a><br><a href="https://www.alluxio.io/docs" target="_blank" rel="noopener"><img alt="Documentation" data-src="https://img.shields.io/badge/docs-reference-blue.svg" class="lozad"></a><br><a href="https://twitter.com/intent/follow?screen_name=alluxio" target="_blank" rel="noopener"><img alt="Twitter Follow" data-src="https://img.shields.io/twitter/follow/alluxio.svg?label=Follow&style=social" class="lozad"></a><br><a href="https://github.com/Alluxio/alluxio/blob/master/LICENSE" target="_blank" rel="noopener"><img alt="License" data-src="https://img.shields.io/github/license/alluxio/alluxio.svg" class="lozad"></a></p></li></ul><ul><li>添加表格<br><code>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行</code><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>表格</td><td>表格</td></tr><tr><td>表格</td><td>表格</td></tr><tr><td>表格</td><td>表格</td></tr></tbody></table></li></ul><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><ul><li>对HTML的支持<br><code>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Ctrl<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span>+<span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Alt<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span>+<span class="tag">&lt;<span class="name">kbd</span>&gt;</span>Del<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span> 重启电脑</span><br></pre></td></tr></table></figure><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><p><strong>文本加粗</strong><br><strong>*正常显示*号配合文本加粗体\</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">以下支持反斜杠转义</span></span><br><span class="line"><span class="string">\</span>   <span class="string">反斜线</span></span><br><span class="line"><span class="string">`</span>   <span class="string">反引号</span></span><br><span class="line"><span class="string">*</span>   <span class="string">星号</span></span><br><span class="line"><span class="string">_</span>   <span class="string">下划线</span></span><br><span class="line"><span class="string">&#123;&#125;</span>  <span class="string">花括号</span></span><br><span class="line"><span class="string">[]</span>  <span class="string">方括号</span></span><br><span class="line"><span class="string">()</span>  <span class="string">小括号</span></span><br><span class="line"><span class="comment">#   井字号</span></span><br><span class="line"><span class="string">+</span>   <span class="string">加号</span></span><br><span class="line"><span class="bullet">-</span>   <span class="string">减号</span></span><br><span class="line"><span class="string">.</span>   <span class="string">英文句点</span></span><br><span class="line"><span class="string">!</span>   <span class="string">感叹号</span></span><br></pre></td></tr></table></figure><ul><li>数学公式  需要开启 mathjax: 0 0改为1<br><code>当需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现</code></li></ul><p>$$<br>\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}<br>\mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \<br>\frac{\partial X}{\partial u} &amp;  \frac{\partial Y}{\partial u} &amp; 0 \<br>\frac{\partial X}{\partial v} &amp;  \frac{\partial Y}{\partial v} &amp; 0 \<br>\end{vmatrix}<br>$$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}<br>$$</p><hr><h3 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks:"></a>Thanks:</h3><p><a href="https://github.com/mashirozx/Sakura/" target="_blank" rel="noopener">Sakura</a> Hexo theme.</p><p><a href="https://sakura.hojun.cn" target="_blank" rel="noopener">hojun</a> Modified into the theme.</p><hr><center>谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo 总结</title>
      <link href="/posts/424111dd/"/>
      <url>/posts/424111dd/</url>
      
        <content type="html"><![CDATA[<p>无法提交theme：<br>下面以yelee做例子<br>cd theme/<br>删除 .git文件<br>git rm -cached yelee/<br>git add yelee</p><p>如果出现 lock情况：<br>rm -f xx/.git/index.lock</p><h2 id="github照片上传："><a href="#github照片上传：" class="headerlink" title="github照片上传："></a>github照片上传：</h2><p>查看远程仓库的版本：<br>git ls-remote</p><p>直接覆盖线上版本：<br>git push -f origin master:tags/v1.1</p><hr><center>谢谢你的支持~~</center><center class="half">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/wechat_shikai.jpg" class="lozad">    <img width="300" data-src="https://cdn.jsdelivr.net/gh/JSK520/blog_web@1.1/photos/alipay_shikai.jpg" class="lozad"></center>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
